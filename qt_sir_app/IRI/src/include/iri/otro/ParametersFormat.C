//   NOTE: this is a machine generated file--editing not recommended
//
// ParametersFormat.C - class member functions for ASN.1 module ParametersFormat
//
//   This file was generated by snacc on Thu May 29 18:14:31 2008
//   UBC snacc written by Mike Sample
//   A couple of enhancements made by IBM European Networking Center


#include "ParametersFormat.h"

//------------------------------------------------------------------------------
// value defs

const AsnOid domainIDO (4, 0, 2, 2, 1, 7);

const AsnInt maxNrOfPoints (15);


//------------------------------------------------------------------------------
// class member definitions:

TetraLocationSeq::TetraLocationSeq()
{
  ci = NULL;
}

//------------------------------------------------------------------------------
//Begin this is not generated by snacc

TetraLocationSeq::TetraLocationSeq(unsigned int pmcc, unsigned int pmnc, unsigned int plai)
{
    mcc = pmcc;
    mnc = pmnc;
    lai = plai;
    ci = NULL;
}
TetraLocationSeq::TetraLocationSeq(unsigned int pmcc, unsigned int pmnc, unsigned int plai, unsigned int pci)
{
    mcc = pmcc;
    mnc = pmnc;
    lai = plai;
    ci = new AsnInt(pci);
}

//End this is not generated by snacc
//------------------------------------------------------------------------------

TetraLocationSeq::TetraLocationSeq (const TetraLocationSeq &)
{
  Asn1Error << "use of incompletely defined TetraLocationSeq::TetraLocationSeq (const TetraLocationSeq &)" << std::endl;
  abort();
}

TetraLocationSeq::~TetraLocationSeq()
{
  delete ci;
}

AsnType *TetraLocationSeq::Clone() const
{
  return new TetraLocationSeq;
}

#if SNACC_DEEP_COPY
TetraLocationSeq &TetraLocationSeq::operator = (const TetraLocationSeq &that)
#else // SNACC_DEEP_COPY
TetraLocationSeq &TetraLocationSeq::operator = (const TetraLocationSeq &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    mcc = that.mcc;
    mnc = that.mnc;
    lai = that.lai;
    if (that.ci)
    {
      if (!ci)
        ci = new AsnInt;
      *ci = *that.ci;
    }
    else
    {
      delete ci;
      ci = NULL;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined TetraLocationSeq &TetraLocationSeq::operator = (const TetraLocationSeq &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
TetraLocationSeq::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

  if (NOT_NULL (ci))
  {
    l = ci->BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, CNTX, PRIM, 4);
    totalLen += l;
  }

    l = lai.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, CNTX, PRIM, 3);
    totalLen += l;

    l = mnc.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, CNTX, PRIM, 2);
    totalLen += l;

    l = mcc.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, CNTX, PRIM, 1);
    totalLen += l;

  return totalLen;
} // TetraLocationSeq::BEncContent


void TetraLocationSeq::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    mcc.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << std::endl;
    longjmp (env, -100);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    mnc.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << std::endl;
    longjmp (env, -101);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    lai.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << std::endl;
    longjmp (env, -102);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    ci = new AsnInt;
    ci->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << std::endl;
    longjmp (env, -103);
  }
  else
    return;
} // TetraLocationSeq::BDecContent

AsnLen TetraLocationSeq::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void TetraLocationSeq::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "TetraLocationSeq::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -104);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int TetraLocationSeq::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int TetraLocationSeq::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void TetraLocationSeq::Print (std::ostream &os) const
{
  os << "{ -- SEQUENCE --" << std::endl;
  indentG += stdIndentG;

  {
    Indent (os, indentG);
    os << "mcc ";
    os << mcc;
    os << "," << std::endl;
  }

  {
    Indent (os, indentG);
    os << "mnc ";
    os << mnc;
    os << "," << std::endl;
  }

  {
    Indent (os, indentG);
    os << "lai ";
    os << lai;
    os << "," << std::endl;
  }

  if (NOT_NULL (ci))
  {
    os << ","<< std::endl;
    Indent (os, indentG);
    os << "ci ";
    os << *ci;
  }
  else
  {
    Indent (os, indentG);
    os << "ci ";
    os << "-- void --";
    os << std::endl;
  }

  os << std::endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // TetraLocationSeq::Print


CallingPartyNumber::CallingPartyNumber()
{
  choiceId = iSUP_FormatCid;
#if TCL
  iSUP_Format = new AsnOcts;
#else
  iSUP_Format = NULL; // incomplete initialization of mandatory element!
#endif // TCL
}

//-----------------------------------------------------------------------------------------
//Begin of this was not created by snacc
CallingPartyNumber::CallingPartyNumber(ChoiceIdEnum pchoiceId, const char *str,int longitud)
{
    choiceId=pchoiceId;
    switch( choiceId )
    {
        case iSUP_FormatCid:
                    iSUP_Format = new AsnOcts;
                    iSUP_Format->Set(str,longitud);
                    break;
        case dSS1_FormatCid:
                    dSS1_Format = new AsnOcts;
                    dSS1_Format->Set(str);
                    break;
        case mAP_FormatCid:
                    mAP_Format = new AsnOcts;
                    mAP_Format->Set(str);
                    break;
    }
}

//Endof this was not created by snacc
//-----------------------------------------------------------------------------------------

CallingPartyNumber::CallingPartyNumber (const CallingPartyNumber &)
{
  Asn1Error << "use of incompletely defined CallingPartyNumber::CallingPartyNumber (const CallingPartyNumber &)" << std::endl;
  abort();
}

CallingPartyNumber::~CallingPartyNumber()
{
  switch (choiceId)
  {
    case iSUP_FormatCid:
      delete iSUP_Format;
      break;
    case dSS1_FormatCid:
      delete dSS1_Format;
      break;
    case mAP_FormatCid:
      delete mAP_Format;
      break;
  } // end of switch
} // end of destructor

AsnType *CallingPartyNumber::Clone() const
{
  return new CallingPartyNumber;
}

#if SNACC_DEEP_COPY
CallingPartyNumber &CallingPartyNumber::operator = (const CallingPartyNumber &that)
#else // SNACC_DEEP_COPY
CallingPartyNumber &CallingPartyNumber::operator = (const CallingPartyNumber &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    switch (choiceId)
    {
      case iSUP_FormatCid:
        delete iSUP_Format;
        break;
      case dSS1_FormatCid:
        delete dSS1_Format;
        break;
      case mAP_FormatCid:
        delete mAP_Format;
        break;
    }
    switch (choiceId = that.choiceId)
    {
      case iSUP_FormatCid:
        iSUP_Format = new AsnOcts;
        *iSUP_Format = *that.iSUP_Format;
        break;
      case dSS1_FormatCid:
        dSS1_Format = new AsnOcts;
        *dSS1_Format = *that.dSS1_Format;
        break;
      case mAP_FormatCid:
        mAP_Format = new AsnOcts;
        *mAP_Format = *that.mAP_Format;
        break;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined CallingPartyNumber &CallingPartyNumber::operator = (const CallingPartyNumber &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
CallingPartyNumber::BEncContent (BUF_TYPE b)
{
  AsnLen l;
  switch (choiceId)
  {
    case iSUP_FormatCid:
      l = iSUP_Format->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 1);
      break;

    case dSS1_FormatCid:
      l = dSS1_Format->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 2);
      break;

    case mAP_FormatCid:
      l = mAP_Format->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 3);
      break;

  } // end switch
  return l;
} // CallingPartyNumber::BEncContent


void CallingPartyNumber::BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  switch (tag)
  {
    case MAKE_TAG_ID (CNTX, PRIM, 1):
    case MAKE_TAG_ID (CNTX, CONS, 1):
      choiceId = iSUP_FormatCid;
      iSUP_Format = new AsnOcts;
        iSUP_Format->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 2):
    case MAKE_TAG_ID (CNTX, CONS, 2):
      choiceId = dSS1_FormatCid;
      dSS1_Format = new AsnOcts;
        dSS1_Format->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 3):
    case MAKE_TAG_ID (CNTX, CONS, 3):
      choiceId = mAP_FormatCid;
      mAP_Format = new AsnOcts;
        mAP_Format->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    default:
      Asn1Error << "ERROR - unexpected tag in CHOICE" << std::endl;
      longjmp (env, -105);
      break;
  } // end switch
} // CallingPartyNumber::BDecContent


AsnLen CallingPartyNumber::BEnc (BUF_TYPE b)
{
    AsnLen l;
    l = BEncContent (b);
    return l;
}

void CallingPartyNumber::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
    AsnLen elmtLen;
    AsnTag tag;

    /*  CHOICEs are a special case - grab identifying tag */
    /*  this allows easier handling of nested CHOICEs */
    tag = BDecTag (b, bytesDecoded, env);
    elmtLen = BDecLen (b, bytesDecoded, env);
    BDecContent (b, tag, elmtLen, bytesDecoded, env);
}

int CallingPartyNumber::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int CallingPartyNumber::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void CallingPartyNumber::Print (std::ostream &os) const
{
  switch (choiceId)
  {
    case iSUP_FormatCid:
      os << "iSUP-Format ";
      if (iSUP_Format)
        os << *iSUP_Format;
      else
        os << "-- void3 --\n";
      break;

    case dSS1_FormatCid:
      os << "dSS1-Format ";
      if (dSS1_Format)
        os << *dSS1_Format;
      else
        os << "-- void3 --\n";
      break;

    case mAP_FormatCid:
      os << "mAP-Format ";
      if (mAP_Format)
        os << *mAP_Format;
      else
        os << "-- void3 --\n";
      break;

  } // end of switch
} // CallingPartyNumber::Print

CalledPartyNumber::CalledPartyNumber()
{
  choiceId = iSUP_FormatCid;
#if TCL
  iSUP_Format = new AsnOcts;
#else
  iSUP_Format = NULL; // incomplete initialization of mandatory element!
#endif // TCL
}


//-----------------------------------------------------------------------------------------
//Begin of this was not created by snacc
CalledPartyNumber::CalledPartyNumber(ChoiceIdEnum pchoiceId, const char *str, int longitud)
{
    choiceId=pchoiceId;
    switch( choiceId )
    {
        case iSUP_FormatCid:
                    iSUP_Format = new AsnOcts;
                    iSUP_Format->Set(str,longitud);
                    break;
        case mAP_FormatCid:
                    mAP_Format = new AsnOcts;
                    mAP_Format->Set(str);
                    break;
        case dSS1_FormatCid:
                    dSS1_Format = new AsnOcts;
                    dSS1_Format->Set(str);
                    break;
    }
}

//Endof this was not created by snacc
//-----------------------------------------------------------------------------------------


CalledPartyNumber::CalledPartyNumber (const CalledPartyNumber &)
{
  Asn1Error << "use of incompletely defined CalledPartyNumber::CalledPartyNumber (const CalledPartyNumber &)" << std::endl;
  abort();
}

CalledPartyNumber::~CalledPartyNumber()
{
  switch (choiceId)
  {
    case iSUP_FormatCid:
      delete iSUP_Format;
      break;
    case mAP_FormatCid:
      delete mAP_Format;
      break;
    case dSS1_FormatCid:
      delete dSS1_Format;
      break;
  } // end of switch
} // end of destructor

AsnType *CalledPartyNumber::Clone() const
{
  return new CalledPartyNumber;
}

#if SNACC_DEEP_COPY
CalledPartyNumber &CalledPartyNumber::operator = (const CalledPartyNumber &that)
#else // SNACC_DEEP_COPY
CalledPartyNumber &CalledPartyNumber::operator = (const CalledPartyNumber &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    switch (choiceId)
    {
      case iSUP_FormatCid:
        delete iSUP_Format;
        break;
      case mAP_FormatCid:
        delete mAP_Format;
        break;
      case dSS1_FormatCid:
        delete dSS1_Format;
        break;
    }
    switch (choiceId = that.choiceId)
    {
      case iSUP_FormatCid:
        iSUP_Format = new AsnOcts;
        *iSUP_Format = *that.iSUP_Format;
        break;
      case mAP_FormatCid:
        mAP_Format = new AsnOcts;
        *mAP_Format = *that.mAP_Format;
        break;
      case dSS1_FormatCid:
        dSS1_Format = new AsnOcts;
        *dSS1_Format = *that.dSS1_Format;
        break;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined CalledPartyNumber &CalledPartyNumber::operator = (const CalledPartyNumber &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
CalledPartyNumber::BEncContent (BUF_TYPE b)
{
  AsnLen l;
  switch (choiceId)
  {
    case iSUP_FormatCid:
      l = iSUP_Format->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 1);
      break;

    case mAP_FormatCid:
      l = mAP_Format->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 2);
      break;

    case dSS1_FormatCid:
      l = dSS1_Format->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 3);
      break;

  } // end switch
  return l;
} // CalledPartyNumber::BEncContent


void CalledPartyNumber::BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  switch (tag)
  {
    case MAKE_TAG_ID (CNTX, PRIM, 1):
    case MAKE_TAG_ID (CNTX, CONS, 1):
      choiceId = iSUP_FormatCid;
      iSUP_Format = new AsnOcts;
        iSUP_Format->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 2):
    case MAKE_TAG_ID (CNTX, CONS, 2):
      choiceId = mAP_FormatCid;
      mAP_Format = new AsnOcts;
        mAP_Format->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 3):
    case MAKE_TAG_ID (CNTX, CONS, 3):
      choiceId = dSS1_FormatCid;
      dSS1_Format = new AsnOcts;
        dSS1_Format->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    default:
      Asn1Error << "ERROR - unexpected tag in CHOICE" << std::endl;
      longjmp (env, -106);
      break;
  } // end switch
} // CalledPartyNumber::BDecContent


AsnLen CalledPartyNumber::BEnc (BUF_TYPE b)
{
    AsnLen l;
    l = BEncContent (b);
    return l;
}

void CalledPartyNumber::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
    AsnLen elmtLen;
    AsnTag tag;

    /*  CHOICEs are a special case - grab identifying tag */
    /*  this allows easier handling of nested CHOICEs */
    tag = BDecTag (b, bytesDecoded, env);
    elmtLen = BDecLen (b, bytesDecoded, env);
    BDecContent (b, tag, elmtLen, bytesDecoded, env);
}

int CalledPartyNumber::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int CalledPartyNumber::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void CalledPartyNumber::Print (std::ostream &os) const
{
  switch (choiceId)
  {
    case iSUP_FormatCid:
      os << "iSUP-Format ";
      if (iSUP_Format)
        os << *iSUP_Format;
      else
        os << "-- void3 --\n";
      break;

    case mAP_FormatCid:
      os << "mAP-Format ";
      if (mAP_Format)
        os << *mAP_Format;
      else
        os << "-- void3 --\n";
      break;

    case dSS1_FormatCid:
      os << "dSS1-Format ";
      if (dSS1_Format)
        os << *dSS1_Format;
      else
        os << "-- void3 --\n";
      break;

  } // end of switch
} // CalledPartyNumber::Print

AsnType *ISUP_parameters::Clone() const
{
  return new ISUP_parameters;
}

AsnLen ISUP_parameters::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SET_TAG_CODE);
  return l;
}

void ISUP_parameters::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SET_TAG_CODE))
  {
    Asn1Error << "ISUP_parameters::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -107);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

ISUP_parameters::ISUP_parameters (const ISUP_parameters &)
{
  Asn1Error << "use of incompletely defined ISUP_parameters::ISUP_parameters (const ISUP_parameters &)" << std::endl;
  abort();
}

ISUP_parameters::~ISUP_parameters()
{
  SetCurrToFirst();
  for (; Curr() != NULL; RemoveCurrFromList())
    ;
} // end of destructor

#if SNACC_DEEP_COPY
ISUP_parameters &ISUP_parameters::operator = (const ISUP_parameters &that)
#else // SNACC_DEEP_COPY
ISUP_parameters &ISUP_parameters::operator = (const ISUP_parameters &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    SetCurrToFirst();
    for (; Curr(); RemoveCurrFromList())
      ;

    //that.SetCurrToFirst();
    //for (; that.Curr(); that.GoNext())
    //  AppendCopy (*that.Curr());
    for (const AsnListElmt *run=that.first; run; run=run->next)
      AppendCopy (*run->elmt);
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined ISUP_parameters &ISUP_parameters::operator = (const ISUP_parameters &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

void ISUP_parameters::Print (std::ostream &os) const
{
    os << "{ -- SEQUENCE/SET OF -- " << std::endl;
    indentG += stdIndentG;
    //SetCurrToFirst();
    //for (; Curr() != NULL; GoNext())
    for (const AsnListElmt *run=first; run; run=run->next)
    {
        Indent (os, indentG);
        //os << *Curr();
        os << *run->elmt;
        //if (Curr() != Last())
        if (run != last)
            os << ",";
        os << std::endl;
    }
    indentG -= stdIndentG;
    Indent (os, indentG);
    os << "}\n";
} // Print


void  ISUP_parameters::SetCurrElmt (unsigned long int index)
{
  unsigned long int i;
  curr = first;
  if (count)
    for (i = 0; (i < (count-1)) && (i < index); i++)
      curr = curr->next;
} // ISUP_parameters::SetCurrElmt


unsigned long int  ISUP_parameters::GetCurrElmtIndex()
{
    unsigned long int i;
    AsnListElmt *tmp;
    if (curr != NULL)
    {
        for (i = 0, tmp = first; tmp != NULL; i++)
        {
            if (tmp == curr)
                return i;
            else
                tmp = tmp->next;
        }
    }
    return count;
} // ISUP_parameters::GetCurrElmtIndex


// alloc new list elmt, put at end of list
//  and return the component type
AsnOcts *ISUP_parameters::Append()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt  = new AsnOcts;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // ISUP_parameters::Append


// alloc new list elmt, put at begining of list
//  and return the component type
AsnOcts  *ISUP_parameters::Prepend()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // ISUP_parameters::Prepend


// alloc new list elmt, insert it before the
// current element and return the component type
// if the current element is null, the new element
// is placed at the beginning of the list.
AsnOcts  *ISUP_parameters::InsertBefore()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // ISUP_parameters::InsertBefore


// alloc new list elmt, insert it after the
// current element and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
AsnOcts *ISUP_parameters::InsertAfter()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // ISUP_parameters::InsertAfter


ISUP_parameters  &ISUP_parameters::AppendCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return *this;
} // AppendCopy


ISUP_parameters  &ISUP_parameters::PrependCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return *this;
} // ISUP_parameters::PrependCopy


// alloc new list elmt, insert it before the
// current element, copy the given elmt into the new elmt
// and return the component type.
// if the current element is null, the new element
// is placed at the beginning of the list.
ISUP_parameters &ISUP_parameters::InsertBeforeAndCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;

    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return *this;
} // ISUP_parameters::InsertBeforeAndCopy


// alloc new list elmt, insert it after the
// current element, copy given elmt in to new elmt
//  and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
ISUP_parameters  &ISUP_parameters::InsertAfterAndCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return *this;
} // ISUP_parameters::InsertAfterAndCopy


// remove current element from list if current element is not NULL
// The new current element will be the next element.
// If the current element is the last element in the list
// the second but last element will become the new current element.
void ISUP_parameters::RemoveCurrFromList()
{
    AsnListElmt *del_elmt;

    if (curr != NULL)
    {
        del_elmt = curr;
        count--;

        if (count == 0)
            first = last = curr = NULL;
        else if (curr == first)
        {
            curr = first= first->next;
            first->prev = NULL;
        }
        else if (curr == last)
        {
            curr = last = last->prev;
            last->next = NULL;
        }
        else
        {
            curr->prev->next = curr->next;
            curr->next->prev = curr->prev;
        }

        delete del_elmt->elmt;
        delete del_elmt;
    }
}


AsnLen ISUP_parameters::BEncContent (BUF_TYPE b)
{
    AsnListElmt *currElmt;
    AsnLen elmtLen;
    AsnLen totalLen = 0;
    for (currElmt = last; currElmt != NULL; currElmt = currElmt->prev)
    {
        elmtLen = currElmt->elmt->BEncContent (b);
    elmtLen += BEncDefLen (b, elmtLen);

    elmtLen += BEncTag1 (b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
        totalLen += elmtLen;
    }
    return totalLen;
} // ISUP_parameters::BEncContent


void  ISUP_parameters::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0,
                                  AsnLen &bytesDecoded, ENV_TYPE env)
{
    AsnOcts *listElmt;
    AsnTag tag1;
    AsnLen listBytesDecoded = 0;
    AsnLen elmtLen1;

    while ((listBytesDecoded < elmtLen0) || (elmtLen0 == INDEFINITE_LEN))
    {
        tag1 = BDecTag (b, listBytesDecoded, env);
        if ((tag1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
        {
            BDEC_2ND_EOC_OCTET (b, listBytesDecoded, env);
            break;
        }
        if ((tag1 != MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
         && (tag1 != MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
        {
            Asn1Error << "Unexpected Tag" << std::endl;
            longjmp (env, -108);
        }

        elmtLen1 = BDecLen (b, listBytesDecoded, env);
        listElmt = Append();
        listElmt->BDecContent (b, tag1, elmtLen1, listBytesDecoded, env);
    }

    bytesDecoded += listBytesDecoded;
} // ISUP_parameters::BDecContent


AsnType *DSS1_parameters_codeset_0::Clone() const
{
  return new DSS1_parameters_codeset_0;
}

AsnLen DSS1_parameters_codeset_0::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SET_TAG_CODE);
  return l;
}

void DSS1_parameters_codeset_0::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SET_TAG_CODE))
  {
    Asn1Error << "DSS1_parameters_codeset_0::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -109);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

DSS1_parameters_codeset_0::DSS1_parameters_codeset_0 (const DSS1_parameters_codeset_0 &)
{
  Asn1Error << "use of incompletely defined DSS1_parameters_codeset_0::DSS1_parameters_codeset_0 (const DSS1_parameters_codeset_0 &)" << std::endl;
  abort();
}

DSS1_parameters_codeset_0::~DSS1_parameters_codeset_0()
{
  SetCurrToFirst();
  for (; Curr() != NULL; RemoveCurrFromList())
    ;
} // end of destructor

#if SNACC_DEEP_COPY
DSS1_parameters_codeset_0 &DSS1_parameters_codeset_0::operator = (const DSS1_parameters_codeset_0 &that)
#else // SNACC_DEEP_COPY
DSS1_parameters_codeset_0 &DSS1_parameters_codeset_0::operator = (const DSS1_parameters_codeset_0 &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    SetCurrToFirst();
    for (; Curr(); RemoveCurrFromList())
      ;

    //that.SetCurrToFirst();
    //for (; that.Curr(); that.GoNext())
    //  AppendCopy (*that.Curr());
    for (const AsnListElmt *run=that.first; run; run=run->next)
      AppendCopy (*run->elmt);
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined DSS1_parameters_codeset_0 &DSS1_parameters_codeset_0::operator = (const DSS1_parameters_codeset_0 &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

void DSS1_parameters_codeset_0::Print (std::ostream &os) const
{
    os << "{ -- SEQUENCE/SET OF -- " << std::endl;
    indentG += stdIndentG;
    //SetCurrToFirst();
    //for (; Curr() != NULL; GoNext())
    for (const AsnListElmt *run=first; run; run=run->next)
    {
        Indent (os, indentG);
        //os << *Curr();
        os << *run->elmt;
        //if (Curr() != Last())
        if (run != last)
            os << ",";
        os << std::endl;
    }
    indentG -= stdIndentG;
    Indent (os, indentG);
    os << "}\n";
} // Print


void  DSS1_parameters_codeset_0::SetCurrElmt (unsigned long int index)
{
  unsigned long int i;
  curr = first;
  if (count)
    for (i = 0; (i < (count-1)) && (i < index); i++)
      curr = curr->next;
} // DSS1_parameters_codeset_0::SetCurrElmt


unsigned long int  DSS1_parameters_codeset_0::GetCurrElmtIndex()
{
    unsigned long int i;
    AsnListElmt *tmp;
    if (curr != NULL)
    {
        for (i = 0, tmp = first; tmp != NULL; i++)
        {
            if (tmp == curr)
                return i;
            else
                tmp = tmp->next;
        }
    }
    return count;
} // DSS1_parameters_codeset_0::GetCurrElmtIndex


// alloc new list elmt, put at end of list
//  and return the component type
AsnOcts *DSS1_parameters_codeset_0::Append()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt  = new AsnOcts;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // DSS1_parameters_codeset_0::Append


// alloc new list elmt, put at begining of list
//  and return the component type
AsnOcts  *DSS1_parameters_codeset_0::Prepend()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // DSS1_parameters_codeset_0::Prepend


// alloc new list elmt, insert it before the
// current element and return the component type
// if the current element is null, the new element
// is placed at the beginning of the list.
AsnOcts  *DSS1_parameters_codeset_0::InsertBefore()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // DSS1_parameters_codeset_0::InsertBefore


// alloc new list elmt, insert it after the
// current element and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
AsnOcts *DSS1_parameters_codeset_0::InsertAfter()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // DSS1_parameters_codeset_0::InsertAfter


DSS1_parameters_codeset_0  &DSS1_parameters_codeset_0::AppendCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return *this;
} // AppendCopy


DSS1_parameters_codeset_0  &DSS1_parameters_codeset_0::PrependCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return *this;
} // DSS1_parameters_codeset_0::PrependCopy


// alloc new list elmt, insert it before the
// current element, copy the given elmt into the new elmt
// and return the component type.
// if the current element is null, the new element
// is placed at the beginning of the list.
DSS1_parameters_codeset_0 &DSS1_parameters_codeset_0::InsertBeforeAndCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;

    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return *this;
} // DSS1_parameters_codeset_0::InsertBeforeAndCopy


// alloc new list elmt, insert it after the
// current element, copy given elmt in to new elmt
//  and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
DSS1_parameters_codeset_0  &DSS1_parameters_codeset_0::InsertAfterAndCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return *this;
} // DSS1_parameters_codeset_0::InsertAfterAndCopy


// remove current element from list if current element is not NULL
// The new current element will be the next element.
// If the current element is the last element in the list
// the second but last element will become the new current element.
void DSS1_parameters_codeset_0::RemoveCurrFromList()
{
    AsnListElmt *del_elmt;

    if (curr != NULL)
    {
        del_elmt = curr;
        count--;

        if (count == 0)
            first = last = curr = NULL;
        else if (curr == first)
        {
            curr = first= first->next;
            first->prev = NULL;
        }
        else if (curr == last)
        {
            curr = last = last->prev;
            last->next = NULL;
        }
        else
        {
            curr->prev->next = curr->next;
            curr->next->prev = curr->prev;
        }

        delete del_elmt->elmt;
        delete del_elmt;
    }
}


AsnLen DSS1_parameters_codeset_0::BEncContent (BUF_TYPE b)
{
    AsnListElmt *currElmt;
    AsnLen elmtLen;
    AsnLen totalLen = 0;
    for (currElmt = last; currElmt != NULL; currElmt = currElmt->prev)
    {
        elmtLen = currElmt->elmt->BEncContent (b);
    elmtLen += BEncDefLen (b, elmtLen);

    elmtLen += BEncTag1 (b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
        totalLen += elmtLen;
    }
    return totalLen;
} // DSS1_parameters_codeset_0::BEncContent


void  DSS1_parameters_codeset_0::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0,
                                  AsnLen &bytesDecoded, ENV_TYPE env)
{
    AsnOcts *listElmt;
    AsnTag tag1;
    AsnLen listBytesDecoded = 0;
    AsnLen elmtLen1;

    while ((listBytesDecoded < elmtLen0) || (elmtLen0 == INDEFINITE_LEN))
    {
        tag1 = BDecTag (b, listBytesDecoded, env);
        if ((tag1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
        {
            BDEC_2ND_EOC_OCTET (b, listBytesDecoded, env);
            break;
        }
        if ((tag1 != MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
         && (tag1 != MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
        {
            Asn1Error << "Unexpected Tag" << std::endl;
            longjmp (env, -110);
        }

        elmtLen1 = BDecLen (b, listBytesDecoded, env);
        listElmt = Append();
        listElmt->BDecContent (b, tag1, elmtLen1, listBytesDecoded, env);
    }

    bytesDecoded += listBytesDecoded;
} // DSS1_parameters_codeset_0::BDecContent


AsnType *MAP_parameters::Clone() const
{
  return new MAP_parameters;
}

AsnLen MAP_parameters::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SET_TAG_CODE);
  return l;
}

void MAP_parameters::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SET_TAG_CODE))
  {
    Asn1Error << "MAP_parameters::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -111);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

MAP_parameters::MAP_parameters (const MAP_parameters &)
{
  Asn1Error << "use of incompletely defined MAP_parameters::MAP_parameters (const MAP_parameters &)" << std::endl;
  abort();
}

MAP_parameters::~MAP_parameters()
{
  SetCurrToFirst();
  for (; Curr() != NULL; RemoveCurrFromList())
    ;
} // end of destructor

#if SNACC_DEEP_COPY
MAP_parameters &MAP_parameters::operator = (const MAP_parameters &that)
#else // SNACC_DEEP_COPY
MAP_parameters &MAP_parameters::operator = (const MAP_parameters &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    SetCurrToFirst();
    for (; Curr(); RemoveCurrFromList())
      ;

    //that.SetCurrToFirst();
    //for (; that.Curr(); that.GoNext())
    //  AppendCopy (*that.Curr());
    for (const AsnListElmt *run=that.first; run; run=run->next)
      AppendCopy (*run->elmt);
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined MAP_parameters &MAP_parameters::operator = (const MAP_parameters &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

void MAP_parameters::Print (std::ostream &os) const
{
    os << "{ -- SEQUENCE/SET OF -- " << std::endl;
    indentG += stdIndentG;
    //SetCurrToFirst();
    //for (; Curr() != NULL; GoNext())
    for (const AsnListElmt *run=first; run; run=run->next)
    {
        Indent (os, indentG);
        //os << *Curr();
        os << *run->elmt;
        //if (Curr() != Last())
        if (run != last)
            os << ",";
        os << std::endl;
    }
    indentG -= stdIndentG;
    Indent (os, indentG);
    os << "}\n";
} // Print


void  MAP_parameters::SetCurrElmt (unsigned long int index)
{
  unsigned long int i;
  curr = first;
  if (count)
    for (i = 0; (i < (count-1)) && (i < index); i++)
      curr = curr->next;
} // MAP_parameters::SetCurrElmt


unsigned long int  MAP_parameters::GetCurrElmtIndex()
{
    unsigned long int i;
    AsnListElmt *tmp;
    if (curr != NULL)
    {
        for (i = 0, tmp = first; tmp != NULL; i++)
        {
            if (tmp == curr)
                return i;
            else
                tmp = tmp->next;
        }
    }
    return count;
} // MAP_parameters::GetCurrElmtIndex


// alloc new list elmt, put at end of list
//  and return the component type
AsnOcts *MAP_parameters::Append()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt  = new AsnOcts;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // MAP_parameters::Append


// alloc new list elmt, put at begining of list
//  and return the component type
AsnOcts  *MAP_parameters::Prepend()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // MAP_parameters::Prepend


// alloc new list elmt, insert it before the
// current element and return the component type
// if the current element is null, the new element
// is placed at the beginning of the list.
AsnOcts  *MAP_parameters::InsertBefore()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // MAP_parameters::InsertBefore


// alloc new list elmt, insert it after the
// current element and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
AsnOcts *MAP_parameters::InsertAfter()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // MAP_parameters::InsertAfter


MAP_parameters  &MAP_parameters::AppendCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return *this;
} // AppendCopy


MAP_parameters  &MAP_parameters::PrependCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return *this;
} // MAP_parameters::PrependCopy


// alloc new list elmt, insert it before the
// current element, copy the given elmt into the new elmt
// and return the component type.
// if the current element is null, the new element
// is placed at the beginning of the list.
MAP_parameters &MAP_parameters::InsertBeforeAndCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;

    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return *this;
} // MAP_parameters::InsertBeforeAndCopy


// alloc new list elmt, insert it after the
// current element, copy given elmt in to new elmt
//  and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
MAP_parameters  &MAP_parameters::InsertAfterAndCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return *this;
} // MAP_parameters::InsertAfterAndCopy


// remove current element from list if current element is not NULL
// The new current element will be the next element.
// If the current element is the last element in the list
// the second but last element will become the new current element.
void MAP_parameters::RemoveCurrFromList()
{
    AsnListElmt *del_elmt;

    if (curr != NULL)
    {
        del_elmt = curr;
        count--;

        if (count == 0)
            first = last = curr = NULL;
        else if (curr == first)
        {
            curr = first= first->next;
            first->prev = NULL;
        }
        else if (curr == last)
        {
            curr = last = last->prev;
            last->next = NULL;
        }
        else
        {
            curr->prev->next = curr->next;
            curr->next->prev = curr->prev;
        }

        delete del_elmt->elmt;
        delete del_elmt;
    }
}


AsnLen MAP_parameters::BEncContent (BUF_TYPE b)
{
    AsnListElmt *currElmt;
    AsnLen elmtLen;
    AsnLen totalLen = 0;
    for (currElmt = last; currElmt != NULL; currElmt = currElmt->prev)
    {
        elmtLen = currElmt->elmt->BEncContent (b);
    elmtLen += BEncDefLen (b, elmtLen);

    elmtLen += BEncTag1 (b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
        totalLen += elmtLen;
    }
    return totalLen;
} // MAP_parameters::BEncContent


void  MAP_parameters::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0,
                                  AsnLen &bytesDecoded, ENV_TYPE env)
{
    AsnOcts *listElmt;
    AsnTag tag1;
    AsnLen listBytesDecoded = 0;
    AsnLen elmtLen1;

    while ((listBytesDecoded < elmtLen0) || (elmtLen0 == INDEFINITE_LEN))
    {
        tag1 = BDecTag (b, listBytesDecoded, env);
        if ((tag1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
        {
            BDEC_2ND_EOC_OCTET (b, listBytesDecoded, env);
            break;
        }
        if ((tag1 != MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
         && (tag1 != MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
        {
            Asn1Error << "Unexpected Tag" << std::endl;
            longjmp (env, -112);
        }

        elmtLen1 = BDecLen (b, listBytesDecoded, env);
        listElmt = Append();
        listElmt->BDecContent (b, tag1, elmtLen1, listBytesDecoded, env);
    }

    bytesDecoded += listBytesDecoded;
} // MAP_parameters::BDecContent


AsnType *Other_Services::Clone() const
{
  return new Other_Services;
}

AsnLen Other_Services::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SET_TAG_CODE);
  return l;
}

void Other_Services::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SET_TAG_CODE))
  {
    Asn1Error << "Other_Services::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -113);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

Other_Services::Other_Services (const Other_Services &)
{
  Asn1Error << "use of incompletely defined Other_Services::Other_Services (const Other_Services &)" << std::endl;
  abort();
}

Other_Services::~Other_Services()
{
  SetCurrToFirst();
  for (; Curr() != NULL; RemoveCurrFromList())
    ;
} // end of destructor

#if SNACC_DEEP_COPY
Other_Services &Other_Services::operator = (const Other_Services &that)
#else // SNACC_DEEP_COPY
Other_Services &Other_Services::operator = (const Other_Services &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    SetCurrToFirst();
    for (; Curr(); RemoveCurrFromList())
      ;

    //that.SetCurrToFirst();
    //for (; that.Curr(); that.GoNext())
    //  AppendCopy (*that.Curr());
    for (const AsnListElmt *run=that.first; run; run=run->next)
      AppendCopy (*run->elmt);
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined Other_Services &Other_Services::operator = (const Other_Services &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

void Other_Services::Print (std::ostream &os) const
{
    os << "{ -- SEQUENCE/SET OF -- " << std::endl;
    indentG += stdIndentG;
    //SetCurrToFirst();
    //for (; Curr() != NULL; GoNext())
    for (const AsnListElmt *run=first; run; run=run->next)
    {
        Indent (os, indentG);
        //os << *Curr();
        os << *run->elmt;
        //if (Curr() != Last())
        if (run != last)
            os << ",";
        os << std::endl;
    }
    indentG -= stdIndentG;
    Indent (os, indentG);
    os << "}\n";
} // Print


void  Other_Services::SetCurrElmt (unsigned long int index)
{
  unsigned long int i;
  curr = first;
  if (count)
    for (i = 0; (i < (count-1)) && (i < index); i++)
      curr = curr->next;
} // Other_Services::SetCurrElmt


unsigned long int  Other_Services::GetCurrElmtIndex()
{
    unsigned long int i;
    AsnListElmt *tmp;
    if (curr != NULL)
    {
        for (i = 0, tmp = first; tmp != NULL; i++)
        {
            if (tmp == curr)
                return i;
            else
                tmp = tmp->next;
        }
    }
    return count;
} // Other_Services::GetCurrElmtIndex


// alloc new list elmt, put at end of list
//  and return the component type
AsnOcts *Other_Services::Append()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt  = new AsnOcts;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // Other_Services::Append


// alloc new list elmt, put at begining of list
//  and return the component type
AsnOcts  *Other_Services::Prepend()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // Other_Services::Prepend


// alloc new list elmt, insert it before the
// current element and return the component type
// if the current element is null, the new element
// is placed at the beginning of the list.
AsnOcts  *Other_Services::InsertBefore()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // Other_Services::InsertBefore


// alloc new list elmt, insert it after the
// current element and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
AsnOcts *Other_Services::InsertAfter()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // Other_Services::InsertAfter


Other_Services  &Other_Services::AppendCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return *this;
} // AppendCopy


Other_Services  &Other_Services::PrependCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return *this;
} // Other_Services::PrependCopy


// alloc new list elmt, insert it before the
// current element, copy the given elmt into the new elmt
// and return the component type.
// if the current element is null, the new element
// is placed at the beginning of the list.
Other_Services &Other_Services::InsertBeforeAndCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;

    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return *this;
} // Other_Services::InsertBeforeAndCopy


// alloc new list elmt, insert it after the
// current element, copy given elmt in to new elmt
//  and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
Other_Services  &Other_Services::InsertAfterAndCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return *this;
} // Other_Services::InsertAfterAndCopy


// remove current element from list if current element is not NULL
// The new current element will be the next element.
// If the current element is the last element in the list
// the second but last element will become the new current element.
void Other_Services::RemoveCurrFromList()
{
    AsnListElmt *del_elmt;

    if (curr != NULL)
    {
        del_elmt = curr;
        count--;

        if (count == 0)
            first = last = curr = NULL;
        else if (curr == first)
        {
            curr = first= first->next;
            first->prev = NULL;
        }
        else if (curr == last)
        {
            curr = last = last->prev;
            last->next = NULL;
        }
        else
        {
            curr->prev->next = curr->next;
            curr->next->prev = curr->prev;
        }

        delete del_elmt->elmt;
        delete del_elmt;
    }
}


AsnLen Other_Services::BEncContent (BUF_TYPE b)
{
    AsnListElmt *currElmt;
    AsnLen elmtLen;
    AsnLen totalLen = 0;
    for (currElmt = last; currElmt != NULL; currElmt = currElmt->prev)
    {
        elmtLen = currElmt->elmt->BEncContent (b);
    elmtLen += BEncDefLen (b, elmtLen);

    elmtLen += BEncTag1 (b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
        totalLen += elmtLen;
    }
    return totalLen;
} // Other_Services::BEncContent


void  Other_Services::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0,
                                  AsnLen &bytesDecoded, ENV_TYPE env)
{
    AsnOcts *listElmt;
    AsnTag tag1;
    AsnLen listBytesDecoded = 0;
    AsnLen elmtLen1;

    while ((listBytesDecoded < elmtLen0) || (elmtLen0 == INDEFINITE_LEN))
    {
        tag1 = BDecTag (b, listBytesDecoded, env);
        if ((tag1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
        {
            BDEC_2ND_EOC_OCTET (b, listBytesDecoded, env);
            break;
        }
        if ((tag1 != MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
         && (tag1 != MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
        {
            Asn1Error << "Unexpected Tag" << std::endl;
            longjmp (env, -114);
        }

        elmtLen1 = BDecLen (b, listBytesDecoded, env);
        listElmt = Append();
        listElmt->BDecContent (b, tag1, elmtLen1, listBytesDecoded, env);
    }

    bytesDecoded += listBytesDecoded;
} // Other_Services::BDecContent


AsnType *ISUP_SS_parameters::Clone() const
{
  return new ISUP_SS_parameters;
}

AsnLen ISUP_SS_parameters::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SET_TAG_CODE);
  return l;
}

void ISUP_SS_parameters::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SET_TAG_CODE))
  {
    Asn1Error << "ISUP_SS_parameters::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -115);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

ISUP_SS_parameters::ISUP_SS_parameters (const ISUP_SS_parameters &)
{
  Asn1Error << "use of incompletely defined ISUP_SS_parameters::ISUP_SS_parameters (const ISUP_SS_parameters &)" << std::endl;
  abort();
}

ISUP_SS_parameters::~ISUP_SS_parameters()
{
  SetCurrToFirst();
  for (; Curr() != NULL; RemoveCurrFromList())
    ;
} // end of destructor

#if SNACC_DEEP_COPY
ISUP_SS_parameters &ISUP_SS_parameters::operator = (const ISUP_SS_parameters &that)
#else // SNACC_DEEP_COPY
ISUP_SS_parameters &ISUP_SS_parameters::operator = (const ISUP_SS_parameters &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    SetCurrToFirst();
    for (; Curr(); RemoveCurrFromList())
      ;

    //that.SetCurrToFirst();
    //for (; that.Curr(); that.GoNext())
    //  AppendCopy (*that.Curr());
    for (const AsnListElmt *run=that.first; run; run=run->next)
      AppendCopy (*run->elmt);
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined ISUP_SS_parameters &ISUP_SS_parameters::operator = (const ISUP_SS_parameters &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

void ISUP_SS_parameters::Print (std::ostream &os) const
{
    os << "{ -- SEQUENCE/SET OF -- " << std::endl;
    indentG += stdIndentG;
    //SetCurrToFirst();
    //for (; Curr() != NULL; GoNext())
    for (const AsnListElmt *run=first; run; run=run->next)
    {
        Indent (os, indentG);
        //os << *Curr();
        os << *run->elmt;
        //if (Curr() != Last())
        if (run != last)
            os << ",";
        os << std::endl;
    }
    indentG -= stdIndentG;
    Indent (os, indentG);
    os << "}\n";
} // Print


void  ISUP_SS_parameters::SetCurrElmt (unsigned long int index)
{
  unsigned long int i;
  curr = first;
  if (count)
    for (i = 0; (i < (count-1)) && (i < index); i++)
      curr = curr->next;
} // ISUP_SS_parameters::SetCurrElmt


unsigned long int  ISUP_SS_parameters::GetCurrElmtIndex()
{
    unsigned long int i;
    AsnListElmt *tmp;
    if (curr != NULL)
    {
        for (i = 0, tmp = first; tmp != NULL; i++)
        {
            if (tmp == curr)
                return i;
            else
                tmp = tmp->next;
        }
    }
    return count;
} // ISUP_SS_parameters::GetCurrElmtIndex


// alloc new list elmt, put at end of list
//  and return the component type
AsnOcts *ISUP_SS_parameters::Append()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt  = new AsnOcts;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // ISUP_SS_parameters::Append


// alloc new list elmt, put at begining of list
//  and return the component type
AsnOcts  *ISUP_SS_parameters::Prepend()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // ISUP_SS_parameters::Prepend


// alloc new list elmt, insert it before the
// current element and return the component type
// if the current element is null, the new element
// is placed at the beginning of the list.
AsnOcts  *ISUP_SS_parameters::InsertBefore()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // ISUP_SS_parameters::InsertBefore


// alloc new list elmt, insert it after the
// current element and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
AsnOcts *ISUP_SS_parameters::InsertAfter()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // ISUP_SS_parameters::InsertAfter


ISUP_SS_parameters  &ISUP_SS_parameters::AppendCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return *this;
} // AppendCopy


ISUP_SS_parameters  &ISUP_SS_parameters::PrependCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return *this;
} // ISUP_SS_parameters::PrependCopy


// alloc new list elmt, insert it before the
// current element, copy the given elmt into the new elmt
// and return the component type.
// if the current element is null, the new element
// is placed at the beginning of the list.
ISUP_SS_parameters &ISUP_SS_parameters::InsertBeforeAndCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;

    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return *this;
} // ISUP_SS_parameters::InsertBeforeAndCopy


// alloc new list elmt, insert it after the
// current element, copy given elmt in to new elmt
//  and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
ISUP_SS_parameters  &ISUP_SS_parameters::InsertAfterAndCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return *this;
} // ISUP_SS_parameters::InsertAfterAndCopy


// remove current element from list if current element is not NULL
// The new current element will be the next element.
// If the current element is the last element in the list
// the second but last element will become the new current element.
void ISUP_SS_parameters::RemoveCurrFromList()
{
    AsnListElmt *del_elmt;

    if (curr != NULL)
    {
        del_elmt = curr;
        count--;

        if (count == 0)
            first = last = curr = NULL;
        else if (curr == first)
        {
            curr = first= first->next;
            first->prev = NULL;
        }
        else if (curr == last)
        {
            curr = last = last->prev;
            last->next = NULL;
        }
        else
        {
            curr->prev->next = curr->next;
            curr->next->prev = curr->prev;
        }

        delete del_elmt->elmt;
        delete del_elmt;
    }
}


AsnLen ISUP_SS_parameters::BEncContent (BUF_TYPE b)
{
    AsnListElmt *currElmt;
    AsnLen elmtLen;
    AsnLen totalLen = 0;
    for (currElmt = last; currElmt != NULL; currElmt = currElmt->prev)
    {
        elmtLen = currElmt->elmt->BEncContent (b);
    elmtLen += BEncDefLen (b, elmtLen);

    elmtLen += BEncTag1 (b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
        totalLen += elmtLen;
    }
    return totalLen;
} // ISUP_SS_parameters::BEncContent


void  ISUP_SS_parameters::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0,
                                  AsnLen &bytesDecoded, ENV_TYPE env)
{
    AsnOcts *listElmt;
    AsnTag tag1;
    AsnLen listBytesDecoded = 0;
    AsnLen elmtLen1;

    while ((listBytesDecoded < elmtLen0) || (elmtLen0 == INDEFINITE_LEN))
    {
        tag1 = BDecTag (b, listBytesDecoded, env);
        if ((tag1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
        {
            BDEC_2ND_EOC_OCTET (b, listBytesDecoded, env);
            break;
        }
        if ((tag1 != MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
         && (tag1 != MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
        {
            Asn1Error << "Unexpected Tag" << std::endl;
            longjmp (env, -116);
        }

        elmtLen1 = BDecLen (b, listBytesDecoded, env);
        listElmt = Append();
        listElmt->BDecContent (b, tag1, elmtLen1, listBytesDecoded, env);
    }

    bytesDecoded += listBytesDecoded;
} // ISUP_SS_parameters::BDecContent


AsnType *DSS1_SS_parameters_codeset_0::Clone() const
{
  return new DSS1_SS_parameters_codeset_0;
}

AsnLen DSS1_SS_parameters_codeset_0::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SET_TAG_CODE);
  return l;
}

void DSS1_SS_parameters_codeset_0::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SET_TAG_CODE))
  {
    Asn1Error << "DSS1_SS_parameters_codeset_0::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -117);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

DSS1_SS_parameters_codeset_0::DSS1_SS_parameters_codeset_0 (const DSS1_SS_parameters_codeset_0 &)
{
  Asn1Error << "use of incompletely defined DSS1_SS_parameters_codeset_0::DSS1_SS_parameters_codeset_0 (const DSS1_SS_parameters_codeset_0 &)" << std::endl;
  abort();
}

DSS1_SS_parameters_codeset_0::~DSS1_SS_parameters_codeset_0()
{
  SetCurrToFirst();
  for (; Curr() != NULL; RemoveCurrFromList())
    ;
} // end of destructor

#if SNACC_DEEP_COPY
DSS1_SS_parameters_codeset_0 &DSS1_SS_parameters_codeset_0::operator = (const DSS1_SS_parameters_codeset_0 &that)
#else // SNACC_DEEP_COPY
DSS1_SS_parameters_codeset_0 &DSS1_SS_parameters_codeset_0::operator = (const DSS1_SS_parameters_codeset_0 &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    SetCurrToFirst();
    for (; Curr(); RemoveCurrFromList())
      ;

    //that.SetCurrToFirst();
    //for (; that.Curr(); that.GoNext())
    //  AppendCopy (*that.Curr());
    for (const AsnListElmt *run=that.first; run; run=run->next)
      AppendCopy (*run->elmt);
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined DSS1_SS_parameters_codeset_0 &DSS1_SS_parameters_codeset_0::operator = (const DSS1_SS_parameters_codeset_0 &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

void DSS1_SS_parameters_codeset_0::Print (std::ostream &os) const
{
    os << "{ -- SEQUENCE/SET OF -- " << std::endl;
    indentG += stdIndentG;
    //SetCurrToFirst();
    //for (; Curr() != NULL; GoNext())
    for (const AsnListElmt *run=first; run; run=run->next)
    {
        Indent (os, indentG);
        //os << *Curr();
        os << *run->elmt;
        //if (Curr() != Last())
        if (run != last)
            os << ",";
        os << std::endl;
    }
    indentG -= stdIndentG;
    Indent (os, indentG);
    os << "}\n";
} // Print


void  DSS1_SS_parameters_codeset_0::SetCurrElmt (unsigned long int index)
{
  unsigned long int i;
  curr = first;
  if (count)
    for (i = 0; (i < (count-1)) && (i < index); i++)
      curr = curr->next;
} // DSS1_SS_parameters_codeset_0::SetCurrElmt


unsigned long int  DSS1_SS_parameters_codeset_0::GetCurrElmtIndex()
{
    unsigned long int i;
    AsnListElmt *tmp;
    if (curr != NULL)
    {
        for (i = 0, tmp = first; tmp != NULL; i++)
        {
            if (tmp == curr)
                return i;
            else
                tmp = tmp->next;
        }
    }
    return count;
} // DSS1_SS_parameters_codeset_0::GetCurrElmtIndex


// alloc new list elmt, put at end of list
//  and return the component type
AsnOcts *DSS1_SS_parameters_codeset_0::Append()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt  = new AsnOcts;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // DSS1_SS_parameters_codeset_0::Append


// alloc new list elmt, put at begining of list
//  and return the component type
AsnOcts  *DSS1_SS_parameters_codeset_0::Prepend()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // DSS1_SS_parameters_codeset_0::Prepend


// alloc new list elmt, insert it before the
// current element and return the component type
// if the current element is null, the new element
// is placed at the beginning of the list.
AsnOcts  *DSS1_SS_parameters_codeset_0::InsertBefore()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // DSS1_SS_parameters_codeset_0::InsertBefore


// alloc new list elmt, insert it after the
// current element and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
AsnOcts *DSS1_SS_parameters_codeset_0::InsertAfter()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // DSS1_SS_parameters_codeset_0::InsertAfter


DSS1_SS_parameters_codeset_0  &DSS1_SS_parameters_codeset_0::AppendCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return *this;
} // AppendCopy


DSS1_SS_parameters_codeset_0  &DSS1_SS_parameters_codeset_0::PrependCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return *this;
} // DSS1_SS_parameters_codeset_0::PrependCopy


// alloc new list elmt, insert it before the
// current element, copy the given elmt into the new elmt
// and return the component type.
// if the current element is null, the new element
// is placed at the beginning of the list.
DSS1_SS_parameters_codeset_0 &DSS1_SS_parameters_codeset_0::InsertBeforeAndCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;

    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return *this;
} // DSS1_SS_parameters_codeset_0::InsertBeforeAndCopy


// alloc new list elmt, insert it after the
// current element, copy given elmt in to new elmt
//  and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
DSS1_SS_parameters_codeset_0  &DSS1_SS_parameters_codeset_0::InsertAfterAndCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return *this;
} // DSS1_SS_parameters_codeset_0::InsertAfterAndCopy


// remove current element from list if current element is not NULL
// The new current element will be the next element.
// If the current element is the last element in the list
// the second but last element will become the new current element.
void DSS1_SS_parameters_codeset_0::RemoveCurrFromList()
{
    AsnListElmt *del_elmt;

    if (curr != NULL)
    {
        del_elmt = curr;
        count--;

        if (count == 0)
            first = last = curr = NULL;
        else if (curr == first)
        {
            curr = first= first->next;
            first->prev = NULL;
        }
        else if (curr == last)
        {
            curr = last = last->prev;
            last->next = NULL;
        }
        else
        {
            curr->prev->next = curr->next;
            curr->next->prev = curr->prev;
        }

        delete del_elmt->elmt;
        delete del_elmt;
    }
}


AsnLen DSS1_SS_parameters_codeset_0::BEncContent (BUF_TYPE b)
{
    AsnListElmt *currElmt;
    AsnLen elmtLen;
    AsnLen totalLen = 0;
    for (currElmt = last; currElmt != NULL; currElmt = currElmt->prev)
    {
        elmtLen = currElmt->elmt->BEncContent (b);
    elmtLen += BEncDefLen (b, elmtLen);

    elmtLen += BEncTag1 (b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
        totalLen += elmtLen;
    }
    return totalLen;
} // DSS1_SS_parameters_codeset_0::BEncContent


void  DSS1_SS_parameters_codeset_0::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0,
                                  AsnLen &bytesDecoded, ENV_TYPE env)
{
    AsnOcts *listElmt;
    AsnTag tag1;
    AsnLen listBytesDecoded = 0;
    AsnLen elmtLen1;

    while ((listBytesDecoded < elmtLen0) || (elmtLen0 == INDEFINITE_LEN))
    {
        tag1 = BDecTag (b, listBytesDecoded, env);
        if ((tag1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
        {
            BDEC_2ND_EOC_OCTET (b, listBytesDecoded, env);
            break;
        }
        if ((tag1 != MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
         && (tag1 != MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
        {
            Asn1Error << "Unexpected Tag" << std::endl;
            longjmp (env, -118);
        }

        elmtLen1 = BDecLen (b, listBytesDecoded, env);
        listElmt = Append();
        listElmt->BDecContent (b, tag1, elmtLen1, listBytesDecoded, env);
    }

    bytesDecoded += listBytesDecoded;
} // DSS1_SS_parameters_codeset_0::BDecContent


AsnType *DSS1_SS_parameters_codeset_4::Clone() const
{
  return new DSS1_SS_parameters_codeset_4;
}

AsnLen DSS1_SS_parameters_codeset_4::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SET_TAG_CODE);
  return l;
}

void DSS1_SS_parameters_codeset_4::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SET_TAG_CODE))
  {
    Asn1Error << "DSS1_SS_parameters_codeset_4::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -119);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

DSS1_SS_parameters_codeset_4::DSS1_SS_parameters_codeset_4 (const DSS1_SS_parameters_codeset_4 &)
{
  Asn1Error << "use of incompletely defined DSS1_SS_parameters_codeset_4::DSS1_SS_parameters_codeset_4 (const DSS1_SS_parameters_codeset_4 &)" << std::endl;
  abort();
}

DSS1_SS_parameters_codeset_4::~DSS1_SS_parameters_codeset_4()
{
  SetCurrToFirst();
  for (; Curr() != NULL; RemoveCurrFromList())
    ;
} // end of destructor

#if SNACC_DEEP_COPY
DSS1_SS_parameters_codeset_4 &DSS1_SS_parameters_codeset_4::operator = (const DSS1_SS_parameters_codeset_4 &that)
#else // SNACC_DEEP_COPY
DSS1_SS_parameters_codeset_4 &DSS1_SS_parameters_codeset_4::operator = (const DSS1_SS_parameters_codeset_4 &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    SetCurrToFirst();
    for (; Curr(); RemoveCurrFromList())
      ;

    //that.SetCurrToFirst();
    //for (; that.Curr(); that.GoNext())
    //  AppendCopy (*that.Curr());
    for (const AsnListElmt *run=that.first; run; run=run->next)
      AppendCopy (*run->elmt);
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined DSS1_SS_parameters_codeset_4 &DSS1_SS_parameters_codeset_4::operator = (const DSS1_SS_parameters_codeset_4 &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

void DSS1_SS_parameters_codeset_4::Print (std::ostream &os) const
{
    os << "{ -- SEQUENCE/SET OF -- " << std::endl;
    indentG += stdIndentG;
    //SetCurrToFirst();
    //for (; Curr() != NULL; GoNext())
    for (const AsnListElmt *run=first; run; run=run->next)
    {
        Indent (os, indentG);
        //os << *Curr();
        os << *run->elmt;
        //if (Curr() != Last())
        if (run != last)
            os << ",";
        os << std::endl;
    }
    indentG -= stdIndentG;
    Indent (os, indentG);
    os << "}\n";
} // Print


void  DSS1_SS_parameters_codeset_4::SetCurrElmt (unsigned long int index)
{
  unsigned long int i;
  curr = first;
  if (count)
    for (i = 0; (i < (count-1)) && (i < index); i++)
      curr = curr->next;
} // DSS1_SS_parameters_codeset_4::SetCurrElmt


unsigned long int  DSS1_SS_parameters_codeset_4::GetCurrElmtIndex()
{
    unsigned long int i;
    AsnListElmt *tmp;
    if (curr != NULL)
    {
        for (i = 0, tmp = first; tmp != NULL; i++)
        {
            if (tmp == curr)
                return i;
            else
                tmp = tmp->next;
        }
    }
    return count;
} // DSS1_SS_parameters_codeset_4::GetCurrElmtIndex


// alloc new list elmt, put at end of list
//  and return the component type
AsnOcts *DSS1_SS_parameters_codeset_4::Append()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt  = new AsnOcts;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // DSS1_SS_parameters_codeset_4::Append


// alloc new list elmt, put at begining of list
//  and return the component type
AsnOcts  *DSS1_SS_parameters_codeset_4::Prepend()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // DSS1_SS_parameters_codeset_4::Prepend


// alloc new list elmt, insert it before the
// current element and return the component type
// if the current element is null, the new element
// is placed at the beginning of the list.
AsnOcts  *DSS1_SS_parameters_codeset_4::InsertBefore()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // DSS1_SS_parameters_codeset_4::InsertBefore


// alloc new list elmt, insert it after the
// current element and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
AsnOcts *DSS1_SS_parameters_codeset_4::InsertAfter()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // DSS1_SS_parameters_codeset_4::InsertAfter


DSS1_SS_parameters_codeset_4  &DSS1_SS_parameters_codeset_4::AppendCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return *this;
} // AppendCopy


DSS1_SS_parameters_codeset_4  &DSS1_SS_parameters_codeset_4::PrependCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return *this;
} // DSS1_SS_parameters_codeset_4::PrependCopy


// alloc new list elmt, insert it before the
// current element, copy the given elmt into the new elmt
// and return the component type.
// if the current element is null, the new element
// is placed at the beginning of the list.
DSS1_SS_parameters_codeset_4 &DSS1_SS_parameters_codeset_4::InsertBeforeAndCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;

    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return *this;
} // DSS1_SS_parameters_codeset_4::InsertBeforeAndCopy


// alloc new list elmt, insert it after the
// current element, copy given elmt in to new elmt
//  and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
DSS1_SS_parameters_codeset_4  &DSS1_SS_parameters_codeset_4::InsertAfterAndCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return *this;
} // DSS1_SS_parameters_codeset_4::InsertAfterAndCopy


// remove current element from list if current element is not NULL
// The new current element will be the next element.
// If the current element is the last element in the list
// the second but last element will become the new current element.
void DSS1_SS_parameters_codeset_4::RemoveCurrFromList()
{
    AsnListElmt *del_elmt;

    if (curr != NULL)
    {
        del_elmt = curr;
        count--;

        if (count == 0)
            first = last = curr = NULL;
        else if (curr == first)
        {
            curr = first= first->next;
            first->prev = NULL;
        }
        else if (curr == last)
        {
            curr = last = last->prev;
            last->next = NULL;
        }
        else
        {
            curr->prev->next = curr->next;
            curr->next->prev = curr->prev;
        }

        delete del_elmt->elmt;
        delete del_elmt;
    }
}


AsnLen DSS1_SS_parameters_codeset_4::BEncContent (BUF_TYPE b)
{
    AsnListElmt *currElmt;
    AsnLen elmtLen;
    AsnLen totalLen = 0;
    for (currElmt = last; currElmt != NULL; currElmt = currElmt->prev)
    {
        elmtLen = currElmt->elmt->BEncContent (b);
    elmtLen += BEncDefLen (b, elmtLen);

    elmtLen += BEncTag1 (b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
        totalLen += elmtLen;
    }
    return totalLen;
} // DSS1_SS_parameters_codeset_4::BEncContent


void  DSS1_SS_parameters_codeset_4::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0,
                                  AsnLen &bytesDecoded, ENV_TYPE env)
{
    AsnOcts *listElmt;
    AsnTag tag1;
    AsnLen listBytesDecoded = 0;
    AsnLen elmtLen1;

    while ((listBytesDecoded < elmtLen0) || (elmtLen0 == INDEFINITE_LEN))
    {
        tag1 = BDecTag (b, listBytesDecoded, env);
        if ((tag1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
        {
            BDEC_2ND_EOC_OCTET (b, listBytesDecoded, env);
            break;
        }
        if ((tag1 != MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
         && (tag1 != MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
        {
            Asn1Error << "Unexpected Tag" << std::endl;
            longjmp (env, -120);
        }

        elmtLen1 = BDecLen (b, listBytesDecoded, env);
        listElmt = Append();
        listElmt->BDecContent (b, tag1, elmtLen1, listBytesDecoded, env);
    }

    bytesDecoded += listBytesDecoded;
} // DSS1_SS_parameters_codeset_4::BDecContent


AsnType *DSS1_SS_parameters_codeset_5::Clone() const
{
  return new DSS1_SS_parameters_codeset_5;
}

AsnLen DSS1_SS_parameters_codeset_5::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SET_TAG_CODE);
  return l;
}

void DSS1_SS_parameters_codeset_5::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SET_TAG_CODE))
  {
    Asn1Error << "DSS1_SS_parameters_codeset_5::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -121);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

DSS1_SS_parameters_codeset_5::DSS1_SS_parameters_codeset_5 (const DSS1_SS_parameters_codeset_5 &)
{
  Asn1Error << "use of incompletely defined DSS1_SS_parameters_codeset_5::DSS1_SS_parameters_codeset_5 (const DSS1_SS_parameters_codeset_5 &)" << std::endl;
  abort();
}

DSS1_SS_parameters_codeset_5::~DSS1_SS_parameters_codeset_5()
{
  SetCurrToFirst();
  for (; Curr() != NULL; RemoveCurrFromList())
    ;
} // end of destructor

#if SNACC_DEEP_COPY
DSS1_SS_parameters_codeset_5 &DSS1_SS_parameters_codeset_5::operator = (const DSS1_SS_parameters_codeset_5 &that)
#else // SNACC_DEEP_COPY
DSS1_SS_parameters_codeset_5 &DSS1_SS_parameters_codeset_5::operator = (const DSS1_SS_parameters_codeset_5 &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    SetCurrToFirst();
    for (; Curr(); RemoveCurrFromList())
      ;

    //that.SetCurrToFirst();
    //for (; that.Curr(); that.GoNext())
    //  AppendCopy (*that.Curr());
    for (const AsnListElmt *run=that.first; run; run=run->next)
      AppendCopy (*run->elmt);
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined DSS1_SS_parameters_codeset_5 &DSS1_SS_parameters_codeset_5::operator = (const DSS1_SS_parameters_codeset_5 &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

void DSS1_SS_parameters_codeset_5::Print (std::ostream &os) const
{
    os << "{ -- SEQUENCE/SET OF -- " << std::endl;
    indentG += stdIndentG;
    //SetCurrToFirst();
    //for (; Curr() != NULL; GoNext())
    for (const AsnListElmt *run=first; run; run=run->next)
    {
        Indent (os, indentG);
        //os << *Curr();
        os << *run->elmt;
        //if (Curr() != Last())
        if (run != last)
            os << ",";
        os << std::endl;
    }
    indentG -= stdIndentG;
    Indent (os, indentG);
    os << "}\n";
} // Print


void  DSS1_SS_parameters_codeset_5::SetCurrElmt (unsigned long int index)
{
  unsigned long int i;
  curr = first;
  if (count)
    for (i = 0; (i < (count-1)) && (i < index); i++)
      curr = curr->next;
} // DSS1_SS_parameters_codeset_5::SetCurrElmt


unsigned long int  DSS1_SS_parameters_codeset_5::GetCurrElmtIndex()
{
    unsigned long int i;
    AsnListElmt *tmp;
    if (curr != NULL)
    {
        for (i = 0, tmp = first; tmp != NULL; i++)
        {
            if (tmp == curr)
                return i;
            else
                tmp = tmp->next;
        }
    }
    return count;
} // DSS1_SS_parameters_codeset_5::GetCurrElmtIndex


// alloc new list elmt, put at end of list
//  and return the component type
AsnOcts *DSS1_SS_parameters_codeset_5::Append()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt  = new AsnOcts;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // DSS1_SS_parameters_codeset_5::Append


// alloc new list elmt, put at begining of list
//  and return the component type
AsnOcts  *DSS1_SS_parameters_codeset_5::Prepend()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // DSS1_SS_parameters_codeset_5::Prepend


// alloc new list elmt, insert it before the
// current element and return the component type
// if the current element is null, the new element
// is placed at the beginning of the list.
AsnOcts  *DSS1_SS_parameters_codeset_5::InsertBefore()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // DSS1_SS_parameters_codeset_5::InsertBefore


// alloc new list elmt, insert it after the
// current element and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
AsnOcts *DSS1_SS_parameters_codeset_5::InsertAfter()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // DSS1_SS_parameters_codeset_5::InsertAfter


DSS1_SS_parameters_codeset_5  &DSS1_SS_parameters_codeset_5::AppendCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return *this;
} // AppendCopy


DSS1_SS_parameters_codeset_5  &DSS1_SS_parameters_codeset_5::PrependCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return *this;
} // DSS1_SS_parameters_codeset_5::PrependCopy


// alloc new list elmt, insert it before the
// current element, copy the given elmt into the new elmt
// and return the component type.
// if the current element is null, the new element
// is placed at the beginning of the list.
DSS1_SS_parameters_codeset_5 &DSS1_SS_parameters_codeset_5::InsertBeforeAndCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;

    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return *this;
} // DSS1_SS_parameters_codeset_5::InsertBeforeAndCopy


// alloc new list elmt, insert it after the
// current element, copy given elmt in to new elmt
//  and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
DSS1_SS_parameters_codeset_5  &DSS1_SS_parameters_codeset_5::InsertAfterAndCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return *this;
} // DSS1_SS_parameters_codeset_5::InsertAfterAndCopy


// remove current element from list if current element is not NULL
// The new current element will be the next element.
// If the current element is the last element in the list
// the second but last element will become the new current element.
void DSS1_SS_parameters_codeset_5::RemoveCurrFromList()
{
    AsnListElmt *del_elmt;

    if (curr != NULL)
    {
        del_elmt = curr;
        count--;

        if (count == 0)
            first = last = curr = NULL;
        else if (curr == first)
        {
            curr = first= first->next;
            first->prev = NULL;
        }
        else if (curr == last)
        {
            curr = last = last->prev;
            last->next = NULL;
        }
        else
        {
            curr->prev->next = curr->next;
            curr->next->prev = curr->prev;
        }

        delete del_elmt->elmt;
        delete del_elmt;
    }
}


AsnLen DSS1_SS_parameters_codeset_5::BEncContent (BUF_TYPE b)
{
    AsnListElmt *currElmt;
    AsnLen elmtLen;
    AsnLen totalLen = 0;
    for (currElmt = last; currElmt != NULL; currElmt = currElmt->prev)
    {
        elmtLen = currElmt->elmt->BEncContent (b);
    elmtLen += BEncDefLen (b, elmtLen);

    elmtLen += BEncTag1 (b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
        totalLen += elmtLen;
    }
    return totalLen;
} // DSS1_SS_parameters_codeset_5::BEncContent


void  DSS1_SS_parameters_codeset_5::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0,
                                  AsnLen &bytesDecoded, ENV_TYPE env)
{
    AsnOcts *listElmt;
    AsnTag tag1;
    AsnLen listBytesDecoded = 0;
    AsnLen elmtLen1;

    while ((listBytesDecoded < elmtLen0) || (elmtLen0 == INDEFINITE_LEN))
    {
        tag1 = BDecTag (b, listBytesDecoded, env);
        if ((tag1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
        {
            BDEC_2ND_EOC_OCTET (b, listBytesDecoded, env);
            break;
        }
        if ((tag1 != MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
         && (tag1 != MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
        {
            Asn1Error << "Unexpected Tag" << std::endl;
            longjmp (env, -122);
        }

        elmtLen1 = BDecLen (b, listBytesDecoded, env);
        listElmt = Append();
        listElmt->BDecContent (b, tag1, elmtLen1, listBytesDecoded, env);
    }

    bytesDecoded += listBytesDecoded;
} // DSS1_SS_parameters_codeset_5::BDecContent


AsnType *DSS1_SS_parameters_codeset_6::Clone() const
{
  return new DSS1_SS_parameters_codeset_6;
}

AsnLen DSS1_SS_parameters_codeset_6::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SET_TAG_CODE);
  return l;
}

void DSS1_SS_parameters_codeset_6::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SET_TAG_CODE))
  {
    Asn1Error << "DSS1_SS_parameters_codeset_6::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -123);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

DSS1_SS_parameters_codeset_6::DSS1_SS_parameters_codeset_6 (const DSS1_SS_parameters_codeset_6 &)
{
  Asn1Error << "use of incompletely defined DSS1_SS_parameters_codeset_6::DSS1_SS_parameters_codeset_6 (const DSS1_SS_parameters_codeset_6 &)" << std::endl;
  abort();
}

DSS1_SS_parameters_codeset_6::~DSS1_SS_parameters_codeset_6()
{
  SetCurrToFirst();
  for (; Curr() != NULL; RemoveCurrFromList())
    ;
} // end of destructor

#if SNACC_DEEP_COPY
DSS1_SS_parameters_codeset_6 &DSS1_SS_parameters_codeset_6::operator = (const DSS1_SS_parameters_codeset_6 &that)
#else // SNACC_DEEP_COPY
DSS1_SS_parameters_codeset_6 &DSS1_SS_parameters_codeset_6::operator = (const DSS1_SS_parameters_codeset_6 &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    SetCurrToFirst();
    for (; Curr(); RemoveCurrFromList())
      ;

    //that.SetCurrToFirst();
    //for (; that.Curr(); that.GoNext())
    //  AppendCopy (*that.Curr());
    for (const AsnListElmt *run=that.first; run; run=run->next)
      AppendCopy (*run->elmt);
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined DSS1_SS_parameters_codeset_6 &DSS1_SS_parameters_codeset_6::operator = (const DSS1_SS_parameters_codeset_6 &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

void DSS1_SS_parameters_codeset_6::Print (std::ostream &os) const
{
    os << "{ -- SEQUENCE/SET OF -- " << std::endl;
    indentG += stdIndentG;
    //SetCurrToFirst();
    //for (; Curr() != NULL; GoNext())
    for (const AsnListElmt *run=first; run; run=run->next)
    {
        Indent (os, indentG);
        //os << *Curr();
        os << *run->elmt;
        //if (Curr() != Last())
        if (run != last)
            os << ",";
        os << std::endl;
    }
    indentG -= stdIndentG;
    Indent (os, indentG);
    os << "}\n";
} // Print


void  DSS1_SS_parameters_codeset_6::SetCurrElmt (unsigned long int index)
{
  unsigned long int i;
  curr = first;
  if (count)
    for (i = 0; (i < (count-1)) && (i < index); i++)
      curr = curr->next;
} // DSS1_SS_parameters_codeset_6::SetCurrElmt


unsigned long int  DSS1_SS_parameters_codeset_6::GetCurrElmtIndex()
{
    unsigned long int i;
    AsnListElmt *tmp;
    if (curr != NULL)
    {
        for (i = 0, tmp = first; tmp != NULL; i++)
        {
            if (tmp == curr)
                return i;
            else
                tmp = tmp->next;
        }
    }
    return count;
} // DSS1_SS_parameters_codeset_6::GetCurrElmtIndex


// alloc new list elmt, put at end of list
//  and return the component type
AsnOcts *DSS1_SS_parameters_codeset_6::Append()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt  = new AsnOcts;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // DSS1_SS_parameters_codeset_6::Append


// alloc new list elmt, put at begining of list
//  and return the component type
AsnOcts  *DSS1_SS_parameters_codeset_6::Prepend()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // DSS1_SS_parameters_codeset_6::Prepend


// alloc new list elmt, insert it before the
// current element and return the component type
// if the current element is null, the new element
// is placed at the beginning of the list.
AsnOcts  *DSS1_SS_parameters_codeset_6::InsertBefore()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // DSS1_SS_parameters_codeset_6::InsertBefore


// alloc new list elmt, insert it after the
// current element and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
AsnOcts *DSS1_SS_parameters_codeset_6::InsertAfter()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // DSS1_SS_parameters_codeset_6::InsertAfter


DSS1_SS_parameters_codeset_6  &DSS1_SS_parameters_codeset_6::AppendCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return *this;
} // AppendCopy


DSS1_SS_parameters_codeset_6  &DSS1_SS_parameters_codeset_6::PrependCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return *this;
} // DSS1_SS_parameters_codeset_6::PrependCopy


// alloc new list elmt, insert it before the
// current element, copy the given elmt into the new elmt
// and return the component type.
// if the current element is null, the new element
// is placed at the beginning of the list.
DSS1_SS_parameters_codeset_6 &DSS1_SS_parameters_codeset_6::InsertBeforeAndCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;

    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return *this;
} // DSS1_SS_parameters_codeset_6::InsertBeforeAndCopy


// alloc new list elmt, insert it after the
// current element, copy given elmt in to new elmt
//  and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
DSS1_SS_parameters_codeset_6  &DSS1_SS_parameters_codeset_6::InsertAfterAndCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return *this;
} // DSS1_SS_parameters_codeset_6::InsertAfterAndCopy


// remove current element from list if current element is not NULL
// The new current element will be the next element.
// If the current element is the last element in the list
// the second but last element will become the new current element.
void DSS1_SS_parameters_codeset_6::RemoveCurrFromList()
{
    AsnListElmt *del_elmt;

    if (curr != NULL)
    {
        del_elmt = curr;
        count--;

        if (count == 0)
            first = last = curr = NULL;
        else if (curr == first)
        {
            curr = first= first->next;
            first->prev = NULL;
        }
        else if (curr == last)
        {
            curr = last = last->prev;
            last->next = NULL;
        }
        else
        {
            curr->prev->next = curr->next;
            curr->next->prev = curr->prev;
        }

        delete del_elmt->elmt;
        delete del_elmt;
    }
}


AsnLen DSS1_SS_parameters_codeset_6::BEncContent (BUF_TYPE b)
{
    AsnListElmt *currElmt;
    AsnLen elmtLen;
    AsnLen totalLen = 0;
    for (currElmt = last; currElmt != NULL; currElmt = currElmt->prev)
    {
        elmtLen = currElmt->elmt->BEncContent (b);
    elmtLen += BEncDefLen (b, elmtLen);

    elmtLen += BEncTag1 (b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
        totalLen += elmtLen;
    }
    return totalLen;
} // DSS1_SS_parameters_codeset_6::BEncContent


void  DSS1_SS_parameters_codeset_6::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0,
                                  AsnLen &bytesDecoded, ENV_TYPE env)
{
    AsnOcts *listElmt;
    AsnTag tag1;
    AsnLen listBytesDecoded = 0;
    AsnLen elmtLen1;

    while ((listBytesDecoded < elmtLen0) || (elmtLen0 == INDEFINITE_LEN))
    {
        tag1 = BDecTag (b, listBytesDecoded, env);
        if ((tag1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
        {
            BDEC_2ND_EOC_OCTET (b, listBytesDecoded, env);
            break;
        }
        if ((tag1 != MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
         && (tag1 != MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
        {
            Asn1Error << "Unexpected Tag" << std::endl;
            longjmp (env, -124);
        }

        elmtLen1 = BDecLen (b, listBytesDecoded, env);
        listElmt = Append();
        listElmt->BDecContent (b, tag1, elmtLen1, listBytesDecoded, env);
    }

    bytesDecoded += listBytesDecoded;
} // DSS1_SS_parameters_codeset_6::BDecContent


AsnType *DSS1_SS_parameters_codeset_7::Clone() const
{
  return new DSS1_SS_parameters_codeset_7;
}

AsnLen DSS1_SS_parameters_codeset_7::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SET_TAG_CODE);
  return l;
}

void DSS1_SS_parameters_codeset_7::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SET_TAG_CODE))
  {
    Asn1Error << "DSS1_SS_parameters_codeset_7::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -125);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

DSS1_SS_parameters_codeset_7::DSS1_SS_parameters_codeset_7 (const DSS1_SS_parameters_codeset_7 &)
{
  Asn1Error << "use of incompletely defined DSS1_SS_parameters_codeset_7::DSS1_SS_parameters_codeset_7 (const DSS1_SS_parameters_codeset_7 &)" << std::endl;
  abort();
}

DSS1_SS_parameters_codeset_7::~DSS1_SS_parameters_codeset_7()
{
  SetCurrToFirst();
  for (; Curr() != NULL; RemoveCurrFromList())
    ;
} // end of destructor

#if SNACC_DEEP_COPY
DSS1_SS_parameters_codeset_7 &DSS1_SS_parameters_codeset_7::operator = (const DSS1_SS_parameters_codeset_7 &that)
#else // SNACC_DEEP_COPY
DSS1_SS_parameters_codeset_7 &DSS1_SS_parameters_codeset_7::operator = (const DSS1_SS_parameters_codeset_7 &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    SetCurrToFirst();
    for (; Curr(); RemoveCurrFromList())
      ;

    //that.SetCurrToFirst();
    //for (; that.Curr(); that.GoNext())
    //  AppendCopy (*that.Curr());
    for (const AsnListElmt *run=that.first; run; run=run->next)
      AppendCopy (*run->elmt);
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined DSS1_SS_parameters_codeset_7 &DSS1_SS_parameters_codeset_7::operator = (const DSS1_SS_parameters_codeset_7 &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

void DSS1_SS_parameters_codeset_7::Print (std::ostream &os) const
{
    os << "{ -- SEQUENCE/SET OF -- " << std::endl;
    indentG += stdIndentG;
    //SetCurrToFirst();
    //for (; Curr() != NULL; GoNext())
    for (const AsnListElmt *run=first; run; run=run->next)
    {
        Indent (os, indentG);
        //os << *Curr();
        os << *run->elmt;
        //if (Curr() != Last())
        if (run != last)
            os << ",";
        os << std::endl;
    }
    indentG -= stdIndentG;
    Indent (os, indentG);
    os << "}\n";
} // Print


void  DSS1_SS_parameters_codeset_7::SetCurrElmt (unsigned long int index)
{
  unsigned long int i;
  curr = first;
  if (count)
    for (i = 0; (i < (count-1)) && (i < index); i++)
      curr = curr->next;
} // DSS1_SS_parameters_codeset_7::SetCurrElmt


unsigned long int  DSS1_SS_parameters_codeset_7::GetCurrElmtIndex()
{
    unsigned long int i;
    AsnListElmt *tmp;
    if (curr != NULL)
    {
        for (i = 0, tmp = first; tmp != NULL; i++)
        {
            if (tmp == curr)
                return i;
            else
                tmp = tmp->next;
        }
    }
    return count;
} // DSS1_SS_parameters_codeset_7::GetCurrElmtIndex


// alloc new list elmt, put at end of list
//  and return the component type
AsnOcts *DSS1_SS_parameters_codeset_7::Append()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt  = new AsnOcts;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // DSS1_SS_parameters_codeset_7::Append


// alloc new list elmt, put at begining of list
//  and return the component type
AsnOcts  *DSS1_SS_parameters_codeset_7::Prepend()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // DSS1_SS_parameters_codeset_7::Prepend


// alloc new list elmt, insert it before the
// current element and return the component type
// if the current element is null, the new element
// is placed at the beginning of the list.
AsnOcts  *DSS1_SS_parameters_codeset_7::InsertBefore()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // DSS1_SS_parameters_codeset_7::InsertBefore


// alloc new list elmt, insert it after the
// current element and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
AsnOcts *DSS1_SS_parameters_codeset_7::InsertAfter()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // DSS1_SS_parameters_codeset_7::InsertAfter


DSS1_SS_parameters_codeset_7  &DSS1_SS_parameters_codeset_7::AppendCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return *this;
} // AppendCopy


DSS1_SS_parameters_codeset_7  &DSS1_SS_parameters_codeset_7::PrependCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return *this;
} // DSS1_SS_parameters_codeset_7::PrependCopy


// alloc new list elmt, insert it before the
// current element, copy the given elmt into the new elmt
// and return the component type.
// if the current element is null, the new element
// is placed at the beginning of the list.
DSS1_SS_parameters_codeset_7 &DSS1_SS_parameters_codeset_7::InsertBeforeAndCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;

    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return *this;
} // DSS1_SS_parameters_codeset_7::InsertBeforeAndCopy


// alloc new list elmt, insert it after the
// current element, copy given elmt in to new elmt
//  and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
DSS1_SS_parameters_codeset_7  &DSS1_SS_parameters_codeset_7::InsertAfterAndCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return *this;
} // DSS1_SS_parameters_codeset_7::InsertAfterAndCopy


// remove current element from list if current element is not NULL
// The new current element will be the next element.
// If the current element is the last element in the list
// the second but last element will become the new current element.
void DSS1_SS_parameters_codeset_7::RemoveCurrFromList()
{
    AsnListElmt *del_elmt;

    if (curr != NULL)
    {
        del_elmt = curr;
        count--;

        if (count == 0)
            first = last = curr = NULL;
        else if (curr == first)
        {
            curr = first= first->next;
            first->prev = NULL;
        }
        else if (curr == last)
        {
            curr = last = last->prev;
            last->next = NULL;
        }
        else
        {
            curr->prev->next = curr->next;
            curr->next->prev = curr->prev;
        }

        delete del_elmt->elmt;
        delete del_elmt;
    }
}


AsnLen DSS1_SS_parameters_codeset_7::BEncContent (BUF_TYPE b)
{
    AsnListElmt *currElmt;
    AsnLen elmtLen;
    AsnLen totalLen = 0;
    for (currElmt = last; currElmt != NULL; currElmt = currElmt->prev)
    {
        elmtLen = currElmt->elmt->BEncContent (b);
    elmtLen += BEncDefLen (b, elmtLen);

    elmtLen += BEncTag1 (b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
        totalLen += elmtLen;
    }
    return totalLen;
} // DSS1_SS_parameters_codeset_7::BEncContent


void  DSS1_SS_parameters_codeset_7::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0,
                                  AsnLen &bytesDecoded, ENV_TYPE env)
{
    AsnOcts *listElmt;
    AsnTag tag1;
    AsnLen listBytesDecoded = 0;
    AsnLen elmtLen1;

    while ((listBytesDecoded < elmtLen0) || (elmtLen0 == INDEFINITE_LEN))
    {
        tag1 = BDecTag (b, listBytesDecoded, env);
        if ((tag1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
        {
            BDEC_2ND_EOC_OCTET (b, listBytesDecoded, env);
            break;
        }
        if ((tag1 != MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
         && (tag1 != MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
        {
            Asn1Error << "Unexpected Tag" << std::endl;
            longjmp (env, -126);
        }

        elmtLen1 = BDecLen (b, listBytesDecoded, env);
        listElmt = Append();
        listElmt->BDecContent (b, tag1, elmtLen1, listBytesDecoded, env);
    }

    bytesDecoded += listBytesDecoded;
} // DSS1_SS_parameters_codeset_7::BDecContent


AsnType *DSS1_SS_Invoke_Components::Clone() const
{
  return new DSS1_SS_Invoke_Components;
}

AsnLen DSS1_SS_Invoke_Components::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SET_TAG_CODE);
  return l;
}

void DSS1_SS_Invoke_Components::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SET_TAG_CODE))
  {
    Asn1Error << "DSS1_SS_Invoke_Components::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -127);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

DSS1_SS_Invoke_Components::DSS1_SS_Invoke_Components (const DSS1_SS_Invoke_Components &)
{
  Asn1Error << "use of incompletely defined DSS1_SS_Invoke_Components::DSS1_SS_Invoke_Components (const DSS1_SS_Invoke_Components &)" << std::endl;
  abort();
}

DSS1_SS_Invoke_Components::~DSS1_SS_Invoke_Components()
{
  SetCurrToFirst();
  for (; Curr() != NULL; RemoveCurrFromList())
    ;
} // end of destructor

#if SNACC_DEEP_COPY
DSS1_SS_Invoke_Components &DSS1_SS_Invoke_Components::operator = (const DSS1_SS_Invoke_Components &that)
#else // SNACC_DEEP_COPY
DSS1_SS_Invoke_Components &DSS1_SS_Invoke_Components::operator = (const DSS1_SS_Invoke_Components &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    SetCurrToFirst();
    for (; Curr(); RemoveCurrFromList())
      ;

    //that.SetCurrToFirst();
    //for (; that.Curr(); that.GoNext())
    //  AppendCopy (*that.Curr());
    for (const AsnListElmt *run=that.first; run; run=run->next)
      AppendCopy (*run->elmt);
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined DSS1_SS_Invoke_Components &DSS1_SS_Invoke_Components::operator = (const DSS1_SS_Invoke_Components &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

void DSS1_SS_Invoke_Components::Print (std::ostream &os) const
{
    os << "{ -- SEQUENCE/SET OF -- " << std::endl;
    indentG += stdIndentG;
    //SetCurrToFirst();
    //for (; Curr() != NULL; GoNext())
    for (const AsnListElmt *run=first; run; run=run->next)
    {
        Indent (os, indentG);
        //os << *Curr();
        os << *run->elmt;
        //if (Curr() != Last())
        if (run != last)
            os << ",";
        os << std::endl;
    }
    indentG -= stdIndentG;
    Indent (os, indentG);
    os << "}\n";
} // Print


void  DSS1_SS_Invoke_Components::SetCurrElmt (unsigned long int index)
{
  unsigned long int i;
  curr = first;
  if (count)
    for (i = 0; (i < (count-1)) && (i < index); i++)
      curr = curr->next;
} // DSS1_SS_Invoke_Components::SetCurrElmt


unsigned long int  DSS1_SS_Invoke_Components::GetCurrElmtIndex()
{
    unsigned long int i;
    AsnListElmt *tmp;
    if (curr != NULL)
    {
        for (i = 0, tmp = first; tmp != NULL; i++)
        {
            if (tmp == curr)
                return i;
            else
                tmp = tmp->next;
        }
    }
    return count;
} // DSS1_SS_Invoke_Components::GetCurrElmtIndex


// alloc new list elmt, put at end of list
//  and return the component type
AsnOcts *DSS1_SS_Invoke_Components::Append()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt  = new AsnOcts;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // DSS1_SS_Invoke_Components::Append


// alloc new list elmt, put at begining of list
//  and return the component type
AsnOcts  *DSS1_SS_Invoke_Components::Prepend()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // DSS1_SS_Invoke_Components::Prepend


// alloc new list elmt, insert it before the
// current element and return the component type
// if the current element is null, the new element
// is placed at the beginning of the list.
AsnOcts  *DSS1_SS_Invoke_Components::InsertBefore()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // DSS1_SS_Invoke_Components::InsertBefore


// alloc new list elmt, insert it after the
// current element and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
AsnOcts *DSS1_SS_Invoke_Components::InsertAfter()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // DSS1_SS_Invoke_Components::InsertAfter


DSS1_SS_Invoke_Components  &DSS1_SS_Invoke_Components::AppendCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return *this;
} // AppendCopy


DSS1_SS_Invoke_Components  &DSS1_SS_Invoke_Components::PrependCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return *this;
} // DSS1_SS_Invoke_Components::PrependCopy


// alloc new list elmt, insert it before the
// current element, copy the given elmt into the new elmt
// and return the component type.
// if the current element is null, the new element
// is placed at the beginning of the list.
DSS1_SS_Invoke_Components &DSS1_SS_Invoke_Components::InsertBeforeAndCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;

    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return *this;
} // DSS1_SS_Invoke_Components::InsertBeforeAndCopy


// alloc new list elmt, insert it after the
// current element, copy given elmt in to new elmt
//  and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
DSS1_SS_Invoke_Components  &DSS1_SS_Invoke_Components::InsertAfterAndCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return *this;
} // DSS1_SS_Invoke_Components::InsertAfterAndCopy


// remove current element from list if current element is not NULL
// The new current element will be the next element.
// If the current element is the last element in the list
// the second but last element will become the new current element.
void DSS1_SS_Invoke_Components::RemoveCurrFromList()
{
    AsnListElmt *del_elmt;

    if (curr != NULL)
    {
        del_elmt = curr;
        count--;

        if (count == 0)
            first = last = curr = NULL;
        else if (curr == first)
        {
            curr = first= first->next;
            first->prev = NULL;
        }
        else if (curr == last)
        {
            curr = last = last->prev;
            last->next = NULL;
        }
        else
        {
            curr->prev->next = curr->next;
            curr->next->prev = curr->prev;
        }

        delete del_elmt->elmt;
        delete del_elmt;
    }
}


AsnLen DSS1_SS_Invoke_Components::BEncContent (BUF_TYPE b)
{
    AsnListElmt *currElmt;
    AsnLen elmtLen;
    AsnLen totalLen = 0;
    for (currElmt = last; currElmt != NULL; currElmt = currElmt->prev)
    {
        elmtLen = currElmt->elmt->BEncContent (b);
    elmtLen += BEncDefLen (b, elmtLen);

    elmtLen += BEncTag1 (b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
        totalLen += elmtLen;
    }
    return totalLen;
} // DSS1_SS_Invoke_Components::BEncContent


void  DSS1_SS_Invoke_Components::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0,
                                  AsnLen &bytesDecoded, ENV_TYPE env)
{
    AsnOcts *listElmt;
    AsnTag tag1;
    AsnLen listBytesDecoded = 0;
    AsnLen elmtLen1;

    while ((listBytesDecoded < elmtLen0) || (elmtLen0 == INDEFINITE_LEN))
    {
        tag1 = BDecTag (b, listBytesDecoded, env);
        if ((tag1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
        {
            BDEC_2ND_EOC_OCTET (b, listBytesDecoded, env);
            break;
        }
        if ((tag1 != MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
         && (tag1 != MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
        {
            Asn1Error << "Unexpected Tag" << std::endl;
            longjmp (env, -128);
        }

        elmtLen1 = BDecLen (b, listBytesDecoded, env);
        listElmt = Append();
        listElmt->BDecContent (b, tag1, elmtLen1, listBytesDecoded, env);
    }

    bytesDecoded += listBytesDecoded;
} // DSS1_SS_Invoke_Components::BDecContent


AsnType *MAP_SS_Invoke_Components::Clone() const
{
  return new MAP_SS_Invoke_Components;
}

AsnLen MAP_SS_Invoke_Components::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SET_TAG_CODE);
  return l;
}

void MAP_SS_Invoke_Components::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SET_TAG_CODE))
  {
    Asn1Error << "MAP_SS_Invoke_Components::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -129);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

MAP_SS_Invoke_Components::MAP_SS_Invoke_Components (const MAP_SS_Invoke_Components &)
{
  Asn1Error << "use of incompletely defined MAP_SS_Invoke_Components::MAP_SS_Invoke_Components (const MAP_SS_Invoke_Components &)" << std::endl;
  abort();
}

MAP_SS_Invoke_Components::~MAP_SS_Invoke_Components()
{
  SetCurrToFirst();
  for (; Curr() != NULL; RemoveCurrFromList())
    ;
} // end of destructor

#if SNACC_DEEP_COPY
MAP_SS_Invoke_Components &MAP_SS_Invoke_Components::operator = (const MAP_SS_Invoke_Components &that)
#else // SNACC_DEEP_COPY
MAP_SS_Invoke_Components &MAP_SS_Invoke_Components::operator = (const MAP_SS_Invoke_Components &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    SetCurrToFirst();
    for (; Curr(); RemoveCurrFromList())
      ;

    //that.SetCurrToFirst();
    //for (; that.Curr(); that.GoNext())
    //  AppendCopy (*that.Curr());
    for (const AsnListElmt *run=that.first; run; run=run->next)
      AppendCopy (*run->elmt);
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined MAP_SS_Invoke_Components &MAP_SS_Invoke_Components::operator = (const MAP_SS_Invoke_Components &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

void MAP_SS_Invoke_Components::Print (std::ostream &os) const
{
    os << "{ -- SEQUENCE/SET OF -- " << std::endl;
    indentG += stdIndentG;
    //SetCurrToFirst();
    //for (; Curr() != NULL; GoNext())
    for (const AsnListElmt *run=first; run; run=run->next)
    {
        Indent (os, indentG);
        //os << *Curr();
        os << *run->elmt;
        //if (Curr() != Last())
        if (run != last)
            os << ",";
        os << std::endl;
    }
    indentG -= stdIndentG;
    Indent (os, indentG);
    os << "}\n";
} // Print


void  MAP_SS_Invoke_Components::SetCurrElmt (unsigned long int index)
{
  unsigned long int i;
  curr = first;
  if (count)
    for (i = 0; (i < (count-1)) && (i < index); i++)
      curr = curr->next;
} // MAP_SS_Invoke_Components::SetCurrElmt


unsigned long int  MAP_SS_Invoke_Components::GetCurrElmtIndex()
{
    unsigned long int i;
    AsnListElmt *tmp;
    if (curr != NULL)
    {
        for (i = 0, tmp = first; tmp != NULL; i++)
        {
            if (tmp == curr)
                return i;
            else
                tmp = tmp->next;
        }
    }
    return count;
} // MAP_SS_Invoke_Components::GetCurrElmtIndex


// alloc new list elmt, put at end of list
//  and return the component type
AsnOcts *MAP_SS_Invoke_Components::Append()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt  = new AsnOcts;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // MAP_SS_Invoke_Components::Append


// alloc new list elmt, put at begining of list
//  and return the component type
AsnOcts  *MAP_SS_Invoke_Components::Prepend()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // MAP_SS_Invoke_Components::Prepend


// alloc new list elmt, insert it before the
// current element and return the component type
// if the current element is null, the new element
// is placed at the beginning of the list.
AsnOcts  *MAP_SS_Invoke_Components::InsertBefore()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // MAP_SS_Invoke_Components::InsertBefore


// alloc new list elmt, insert it after the
// current element and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
AsnOcts *MAP_SS_Invoke_Components::InsertAfter()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // MAP_SS_Invoke_Components::InsertAfter


MAP_SS_Invoke_Components  &MAP_SS_Invoke_Components::AppendCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return *this;
} // AppendCopy


MAP_SS_Invoke_Components  &MAP_SS_Invoke_Components::PrependCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return *this;
} // MAP_SS_Invoke_Components::PrependCopy


// alloc new list elmt, insert it before the
// current element, copy the given elmt into the new elmt
// and return the component type.
// if the current element is null, the new element
// is placed at the beginning of the list.
MAP_SS_Invoke_Components &MAP_SS_Invoke_Components::InsertBeforeAndCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;

    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return *this;
} // MAP_SS_Invoke_Components::InsertBeforeAndCopy


// alloc new list elmt, insert it after the
// current element, copy given elmt in to new elmt
//  and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
MAP_SS_Invoke_Components  &MAP_SS_Invoke_Components::InsertAfterAndCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return *this;
} // MAP_SS_Invoke_Components::InsertAfterAndCopy


// remove current element from list if current element is not NULL
// The new current element will be the next element.
// If the current element is the last element in the list
// the second but last element will become the new current element.
void MAP_SS_Invoke_Components::RemoveCurrFromList()
{
    AsnListElmt *del_elmt;

    if (curr != NULL)
    {
        del_elmt = curr;
        count--;

        if (count == 0)
            first = last = curr = NULL;
        else if (curr == first)
        {
            curr = first= first->next;
            first->prev = NULL;
        }
        else if (curr == last)
        {
            curr = last = last->prev;
            last->next = NULL;
        }
        else
        {
            curr->prev->next = curr->next;
            curr->next->prev = curr->prev;
        }

        delete del_elmt->elmt;
        delete del_elmt;
    }
}


AsnLen MAP_SS_Invoke_Components::BEncContent (BUF_TYPE b)
{
    AsnListElmt *currElmt;
    AsnLen elmtLen;
    AsnLen totalLen = 0;
    for (currElmt = last; currElmt != NULL; currElmt = currElmt->prev)
    {
        elmtLen = currElmt->elmt->BEncContent (b);
    elmtLen += BEncDefLen (b, elmtLen);

    elmtLen += BEncTag1 (b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
        totalLen += elmtLen;
    }
    return totalLen;
} // MAP_SS_Invoke_Components::BEncContent


void  MAP_SS_Invoke_Components::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0,
                                  AsnLen &bytesDecoded, ENV_TYPE env)
{
    AsnOcts *listElmt;
    AsnTag tag1;
    AsnLen listBytesDecoded = 0;
    AsnLen elmtLen1;

    while ((listBytesDecoded < elmtLen0) || (elmtLen0 == INDEFINITE_LEN))
    {
        tag1 = BDecTag (b, listBytesDecoded, env);
        if ((tag1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
        {
            BDEC_2ND_EOC_OCTET (b, listBytesDecoded, env);
            break;
        }
        if ((tag1 != MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
         && (tag1 != MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
        {
            Asn1Error << "Unexpected Tag" << std::endl;
            longjmp (env, -130);
        }

        elmtLen1 = BDecLen (b, listBytesDecoded, env);
        listElmt = Append();
        listElmt->BDecContent (b, tag1, elmtLen1, listBytesDecoded, env);
    }

    bytesDecoded += listBytesDecoded;
} // MAP_SS_Invoke_Components::BDecContent


AsnType *MAP_SS_Parameters::Clone() const
{
  return new MAP_SS_Parameters;
}

AsnLen MAP_SS_Parameters::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SET_TAG_CODE);
  return l;
}

void MAP_SS_Parameters::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SET_TAG_CODE))
  {
    Asn1Error << "MAP_SS_Parameters::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -131);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

MAP_SS_Parameters::MAP_SS_Parameters (const MAP_SS_Parameters &)
{
  Asn1Error << "use of incompletely defined MAP_SS_Parameters::MAP_SS_Parameters (const MAP_SS_Parameters &)" << std::endl;
  abort();
}

MAP_SS_Parameters::~MAP_SS_Parameters()
{
  SetCurrToFirst();
  for (; Curr() != NULL; RemoveCurrFromList())
    ;
} // end of destructor

#if SNACC_DEEP_COPY
MAP_SS_Parameters &MAP_SS_Parameters::operator = (const MAP_SS_Parameters &that)
#else // SNACC_DEEP_COPY
MAP_SS_Parameters &MAP_SS_Parameters::operator = (const MAP_SS_Parameters &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    SetCurrToFirst();
    for (; Curr(); RemoveCurrFromList())
      ;

    //that.SetCurrToFirst();
    //for (; that.Curr(); that.GoNext())
    //  AppendCopy (*that.Curr());
    for (const AsnListElmt *run=that.first; run; run=run->next)
      AppendCopy (*run->elmt);
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined MAP_SS_Parameters &MAP_SS_Parameters::operator = (const MAP_SS_Parameters &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

void MAP_SS_Parameters::Print (std::ostream &os) const
{
    os << "{ -- SEQUENCE/SET OF -- " << std::endl;
    indentG += stdIndentG;
    //SetCurrToFirst();
    //for (; Curr() != NULL; GoNext())
    for (const AsnListElmt *run=first; run; run=run->next)
    {
        Indent (os, indentG);
        //os << *Curr();
        os << *run->elmt;
        //if (Curr() != Last())
        if (run != last)
            os << ",";
        os << std::endl;
    }
    indentG -= stdIndentG;
    Indent (os, indentG);
    os << "}\n";
} // Print


void  MAP_SS_Parameters::SetCurrElmt (unsigned long int index)
{
  unsigned long int i;
  curr = first;
  if (count)
    for (i = 0; (i < (count-1)) && (i < index); i++)
      curr = curr->next;
} // MAP_SS_Parameters::SetCurrElmt


unsigned long int  MAP_SS_Parameters::GetCurrElmtIndex()
{
    unsigned long int i;
    AsnListElmt *tmp;
    if (curr != NULL)
    {
        for (i = 0, tmp = first; tmp != NULL; i++)
        {
            if (tmp == curr)
                return i;
            else
                tmp = tmp->next;
        }
    }
    return count;
} // MAP_SS_Parameters::GetCurrElmtIndex


// alloc new list elmt, put at end of list
//  and return the component type
AsnOcts *MAP_SS_Parameters::Append()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt  = new AsnOcts;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // MAP_SS_Parameters::Append


// alloc new list elmt, put at begining of list
//  and return the component type
AsnOcts  *MAP_SS_Parameters::Prepend()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // MAP_SS_Parameters::Prepend


// alloc new list elmt, insert it before the
// current element and return the component type
// if the current element is null, the new element
// is placed at the beginning of the list.
AsnOcts  *MAP_SS_Parameters::InsertBefore()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // MAP_SS_Parameters::InsertBefore


// alloc new list elmt, insert it after the
// current element and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
AsnOcts *MAP_SS_Parameters::InsertAfter()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // MAP_SS_Parameters::InsertAfter


MAP_SS_Parameters  &MAP_SS_Parameters::AppendCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return *this;
} // AppendCopy


MAP_SS_Parameters  &MAP_SS_Parameters::PrependCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return *this;
} // MAP_SS_Parameters::PrependCopy


// alloc new list elmt, insert it before the
// current element, copy the given elmt into the new elmt
// and return the component type.
// if the current element is null, the new element
// is placed at the beginning of the list.
MAP_SS_Parameters &MAP_SS_Parameters::InsertBeforeAndCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;

    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return *this;
} // MAP_SS_Parameters::InsertBeforeAndCopy


// alloc new list elmt, insert it after the
// current element, copy given elmt in to new elmt
//  and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
MAP_SS_Parameters  &MAP_SS_Parameters::InsertAfterAndCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return *this;
} // MAP_SS_Parameters::InsertAfterAndCopy


// remove current element from list if current element is not NULL
// The new current element will be the next element.
// If the current element is the last element in the list
// the second but last element will become the new current element.
void MAP_SS_Parameters::RemoveCurrFromList()
{
    AsnListElmt *del_elmt;

    if (curr != NULL)
    {
        del_elmt = curr;
        count--;

        if (count == 0)
            first = last = curr = NULL;
        else if (curr == first)
        {
            curr = first= first->next;
            first->prev = NULL;
        }
        else if (curr == last)
        {
            curr = last = last->prev;
            last->next = NULL;
        }
        else
        {
            curr->prev->next = curr->next;
            curr->next->prev = curr->prev;
        }

        delete del_elmt->elmt;
        delete del_elmt;
    }
}


AsnLen MAP_SS_Parameters::BEncContent (BUF_TYPE b)
{
    AsnListElmt *currElmt;
    AsnLen elmtLen;
    AsnLen totalLen = 0;
    for (currElmt = last; currElmt != NULL; currElmt = currElmt->prev)
    {
        elmtLen = currElmt->elmt->BEncContent (b);
    elmtLen += BEncDefLen (b, elmtLen);

    elmtLen += BEncTag1 (b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
        totalLen += elmtLen;
    }
    return totalLen;
} // MAP_SS_Parameters::BEncContent


void  MAP_SS_Parameters::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0,
                                  AsnLen &bytesDecoded, ENV_TYPE env)
{
    AsnOcts *listElmt;
    AsnTag tag1;
    AsnLen listBytesDecoded = 0;
    AsnLen elmtLen1;

    while ((listBytesDecoded < elmtLen0) || (elmtLen0 == INDEFINITE_LEN))
    {
        tag1 = BDecTag (b, listBytesDecoded, env);
        if ((tag1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
        {
            BDEC_2ND_EOC_OCTET (b, listBytesDecoded, env);
            break;
        }
        if ((tag1 != MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
         && (tag1 != MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
        {
            Asn1Error << "Unexpected Tag" << std::endl;
            longjmp (env, -132);
        }

        elmtLen1 = BDecLen (b, listBytesDecoded, env);
        listElmt = Append();
        listElmt->BDecContent (b, tag1, elmtLen1, listBytesDecoded, env);
    }

    bytesDecoded += listBytesDecoded;
} // MAP_SS_Parameters::BDecContent


IP_value::IP_value()
{
  choiceId = iPBinaryAddressCid;
#if TCL
  iPBinaryAddress = new AsnOcts;
#else
  iPBinaryAddress = NULL; // incomplete initialization of mandatory element!
#endif // TCL
}

IP_value::IP_value (const IP_value &)
{
  Asn1Error << "use of incompletely defined IP_value::IP_value (const IP_value &)" << std::endl;
  abort();
}

//--------------------------------------------------------------------------------------------------------------------
//Begin this is not generated by compiler
IP_value::IP_value( ChoiceIdEnum pchoiceId, const char *str)
{
    choiceId = pchoiceId;
    switch (choiceId)
    {
        case iPBinaryAddressCid:
                iPBinaryAddress = new AsnOcts;
                iPBinaryAddress->Set(str);
        break;
        case iPTextAddressCid:
                iPTextAddress = new IA5String;
                iPTextAddress->Set(str);
        break;
    }

}

//End this is not generated by compiler
//--------------------------------------------------------------------------------------------------------------------

IP_value::~IP_value()
{
  switch (choiceId)
  {
    case iPBinaryAddressCid:
      delete iPBinaryAddress;
      break;
    case iPTextAddressCid:
      delete iPTextAddress;
      break;
  } // end of switch
} // end of destructor

AsnType *IP_value::Clone() const
{
  return new IP_value;
}

#if SNACC_DEEP_COPY
IP_value &IP_value::operator = (const IP_value &that)
#else // SNACC_DEEP_COPY
IP_value &IP_value::operator = (const IP_value &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    switch (choiceId)
    {
      case iPBinaryAddressCid:
        delete iPBinaryAddress;
        break;
      case iPTextAddressCid:
        delete iPTextAddress;
        break;
    }
    switch (choiceId = that.choiceId)
    {
      case iPBinaryAddressCid:
        iPBinaryAddress = new AsnOcts;
        *iPBinaryAddress = *that.iPBinaryAddress;
        break;
      case iPTextAddressCid:
        iPTextAddress = new IA5String;
        *iPTextAddress = *that.iPTextAddress;
        break;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined IP_value &IP_value::operator = (const IP_value &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
IP_value::BEncContent (BUF_TYPE b)
{
  AsnLen l;
  switch (choiceId)
  {
    case iPBinaryAddressCid:
      l = iPBinaryAddress->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 1);
      break;

    case iPTextAddressCid:
      l = iPTextAddress->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 2);
      break;

  } // end switch
  return l;
} // IP_value::BEncContent


void IP_value::BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  switch (tag)
  {
    case MAKE_TAG_ID (CNTX, PRIM, 1):
    case MAKE_TAG_ID (CNTX, CONS, 1):
      choiceId = iPBinaryAddressCid;
      iPBinaryAddress = new AsnOcts;
        iPBinaryAddress->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 2):
    case MAKE_TAG_ID (CNTX, CONS, 2):
      choiceId = iPTextAddressCid;
      iPTextAddress = new IA5String;
        iPTextAddress->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    default:
      Asn1Error << "ERROR - unexpected tag in CHOICE" << std::endl;
      longjmp (env, -133);
      break;
  } // end switch
} // IP_value::BDecContent


AsnLen IP_value::BEnc (BUF_TYPE b)
{
    AsnLen l;
    l = BEncContent (b);
    return l;
}

void IP_value::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
    AsnLen elmtLen;
    AsnTag tag;

    /*  CHOICEs are a special case - grab identifying tag */
    /*  this allows easier handling of nested CHOICEs */
    tag = BDecTag (b, bytesDecoded, env);
    elmtLen = BDecLen (b, bytesDecoded, env);
    BDecContent (b, tag, elmtLen, bytesDecoded, env);
}

int IP_value::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int IP_value::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void IP_value::Print (std::ostream &os) const
{
  switch (choiceId)
  {
    case iPBinaryAddressCid:
      os << "iPBinaryAddress ";
      if (iPBinaryAddress)
        os << *iPBinaryAddress;
      else
        os << "-- void3 --\n";
      break;

    case iPTextAddressCid:
      os << "iPTextAddress ";
      if (iPTextAddress)
        os << *iPTextAddress;
      else
        os << "-- void3 --\n";
      break;

  } // end of switch
} // IP_value::Print

SMS_reportSeq::SMS_reportSeq()
{
  transfer_status = NULL;
  other_message = NULL;
  content = NULL;
}

SMS_reportSeq::SMS_reportSeq (const SMS_reportSeq &)
{
  Asn1Error << "use of incompletely defined SMS_reportSeq::SMS_reportSeq (const SMS_reportSeq &)" << std::endl;
  abort();
}

SMS_reportSeq::~SMS_reportSeq()
{
  delete transfer_status;
  delete other_message;
  delete content;
}

AsnType *SMS_reportSeq::Clone() const
{
  return new SMS_reportSeq;
}

#if SNACC_DEEP_COPY
SMS_reportSeq &SMS_reportSeq::operator = (const SMS_reportSeq &that)
#else // SNACC_DEEP_COPY
SMS_reportSeq &SMS_reportSeq::operator = (const SMS_reportSeq &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    initiator = that.initiator;
    if (that.transfer_status)
    {
      if (!transfer_status)
        transfer_status = new SMS_reportSeqEnum1;
      *transfer_status = *that.transfer_status;
    }
    else
    {
      delete transfer_status;
      transfer_status = NULL;
    }
    if (that.other_message)
    {
      if (!other_message)
        other_message = new SMS_reportSeqEnum2;
      *other_message = *that.other_message;
    }
    else
    {
      delete other_message;
      other_message = NULL;
    }
    if (that.content)
    {
      if (!content)
        content = new AsnOcts;
      *content = *that.content;
    }
    else
    {
      delete content;
      content = NULL;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined SMS_reportSeq &SMS_reportSeq::operator = (const SMS_reportSeq &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
SMS_reportSeq::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

  if (NOT_NULL (content))
  {
    l = content->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 4);
    totalLen += l;
  }

  if (NOT_NULL (other_message))
  {
    l = other_message->BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, CNTX, PRIM, 3);
    totalLen += l;
  }

  if (NOT_NULL (transfer_status))
  {
    l = transfer_status->BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, CNTX, PRIM, 2);
    totalLen += l;
  }

    l = initiator.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, CNTX, PRIM, 1);
    totalLen += l;

  return totalLen;
} // SMS_reportSeq::BEncContent


void SMS_reportSeq::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    initiator.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << std::endl;
    longjmp (env, -134);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    transfer_status = new SMS_reportSeqEnum1;
    transfer_status->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    other_message = new SMS_reportSeqEnum2;
    other_message->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 4)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    content = new AsnOcts;
    content->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << std::endl;
    longjmp (env, -135);
  }
  else
    return;
} // SMS_reportSeq::BDecContent

AsnLen SMS_reportSeq::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void SMS_reportSeq::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "SMS_reportSeq::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -136);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int SMS_reportSeq::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int SMS_reportSeq::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void SMS_reportSeq::Print (std::ostream &os) const
{
  os << "{ -- SEQUENCE --" << std::endl;
  indentG += stdIndentG;

  {
    Indent (os, indentG);
    os << "initiator ";
    os << initiator;
    os << "," << std::endl;
  }

  if (NOT_NULL (transfer_status))
  {
    os << ","<< std::endl;
    Indent (os, indentG);
    os << "transfer-status ";
    os << *transfer_status;
  }
  else
  {
    Indent (os, indentG);
    os << "transfer-status ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (other_message))
  {
    os << ","<< std::endl;
    Indent (os, indentG);
    os << "other-message ";
    os << *other_message;
  }
  else
  {
    Indent (os, indentG);
    os << "other-message ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (content))
  {
    os << ","<< std::endl;
    Indent (os, indentG);
    os << "content ";
    os << *content;
  }
  else
  {
    Indent (os, indentG);
    os << "content ";
    os << "-- void --";
    os << std::endl;
  }

  os << std::endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // SMS_reportSeq::Print


Non_Standard_Supplementary_ServicesChoice::Non_Standard_Supplementary_ServicesChoice()
{
  choiceId = simpleIndicationCid;
#if TCL
  simpleIndication = new SimpleIndication;
#else
  simpleIndication = NULL; // incomplete initialization of mandatory element!
#endif // TCL
}

//Begin of this was not created by snacc
Non_Standard_Supplementary_ServicesChoice::Non_Standard_Supplementary_ServicesChoice(SimpleIndication psimpleIndication)
{
    choiceId = simpleIndicationCid;
    simpleIndication = new SimpleIndication(psimpleIndication);
}
Non_Standard_Supplementary_ServicesChoice::Non_Standard_Supplementary_ServicesChoice(const char *psciData)
{
    choiceId = sciDataCid;
    sciData = new AsnOcts;
    sciData->Set(psciData);
}
//End of this was not created by snacc


Non_Standard_Supplementary_ServicesChoice::Non_Standard_Supplementary_ServicesChoice (const Non_Standard_Supplementary_ServicesChoice &)
{
  Asn1Error << "use of incompletely defined Non_Standard_Supplementary_ServicesChoice::Non_Standard_Supplementary_ServicesChoice (const Non_Standard_Supplementary_ServicesChoice &)" << std::endl;
  abort();
}

Non_Standard_Supplementary_ServicesChoice::~Non_Standard_Supplementary_ServicesChoice()
{
  switch (choiceId)
  {
    case simpleIndicationCid:
      delete simpleIndication;
      break;
    case sciDataCid:
      delete sciData;
      break;
  } // end of switch
} // end of destructor

AsnType *Non_Standard_Supplementary_ServicesChoice::Clone() const
{
  return new Non_Standard_Supplementary_ServicesChoice;
}

#if SNACC_DEEP_COPY
Non_Standard_Supplementary_ServicesChoice &Non_Standard_Supplementary_ServicesChoice::operator = (const Non_Standard_Supplementary_ServicesChoice &that)
#else // SNACC_DEEP_COPY
Non_Standard_Supplementary_ServicesChoice &Non_Standard_Supplementary_ServicesChoice::operator = (const Non_Standard_Supplementary_ServicesChoice &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    switch (choiceId)
    {
      case simpleIndicationCid:
        delete simpleIndication;
        break;
      case sciDataCid:
        delete sciData;
        break;
    }
    switch (choiceId = that.choiceId)
    {
      case simpleIndicationCid:
        simpleIndication = new SimpleIndication;
        *simpleIndication = *that.simpleIndication;
        break;
      case sciDataCid:
        sciData = new SciDataMode;
        *sciData = *that.sciData;
        break;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined Non_Standard_Supplementary_ServicesChoice &Non_Standard_Supplementary_ServicesChoice::operator = (const Non_Standard_Supplementary_ServicesChoice &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
Non_Standard_Supplementary_ServicesChoice::BEncContent (BUF_TYPE b)
{
  AsnLen l;
  switch (choiceId)
  {
    case simpleIndicationCid:
      l = simpleIndication->BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, CNTX, PRIM, 1);
      break;

    case sciDataCid:
      l = sciData->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 2);
      break;

  } // end switch
  return l;
} // Non_Standard_Supplementary_ServicesChoice::BEncContent


void Non_Standard_Supplementary_ServicesChoice::BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  switch (tag)
  {
    case MAKE_TAG_ID (CNTX, PRIM, 1):
      choiceId = simpleIndicationCid;
      simpleIndication = new SimpleIndication;
        simpleIndication->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 2):
    case MAKE_TAG_ID (CNTX, CONS, 2):
      choiceId = sciDataCid;
      sciData = new SciDataMode;
        sciData->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    default:
      Asn1Error << "ERROR - unexpected tag in CHOICE" << std::endl;
      longjmp (env, -137);
      break;
  } // end switch
} // Non_Standard_Supplementary_ServicesChoice::BDecContent


AsnLen Non_Standard_Supplementary_ServicesChoice::BEnc (BUF_TYPE b)
{
    AsnLen l;
    l = BEncContent (b);
    return l;
}

void Non_Standard_Supplementary_ServicesChoice::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
    AsnLen elmtLen;
    AsnTag tag;

    /*  CHOICEs are a special case - grab identifying tag */
    /*  this allows easier handling of nested CHOICEs */
    tag = BDecTag (b, bytesDecoded, env);
    elmtLen = BDecLen (b, bytesDecoded, env);
    BDecContent (b, tag, elmtLen, bytesDecoded, env);
}

int Non_Standard_Supplementary_ServicesChoice::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int Non_Standard_Supplementary_ServicesChoice::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void Non_Standard_Supplementary_ServicesChoice::Print (std::ostream &os) const
{
  switch (choiceId)
  {
    case simpleIndicationCid:
      os << "simpleIndication ";
      if (simpleIndication)
        os << *simpleIndication;
      else
        os << "-- void3 --\n";
      break;

    case sciDataCid:
      os << "sciData ";
      if (sciData)
        os << *sciData;
      else
        os << "-- void3 --\n";
      break;

  } // end of switch
} // Non_Standard_Supplementary_ServicesChoice::Print

GSMLocationSeq2::GSMLocationSeq2()
{
  mapDatum = NULL;
}

//----------------------------------------------------------------------------------------------------
//Begin this was not generated by snacc
GSMLocationSeq2::GSMLocationSeq2(const char *putmref_string, MapDatum  pmapDatum)
{
    utmref_string=putmref_string;
    mapDatum = new MapDatum(pmapDatum);
}

//End this was not generated by snacc
//----------------------------------------------------------------------------------------------------


GSMLocationSeq2::GSMLocationSeq2 (const GSMLocationSeq2 &)
{
  Asn1Error << "use of incompletely defined GSMLocationSeq2::GSMLocationSeq2 (const GSMLocationSeq2 &)" << std::endl;
  abort();
}

GSMLocationSeq2::~GSMLocationSeq2()
{
  delete mapDatum;
}

AsnType *GSMLocationSeq2::Clone() const
{
  return new GSMLocationSeq2;
}

#if SNACC_DEEP_COPY
GSMLocationSeq2 &GSMLocationSeq2::operator = (const GSMLocationSeq2 &that)
#else // SNACC_DEEP_COPY
GSMLocationSeq2 &GSMLocationSeq2::operator = (const GSMLocationSeq2 &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    utmref_string = that.utmref_string;
    if (that.mapDatum)
    {
      if (!mapDatum)
        mapDatum = new MapDatum;
      *mapDatum = *that.mapDatum;
    }
    else
    {
      delete mapDatum;
      mapDatum = NULL;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined GSMLocationSeq2 &GSMLocationSeq2::operator = (const GSMLocationSeq2 &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
GSMLocationSeq2::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

  if (NOT_NULL (mapDatum))
  {
    l = mapDatum->BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, ENUM_TAG_CODE);
    totalLen += l;
  }

    l = utmref_string.BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, UNIV, PRIM, PRINTABLESTRING_TAG_CODE);
    totalLen += l;

  return totalLen;
} // GSMLocationSeq2::BEncContent


void GSMLocationSeq2::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, PRINTABLESTRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, CONS, PRINTABLESTRING_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    utmref_string.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << std::endl;
    longjmp (env, -138);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, ENUM_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    mapDatum = new MapDatum;
    mapDatum->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << std::endl;
    longjmp (env, -139);
  }
  else
    return;
} // GSMLocationSeq2::BDecContent

AsnLen GSMLocationSeq2::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void GSMLocationSeq2::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "GSMLocationSeq2::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -140);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int GSMLocationSeq2::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int GSMLocationSeq2::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void GSMLocationSeq2::Print (std::ostream &os) const
{
  os << "{ -- SEQUENCE --" << std::endl;
  indentG += stdIndentG;

  {
    Indent (os, indentG);
    os << "utmref-string ";
    os << utmref_string;
    os << "," << std::endl;
  }

  if (NOT_NULL (mapDatum))
  {
    os << ","<< std::endl;
    Indent (os, indentG);
    os << "mapDatum ";
    os << *mapDatum;
  }
  else
  {
    Indent (os, indentG);
    os << "mapDatum ";
    os << "-- void --";
    os << std::endl;
  }

  os << std::endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // GSMLocationSeq2::Print


GSMLocationSeq1::GSMLocationSeq1()
{
  mapDatum = NULL;
  azimuth = NULL;
}

//---------------------------------------------------------------------------------------------------------------------
//Begin this was not generated by snacc
//MapDatum enum{wGS84, wGS72, eD50};
GSMLocationSeq1::GSMLocationSeq1(const char *putm_East,const char *putm_North, MapDatum  pmapDatum)
{
    utm_East = putm_East;
    utm_North = putm_North;
    mapDatum = new MapDatum(pmapDatum);
    azimuth = NULL;
}
GSMLocationSeq1::GSMLocationSeq1(const char *putm_East,const char *putm_North, unsigned int pazimuth, MapDatum  pmapDatum)
{
    utm_East = putm_East;
    utm_North = putm_North;
    mapDatum = new MapDatum(pmapDatum);
    azimuth = new AsnInt(pazimuth);
}

//End this was not generated by snacc
//---------------------------------------------------------------------------------------------------------------------



GSMLocationSeq1::GSMLocationSeq1 (const GSMLocationSeq1 &)
{
  Asn1Error << "use of incompletely defined GSMLocationSeq1::GSMLocationSeq1 (const GSMLocationSeq1 &)" << std::endl;
  abort();
}

GSMLocationSeq1::~GSMLocationSeq1()
{
  delete mapDatum;
  delete azimuth;
}

AsnType *GSMLocationSeq1::Clone() const
{
  return new GSMLocationSeq1;
}

#if SNACC_DEEP_COPY
GSMLocationSeq1 &GSMLocationSeq1::operator = (const GSMLocationSeq1 &that)
#else // SNACC_DEEP_COPY
GSMLocationSeq1 &GSMLocationSeq1::operator = (const GSMLocationSeq1 &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    utm_East = that.utm_East;
    utm_North = that.utm_North;
    if (that.mapDatum)
    {
      if (!mapDatum)
        mapDatum = new MapDatum;
      *mapDatum = *that.mapDatum;
    }
    else
    {
      delete mapDatum;
      mapDatum = NULL;
    }
    if (that.azimuth)
    {
      if (!azimuth)
        azimuth = new AsnInt;
      *azimuth = *that.azimuth;
    }
    else
    {
      delete azimuth;
      azimuth = NULL;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined GSMLocationSeq1 &GSMLocationSeq1::operator = (const GSMLocationSeq1 &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
GSMLocationSeq1::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

  if (NOT_NULL (azimuth))
  {
    l = azimuth->BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, CNTX, PRIM, 4);
    totalLen += l;
  }

  if (NOT_NULL (mapDatum))
  {
    l = mapDatum->BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, CNTX, PRIM, 3);
    totalLen += l;
  }

    l = utm_North.BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 2);
    totalLen += l;

    l = utm_East.BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 1);
    totalLen += l;

  return totalLen;
} // GSMLocationSeq1::BEncContent


void GSMLocationSeq1::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    utm_East.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << std::endl;
    longjmp (env, -141);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    utm_North.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << std::endl;
    longjmp (env, -142);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    mapDatum = new MapDatum;
    mapDatum->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    azimuth = new AsnInt;
    azimuth->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << std::endl;
    longjmp (env, -143);
  }
  else
    return;
} // GSMLocationSeq1::BDecContent

AsnLen GSMLocationSeq1::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void GSMLocationSeq1::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "GSMLocationSeq1::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -144);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int GSMLocationSeq1::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int GSMLocationSeq1::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void GSMLocationSeq1::Print (std::ostream &os) const
{
  os << "{ -- SEQUENCE --" << std::endl;
  indentG += stdIndentG;

  {
    Indent (os, indentG);
    os << "utm-East ";
    os << utm_East;
    os << "," << std::endl;
  }

  {
    Indent (os, indentG);
    os << "utm-North ";
    os << utm_North;
    os << "," << std::endl;
  }

  if (NOT_NULL (mapDatum))
  {
    os << ","<< std::endl;
    Indent (os, indentG);
    os << "mapDatum ";
    os << *mapDatum;
  }
  else
  {
    Indent (os, indentG);
    os << "mapDatum ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (azimuth))
  {
    os << ","<< std::endl;
    Indent (os, indentG);
    os << "azimuth ";
    os << *azimuth;
  }
  else
  {
    Indent (os, indentG);
    os << "azimuth ";
    os << "-- void --";
    os << std::endl;
  }

  os << std::endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // GSMLocationSeq1::Print


GSMLocationSeq::GSMLocationSeq()
{
  mapDatum = NULL;
  azimuth = NULL;
}

//---------------------------------------------------------------------------------------------------------------------
//Begin this was not generated by snacc
//MapDatum enum{wGS84, wGS72, eD50};
GSMLocationSeq::GSMLocationSeq(const char *platitude,const char *plongitude, MapDatum  pmapDatum)
{
    latitude = platitude;
    longitude = plongitude;
    mapDatum = new MapDatum(pmapDatum);
    azimuth = NULL;
}
GSMLocationSeq::GSMLocationSeq(const char *platitude,const char *plongitude, unsigned int pazimuth, MapDatum  pmapDatum)
{
    latitude = platitude;
    longitude = plongitude;
    mapDatum = new MapDatum(pmapDatum);
    azimuth = new AsnInt(pazimuth);
}

//End this was not generated by snacc
//---------------------------------------------------------------------------------------------------------------------

GSMLocationSeq::GSMLocationSeq (const GSMLocationSeq &)
{
  Asn1Error << "use of incompletely defined GSMLocationSeq::GSMLocationSeq (const GSMLocationSeq &)" << std::endl;
  abort();
}

GSMLocationSeq::~GSMLocationSeq()
{
  delete mapDatum;
  delete azimuth;
}

AsnType *GSMLocationSeq::Clone() const
{
  return new GSMLocationSeq;
}

#if SNACC_DEEP_COPY
GSMLocationSeq &GSMLocationSeq::operator = (const GSMLocationSeq &that)
#else // SNACC_DEEP_COPY
GSMLocationSeq &GSMLocationSeq::operator = (const GSMLocationSeq &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    latitude = that.latitude;
    longitude = that.longitude;
    if (that.mapDatum)
    {
      if (!mapDatum)
        mapDatum = new MapDatum;
      *mapDatum = *that.mapDatum;
    }
    else
    {
      delete mapDatum;
      mapDatum = NULL;
    }
    if (that.azimuth)
    {
      if (!azimuth)
        azimuth = new AsnInt;
      *azimuth = *that.azimuth;
    }
    else
    {
      delete azimuth;
      azimuth = NULL;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined GSMLocationSeq &GSMLocationSeq::operator = (const GSMLocationSeq &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
GSMLocationSeq::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

  if (NOT_NULL (azimuth))
  {
    l = azimuth->BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, CNTX, PRIM, 4);
    totalLen += l;
  }

  if (NOT_NULL (mapDatum))
  {
    l = mapDatum->BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, CNTX, PRIM, 3);
    totalLen += l;
  }

    l = longitude.BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 2);
    totalLen += l;

    l = latitude.BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 1);
    totalLen += l;

  return totalLen;
} // GSMLocationSeq::BEncContent


void GSMLocationSeq::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    latitude.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << std::endl;
    longjmp (env, -145);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    longitude.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << std::endl;
    longjmp (env, -146);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    mapDatum = new MapDatum;
    mapDatum->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    azimuth = new AsnInt;
    azimuth->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << std::endl;
    longjmp (env, -147);
  }
  else
    return;
} // GSMLocationSeq::BDecContent

AsnLen GSMLocationSeq::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void GSMLocationSeq::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "GSMLocationSeq::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -148);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int GSMLocationSeq::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int GSMLocationSeq::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void GSMLocationSeq::Print (std::ostream &os) const
{
  os << "{ -- SEQUENCE --" << std::endl;
  indentG += stdIndentG;

  {
    Indent (os, indentG);
    os << "latitude ";
    os << latitude;
    os << "," << std::endl;
  }

  {
    Indent (os, indentG);
    os << "longitude ";
    os << longitude;
    os << "," << std::endl;
  }

  if (NOT_NULL (mapDatum))
  {
    os << ","<< std::endl;
    Indent (os, indentG);
    os << "mapDatum ";
    os << *mapDatum;
  }
  else
  {
    Indent (os, indentG);
    os << "mapDatum ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (azimuth))
  {
    os << ","<< std::endl;
    Indent (os, indentG);
    os << "azimuth ";
    os << *azimuth;
  }
  else
  {
    Indent (os, indentG);
    os << "azimuth ";
    os << "-- void --";
    os << std::endl;
  }

  os << std::endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // GSMLocationSeq::Print


PartyInformationSeq::PartyInformationSeq()
{
  imei = NULL;
  tei = NULL;
  imsi = NULL;
  callingPartyNumber = NULL;
  calledPartyNumber = NULL;
  msISDN = NULL;
  e164_Format = NULL;
  sip_uri = NULL;
  tel_url = NULL;
}

PartyInformationSeq::PartyInformationSeq (const PartyInformationSeq &)
{
  Asn1Error << "use of incompletely defined PartyInformationSeq::PartyInformationSeq (const PartyInformationSeq &)" << std::endl;
  abort();
}

PartyInformationSeq::~PartyInformationSeq()
{
  delete imei;
  delete tei;
  delete imsi;
  delete callingPartyNumber;
  delete calledPartyNumber;
  delete msISDN;
  delete e164_Format;
  delete sip_uri;
  delete tel_url;
}

AsnType *PartyInformationSeq::Clone() const
{
  return new PartyInformationSeq;
}

#if SNACC_DEEP_COPY
PartyInformationSeq &PartyInformationSeq::operator = (const PartyInformationSeq &that)
#else // SNACC_DEEP_COPY
PartyInformationSeq &PartyInformationSeq::operator = (const PartyInformationSeq &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    if (that.imei)
    {
      if (!imei)
        imei = new AsnOcts;
      *imei = *that.imei;
    }
    else
    {
      delete imei;
      imei = NULL;
    }
    if (that.tei)
    {
      if (!tei)
        tei = new AsnOcts;
      *tei = *that.tei;
    }
    else
    {
      delete tei;
      tei = NULL;
    }
    if (that.imsi)
    {
      if (!imsi)
        imsi = new AsnOcts;
      *imsi = *that.imsi;
    }
    else
    {
      delete imsi;
      imsi = NULL;
    }
    if (that.callingPartyNumber)
    {
      if (!callingPartyNumber)
        callingPartyNumber = new CallingPartyNumber;
      *callingPartyNumber = *that.callingPartyNumber;
    }
    else
    {
      delete callingPartyNumber;
      callingPartyNumber = NULL;
    }
    if (that.calledPartyNumber)
    {
      if (!calledPartyNumber)
        calledPartyNumber = new CalledPartyNumber;
      *calledPartyNumber = *that.calledPartyNumber;
    }
    else
    {
      delete calledPartyNumber;
      calledPartyNumber = NULL;
    }
    if (that.msISDN)
    {
      if (!msISDN)
        msISDN = new AsnOcts;
      *msISDN = *that.msISDN;
    }
    else
    {
      delete msISDN;
      msISDN = NULL;
    }
    if (that.e164_Format)
    {
      if (!e164_Format)
        e164_Format = new AsnOcts;
      *e164_Format = *that.e164_Format;
    }
    else
    {
      delete e164_Format;
      e164_Format = NULL;
    }
    if (that.sip_uri)
    {
      if (!sip_uri)
        sip_uri = new AsnOcts;
      *sip_uri = *that.sip_uri;
    }
    else
    {
      delete sip_uri;
      sip_uri = NULL;
    }
    if (that.tel_url)
    {
      if (!tel_url)
        tel_url = new AsnOcts;
      *tel_url = *that.tel_url;
    }
    else
    {
      delete tel_url;
      tel_url = NULL;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined PartyInformationSeq &PartyInformationSeq::operator = (const PartyInformationSeq &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
PartyInformationSeq::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

  if (NOT_NULL (tel_url))
  {
    l = tel_url->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 9);
    totalLen += l;
  }

  if (NOT_NULL (sip_uri))
  {
    l = sip_uri->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 8);
    totalLen += l;
  }

  if (NOT_NULL (e164_Format))
  {
    l = e164_Format->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 7);
    totalLen += l;
  }

  if (NOT_NULL (msISDN))
  {
    l = msISDN->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 6);
    totalLen += l;
  }

  if (NOT_NULL (calledPartyNumber))
  {
      BEncEocIfNec (b);
    l = calledPartyNumber->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 5);
    totalLen += l;
  }

  if (NOT_NULL (callingPartyNumber))
  {
      BEncEocIfNec (b);
    l = callingPartyNumber->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 4);
    totalLen += l;
  }

  if (NOT_NULL (imsi))
  {
    l = imsi->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 3);
    totalLen += l;
  }

  if (NOT_NULL (tei))
  {
    l = tei->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 2);
    totalLen += l;
  }

  if (NOT_NULL (imei))
  {
    l = imei->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 1);
    totalLen += l;
  }

  return totalLen;
} // PartyInformationSeq::BEncContent


void PartyInformationSeq::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  AsnLen elmtLen2;
  if (elmtLen0 == 0)
    return;
  else
  {
    tag1 = BDecTag (b, seqBytesDecoded, env);

    if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
    {
      BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
      bytesDecoded += seqBytesDecoded;
      return;
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    imei = new AsnOcts;
    imei->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    tei = new AsnOcts;
    tei->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 3)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    imsi = new AsnOcts;
    imsi->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 4)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
    elmtLen2 = BDecLen (b, seqBytesDecoded, env);
    callingPartyNumber = new CallingPartyNumber;
    callingPartyNumber->BDecContent (b, tag1, elmtLen2, seqBytesDecoded, env);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (b, seqBytesDecoded, env);

    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 5)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
    elmtLen2 = BDecLen (b, seqBytesDecoded, env);
    calledPartyNumber = new CalledPartyNumber;
    calledPartyNumber->BDecContent (b, tag1, elmtLen2, seqBytesDecoded, env);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (b, seqBytesDecoded, env);

    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 6))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 6)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    msISDN = new AsnOcts;
    msISDN->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 7))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 7)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    e164_Format = new AsnOcts;
    e164_Format->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 8))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 8)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    sip_uri = new AsnOcts;
    sip_uri->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 9))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 9)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    tel_url = new AsnOcts;
    tel_url->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << std::endl;
    longjmp (env, -149);
  }
  else
    return;
} // PartyInformationSeq::BDecContent

AsnLen PartyInformationSeq::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void PartyInformationSeq::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "PartyInformationSeq::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -150);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int PartyInformationSeq::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int PartyInformationSeq::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void PartyInformationSeq::Print (std::ostream &os) const
{
  int nonePrinted = true;
  os << "{ -- SEQUENCE --" << std::endl;
  indentG += stdIndentG;

  if (NOT_NULL (imei))
  {
    nonePrinted = false;
    Indent (os, indentG);
    os << "imei ";
    os << *imei;
  }
  else
  {
    Indent (os, indentG);
    os << "imei ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (tei))
  {
    if (!nonePrinted)
      os << "," << std::endl;
    nonePrinted = false;
    Indent (os, indentG);
    os << "tei ";
    os << *tei;
  }
  else
  {
    Indent (os, indentG);
    os << "tei ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (imsi))
  {
    if (!nonePrinted)
      os << "," << std::endl;
    nonePrinted = false;
    Indent (os, indentG);
    os << "imsi ";
    os << *imsi;
  }
  else
  {
    Indent (os, indentG);
    os << "imsi ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (callingPartyNumber))
  {
    if (!nonePrinted)
      os << "," << std::endl;
    nonePrinted = false;
    Indent (os, indentG);
    os << "callingPartyNumber ";
    os << *callingPartyNumber;
  }
  else
  {
    Indent (os, indentG);
    os << "callingPartyNumber ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (calledPartyNumber))
  {
    if (!nonePrinted)
      os << "," << std::endl;
    nonePrinted = false;
    Indent (os, indentG);
    os << "calledPartyNumber ";
    os << *calledPartyNumber;
  }
  else
  {
    Indent (os, indentG);
    os << "calledPartyNumber ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (msISDN))
  {
    if (!nonePrinted)
      os << "," << std::endl;
    nonePrinted = false;
    Indent (os, indentG);
    os << "msISDN ";
    os << *msISDN;
  }
  else
  {
    Indent (os, indentG);
    os << "msISDN ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (e164_Format))
  {
    if (!nonePrinted)
      os << "," << std::endl;
    nonePrinted = false;
    Indent (os, indentG);
    os << "e164-Format ";
    os << *e164_Format;
  }
  else
  {
    Indent (os, indentG);
    os << "e164-Format ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (sip_uri))
  {
    if (!nonePrinted)
      os << "," << std::endl;
    nonePrinted = false;
    Indent (os, indentG);
    os << "sip-uri ";
    os << *sip_uri;
  }
  else
  {
    Indent (os, indentG);
    os << "sip-uri ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (tel_url))
  {
    if (!nonePrinted)
      os << "," << std::endl;
    nonePrinted = false;
    Indent (os, indentG);
    os << "tel-url ";
    os << *tel_url;
  }
  else
  {
    Indent (os, indentG);
    os << "tel-url ";
    os << "-- void --";
    os << std::endl;
  }

  os << std::endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // PartyInformationSeq::Print


LocalTimeStamp::LocalTimeStamp()
{
}

//-----------------------------------------------------------------------------------------------------
//Begin this is not generated by snacc
LocalTimeStamp::LocalTimeStamp(const char*generalizedTimeStr,LocalTimeStampEnum  pwinterSummerIndication)
{
    generalizedTime = generalizedTimeStr;
    winterSummerIndication = pwinterSummerIndication;
}
//End this is not generated by snacc
//-----------------------------------------------------------------------------------------------------
LocalTimeStamp::LocalTimeStamp (const LocalTimeStamp &)
{
  Asn1Error << "use of incompletely defined LocalTimeStamp::LocalTimeStamp (const LocalTimeStamp &)" << std::endl;
  abort();
}

LocalTimeStamp::~LocalTimeStamp()
{
}

AsnType *LocalTimeStamp::Clone() const
{
  return new LocalTimeStamp;
}

#if SNACC_DEEP_COPY
LocalTimeStamp &LocalTimeStamp::operator = (const LocalTimeStamp &that)
#else // SNACC_DEEP_COPY
LocalTimeStamp &LocalTimeStamp::operator = (const LocalTimeStamp &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    generalizedTime = that.generalizedTime;
    winterSummerIndication = that.winterSummerIndication;
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined LocalTimeStamp &LocalTimeStamp::operator = (const LocalTimeStamp &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
LocalTimeStamp::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

    l = winterSummerIndication.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, CNTX, PRIM, 1);
    totalLen += l;

    l = generalizedTime.BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // LocalTimeStamp::BEncContent


void LocalTimeStamp::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    generalizedTime.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << std::endl;
    longjmp (env, -151);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    winterSummerIndication.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << std::endl;
    longjmp (env, -152);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << std::endl;
    longjmp (env, -153);
  }
  else
    return;
} // LocalTimeStamp::BDecContent

AsnLen LocalTimeStamp::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void LocalTimeStamp::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "LocalTimeStamp::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -154);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int LocalTimeStamp::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int LocalTimeStamp::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void LocalTimeStamp::Print (std::ostream &os) const
{
  os << "{ -- SEQUENCE --" << std::endl;
  indentG += stdIndentG;

  {
    Indent (os, indentG);
    os << "generalizedTime ";
    os << generalizedTime;
    os << "," << std::endl;
  }

  {
    Indent (os, indentG);
    os << "winterSummerIndication ";
    os << winterSummerIndication;
  }

  os << std::endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // LocalTimeStamp::Print


TetraLocation::TetraLocation()
{
  choiceId = ms_LocCid;
#if TCL
  ms_Loc = new TetraLocationSeq;
#else
  ms_Loc = NULL; // incomplete initialization of mandatory element!
#endif // TCL
}

//-------------------------------------------------------------------------------------------------------
//Begin this was not generated by snacc

TetraLocation::TetraLocation(int pls_loc)
{
    choiceId = ls_LocCid;
    ls_Loc = new AsnInt(pls_loc);
}
TetraLocation::TetraLocation(unsigned int mcc, unsigned int mnc, unsigned int lai)
{
    choiceId = ms_LocCid;
    ms_Loc = new TetraLocationSeq(mcc, mnc, lai);
}
TetraLocation::TetraLocation(unsigned int mcc, unsigned int mnc, unsigned int lai, int ci)
{
    choiceId = ms_LocCid;
    ms_Loc = new TetraLocationSeq(mcc, mnc, lai, ci);
}


//End this was not generated by snacc
//-------------------------------------------------------------------------------------------------------


TetraLocation::TetraLocation (const TetraLocation &)
{
  Asn1Error << "use of incompletely defined TetraLocation::TetraLocation (const TetraLocation &)" << std::endl;
  abort();
}

TetraLocation::~TetraLocation()
{
  switch (choiceId)
  {
    case ms_LocCid:
      delete ms_Loc;
      break;
    case ls_LocCid:
      delete ls_Loc;
      break;
  } // end of switch
} // end of destructor

AsnType *TetraLocation::Clone() const
{
  return new TetraLocation;
}

#if SNACC_DEEP_COPY
TetraLocation &TetraLocation::operator = (const TetraLocation &that)
#else // SNACC_DEEP_COPY
TetraLocation &TetraLocation::operator = (const TetraLocation &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    switch (choiceId)
    {
      case ms_LocCid:
        delete ms_Loc;
        break;
      case ls_LocCid:
        delete ls_Loc;
        break;
    }
    switch (choiceId = that.choiceId)
    {
      case ms_LocCid:
        ms_Loc = new TetraLocationSeq;
        *ms_Loc = *that.ms_Loc;
        break;
      case ls_LocCid:
        ls_Loc = new AsnInt;
        *ls_Loc = *that.ls_Loc;
        break;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined TetraLocation &TetraLocation::operator = (const TetraLocation &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
TetraLocation::BEncContent (BUF_TYPE b)
{
  AsnLen l;
  switch (choiceId)
  {
    case ms_LocCid:
      BEncEocIfNec (b);
      l = ms_Loc->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 1);
      break;

    case ls_LocCid:
      l = ls_Loc->BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, CNTX, PRIM, 2);
      break;

  } // end switch
  return l;
} // TetraLocation::BEncContent


void TetraLocation::BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  switch (tag)
  {
    case MAKE_TAG_ID (CNTX, CONS, 1):
      choiceId = ms_LocCid;
      ms_Loc = new TetraLocationSeq;
        ms_Loc->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 2):
      choiceId = ls_LocCid;
      ls_Loc = new AsnInt;
        ls_Loc->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    default:
      Asn1Error << "ERROR - unexpected tag in CHOICE" << std::endl;
      longjmp (env, -155);
      break;
  } // end switch
} // TetraLocation::BDecContent


AsnLen TetraLocation::BEnc (BUF_TYPE b)
{
    AsnLen l;
    l = BEncContent (b);
    return l;
}

void TetraLocation::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
    AsnLen elmtLen;
    AsnTag tag;

    /*  CHOICEs are a special case - grab identifying tag */
    /*  this allows easier handling of nested CHOICEs */
    tag = BDecTag (b, bytesDecoded, env);
    elmtLen = BDecLen (b, bytesDecoded, env);
    BDecContent (b, tag, elmtLen, bytesDecoded, env);
}

int TetraLocation::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int TetraLocation::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void TetraLocation::Print (std::ostream &os) const
{
  switch (choiceId)
  {
    case ms_LocCid:
      os << "ms-Loc ";
      if (ms_Loc)
        os << *ms_Loc;
      else
        os << "-- void3 --\n";
      break;

    case ls_LocCid:
      os << "ls-Loc ";
      if (ls_Loc)
        os << *ls_Loc;
      else
        os << "-- void3 --\n";
      break;

  } // end of switch
} // TetraLocation::Print

GSMLocation::GSMLocation()
{
/*
  choiceId = geoCoordinatesCid;
#if TCL
  geoCoordinates = new GSMLocationSeq;
#else
  geoCoordinates = NULL; // incomplete initialization of mandatory element!
#endif // TCL
*/
  choiceId = geoCoordinatesCid;
  geoCoordinates = NULL;
}

//------------------------------------------------------------------------------------------------------------------
//Begin of this was not generated by snacc

void GSMLocation::CreateGeoCoordinates(const char *platitude,const char *plongitude, MapDatum  pmapDatum)
{
    choiceId = geoCoordinatesCid;
    geoCoordinates = new GSMLocationSeq(platitude, plongitude, pmapDatum);
}
void GSMLocation::CreateGeoCoordinates(const char *platitude,const char *plongitude, unsigned int pazimuth, MapDatum  pmapDatum)
{
    choiceId = geoCoordinatesCid;
    geoCoordinates = new GSMLocationSeq(platitude, plongitude, pmapDatum,  pazimuth);
}
void GSMLocation::CreateUtmCoordinates(const char *putm_East,const char *putm_North, MapDatum  pmapDatum)
{
    choiceId = utmCoordinatesCid;
    utmCoordinates = new GSMLocationSeq1(putm_East, putm_North, pmapDatum);
}
void GSMLocation::CreateUtmCoordinates(const char *putm_East,const char *putm_North, unsigned int pazimuth, MapDatum  pmapDatum)
{
    choiceId = utmCoordinatesCid;
    utmCoordinates = new GSMLocationSeq1(putm_East, putm_North, pmapDatum, pazimuth);
}

void GSMLocation::CreateUtmRefCoordinates(const char *putmref_string,MapDatum  pmapDatum)
{
    choiceId = utmRefCoordinatesCid;
    utmRefCoordinates = new GSMLocationSeq2(putmref_string, pmapDatum);
}
void GSMLocation::CreateWGS84Coordinates( const char *pwGS84Coordinates)
{
    choiceId=wGS84CoordinatesCid;
    wGS84Coordinates = new AsnOcts;
    wGS84Coordinates->Set( pwGS84Coordinates);
}

//End of this was not generated by snacc
//------------------------------------------------------------------------------------------------------------------

GSMLocation::GSMLocation (const GSMLocation &)
{
  Asn1Error << "use of incompletely defined GSMLocation::GSMLocation (const GSMLocation &)" << std::endl;
  abort();
}

GSMLocation::~GSMLocation()
{
  switch (choiceId)
  {
    case geoCoordinatesCid:
      delete geoCoordinates;
      break;
    case utmCoordinatesCid:
      delete utmCoordinates;
      break;
    case utmRefCoordinatesCid:
      delete utmRefCoordinates;
      break;
    case wGS84CoordinatesCid:
      delete wGS84Coordinates;
      break;
  } // end of switch
} // end of destructor

AsnType *GSMLocation::Clone() const
{
  return new GSMLocation;
}

#if SNACC_DEEP_COPY
GSMLocation &GSMLocation::operator = (const GSMLocation &that)
#else // SNACC_DEEP_COPY
GSMLocation &GSMLocation::operator = (const GSMLocation &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    switch (choiceId)
    {
      case geoCoordinatesCid:
        delete geoCoordinates;
        break;
      case utmCoordinatesCid:
        delete utmCoordinates;
        break;
      case utmRefCoordinatesCid:
        delete utmRefCoordinates;
        break;
      case wGS84CoordinatesCid:
        delete wGS84Coordinates;
        break;
    }
    switch (choiceId = that.choiceId)
    {
      case geoCoordinatesCid:
        geoCoordinates = new GSMLocationSeq;
        *geoCoordinates = *that.geoCoordinates;
        break;
      case utmCoordinatesCid:
        utmCoordinates = new GSMLocationSeq1;
        *utmCoordinates = *that.utmCoordinates;
        break;
      case utmRefCoordinatesCid:
        utmRefCoordinates = new GSMLocationSeq2;
        *utmRefCoordinates = *that.utmRefCoordinates;
        break;
      case wGS84CoordinatesCid:
        wGS84Coordinates = new AsnOcts;
        *wGS84Coordinates = *that.wGS84Coordinates;
        break;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined GSMLocation &GSMLocation::operator = (const GSMLocation &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
GSMLocation::BEncContent (BUF_TYPE b)
{
  AsnLen l;
  switch (choiceId)
  {
    case geoCoordinatesCid:
      BEncEocIfNec (b);
      l = geoCoordinates->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 1);
      break;

    case utmCoordinatesCid:
      BEncEocIfNec (b);
      l = utmCoordinates->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 2);
      break;

    case utmRefCoordinatesCid:
      BEncEocIfNec (b);
      l = utmRefCoordinates->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 3);
      break;

    case wGS84CoordinatesCid:
      l = wGS84Coordinates->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 4);
      break;

  } // end switch
  return l;
} // GSMLocation::BEncContent


void GSMLocation::BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  switch (tag)
  {
    case MAKE_TAG_ID (CNTX, CONS, 1):
      choiceId = geoCoordinatesCid;
      geoCoordinates = new GSMLocationSeq;
        geoCoordinates->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, CONS, 2):
      choiceId = utmCoordinatesCid;
      utmCoordinates = new GSMLocationSeq1;
        utmCoordinates->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, CONS, 3):
      choiceId = utmRefCoordinatesCid;
      utmRefCoordinates = new GSMLocationSeq2;
        utmRefCoordinates->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 4):
    case MAKE_TAG_ID (CNTX, CONS, 4):
      choiceId = wGS84CoordinatesCid;
      wGS84Coordinates = new AsnOcts;
        wGS84Coordinates->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    default:
      Asn1Error << "ERROR - unexpected tag in CHOICE" << std::endl;
      longjmp (env, -156);
      break;
  } // end switch
} // GSMLocation::BDecContent


AsnLen GSMLocation::BEnc (BUF_TYPE b)
{
    AsnLen l;
    l = BEncContent (b);
    return l;
}

void GSMLocation::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
    AsnLen elmtLen;
    AsnTag tag;

    /*  CHOICEs are a special case - grab identifying tag */
    /*  this allows easier handling of nested CHOICEs */
    tag = BDecTag (b, bytesDecoded, env);
    elmtLen = BDecLen (b, bytesDecoded, env);
    BDecContent (b, tag, elmtLen, bytesDecoded, env);
}

int GSMLocation::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int GSMLocation::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void GSMLocation::Print (std::ostream &os) const
{
  switch (choiceId)
  {
    case geoCoordinatesCid:
      os << "geoCoordinates ";
      if (geoCoordinates)
        os << *geoCoordinates;
      else
        os << "-- void3 --\n";
      break;

    case utmCoordinatesCid:
      os << "utmCoordinates ";
      if (utmCoordinates)
        os << *utmCoordinates;
      else
        os << "-- void3 --\n";
      break;

    case utmRefCoordinatesCid:
      os << "utmRefCoordinates ";
      if (utmRefCoordinates)
        os << *utmRefCoordinates;
      else
        os << "-- void3 --\n";
      break;

    case wGS84CoordinatesCid:
      os << "wGS84Coordinates ";
      if (wGS84Coordinates)
        os << *wGS84Coordinates;
      else
        os << "-- void3 --\n";
      break;

  } // end of switch
} // GSMLocation::Print

GeographicalCoordinates::GeographicalCoordinates()
{
}

//------------------------------------------------------------------------------------------------------------------------------
//Begin of this was not generated by compiler

GeographicalCoordinates::GeographicalCoordinates(GeographicalCoordinatesEnum platitudeSign,int platitude, int plongitude)
{
    latitudeSign = platitudeSign;
    latitude = platitude;
    longitude = plongitude;
}

//End of this was not generated by compiler
//------------------------------------------------------------------------------------------------------------------------------
GeographicalCoordinates::GeographicalCoordinates (const GeographicalCoordinates &)
{
  Asn1Error << "use of incompletely defined GeographicalCoordinates::GeographicalCoordinates (const GeographicalCoordinates &)" << std::endl;
  abort();
}

GeographicalCoordinates::~GeographicalCoordinates()
{
}

AsnType *GeographicalCoordinates::Clone() const
{
  return new GeographicalCoordinates;
}

#if SNACC_DEEP_COPY
GeographicalCoordinates &GeographicalCoordinates::operator = (const GeographicalCoordinates &that)
#else // SNACC_DEEP_COPY
GeographicalCoordinates &GeographicalCoordinates::operator = (const GeographicalCoordinates &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    latitudeSign = that.latitudeSign;
    latitude = that.latitude;
    longitude = that.longitude;
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined GeographicalCoordinates &GeographicalCoordinates::operator = (const GeographicalCoordinates &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
GeographicalCoordinates::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

    l = longitude.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

    l = latitude.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

    l = latitudeSign.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, ENUM_TAG_CODE);
    totalLen += l;

  return totalLen;
} // GeographicalCoordinates::BEncContent


void GeographicalCoordinates::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, ENUM_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    latitudeSign.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << std::endl;
    longjmp (env, -157);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    latitude.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << std::endl;
    longjmp (env, -158);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    longitude.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << std::endl;
    longjmp (env, -159);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << std::endl;
    longjmp (env, -160);
  }
  else
    return;
} // GeographicalCoordinates::BDecContent

AsnLen GeographicalCoordinates::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void GeographicalCoordinates::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "GeographicalCoordinates::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -161);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int GeographicalCoordinates::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int GeographicalCoordinates::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void GeographicalCoordinates::Print (std::ostream &os) const
{
  os << "{ -- SEQUENCE --" << std::endl;
  indentG += stdIndentG;

  {
    Indent (os, indentG);
    os << "latitudeSign ";
    os << latitudeSign;
    os << "," << std::endl;
  }

  {
    Indent (os, indentG);
    os << "latitude ";
    os << latitude;
    os << "," << std::endl;
  }

  {
    Indent (os, indentG);
    os << "longitude ";
    os << longitude;
  }

  os << std::endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // GeographicalCoordinates::Print


GA_Point::GA_Point()
{
#if TCL
  geographicalCoordinates = new GeographicalCoordinates;
#else
  geographicalCoordinates = NULL; // incomplete initialization of mandatory element!
#endif // TCL
}

//-------------------------------------------------------------------------------------------
//Begin of this was not generated by compiler

GA_Point::GA_Point(GeographicalCoordinatesEnum platitudeSign,int platitude, int plongitude)
{
      geographicalCoordinates = new GeographicalCoordinates(platitudeSign, platitude, plongitude);
}

//End of this was not generated by compiler
//-------------------------------------------------------------------------------------------


GA_Point::GA_Point (const GA_Point &)
{
  Asn1Error << "use of incompletely defined GA_Point::GA_Point (const GA_Point &)" << std::endl;
  abort();
}

GA_Point::~GA_Point()
{
  delete geographicalCoordinates;
}

AsnType *GA_Point::Clone() const
{
  return new GA_Point;
}

#if SNACC_DEEP_COPY
GA_Point &GA_Point::operator = (const GA_Point &that)
#else // SNACC_DEEP_COPY
GA_Point &GA_Point::operator = (const GA_Point &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    if (that.geographicalCoordinates)
    {
      if (!geographicalCoordinates)
        geographicalCoordinates = new GeographicalCoordinates;
      *geographicalCoordinates = *that.geographicalCoordinates;
    }
    else
    {
      delete geographicalCoordinates;
      geographicalCoordinates = NULL;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined GA_Point &GA_Point::operator = (const GA_Point &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
GA_Point::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

      BEncEocIfNec (b);
    l = geographicalCoordinates->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;

  return totalLen;
} // GA_Point::BEncContent


void GA_Point::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    geographicalCoordinates = new GeographicalCoordinates;
    geographicalCoordinates->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << std::endl;
    longjmp (env, -162);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << std::endl;
    longjmp (env, -163);
  }
  else
    return;
} // GA_Point::BDecContent

AsnLen GA_Point::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void GA_Point::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "GA_Point::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -164);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int GA_Point::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int GA_Point::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void GA_Point::Print (std::ostream &os) const
{
  os << "{ -- SEQUENCE --" << std::endl;
  indentG += stdIndentG;

  if (NOT_NULL (geographicalCoordinates))
  {
    Indent (os, indentG);
    os << "geographicalCoordinates ";
    os << *geographicalCoordinates;
  }
  else
  {
    Indent (os, indentG);
    os << "geographicalCoordinates ";
    os << "-- void --";
    os << std::endl;
  }

  os << std::endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // GA_Point::Print


GA_PointWithUnCertainty::GA_PointWithUnCertainty()
{
#if TCL
  geographicalCoordinates = new GeographicalCoordinates;
#else
  geographicalCoordinates = NULL; // incomplete initialization of mandatory element!
#endif // TCL
}

//-------------------------------------------------------------------------------------------------------------------------------------------
//Begin of this was not generated by compiler

GA_PointWithUnCertainty::GA_PointWithUnCertainty(GeographicalCoordinatesEnum platitudeSign,int platitude, int plongitude,unsigned int puncertaintyCode)
{
      geographicalCoordinates = new GeographicalCoordinates(platitudeSign, platitude, plongitude);
      uncertaintyCode = puncertaintyCode;
}


//End of this was not generated by compiler
//-------------------------------------------------------------------------------------------------------------------------------------------

GA_PointWithUnCertainty::GA_PointWithUnCertainty (const GA_PointWithUnCertainty &)
{
  Asn1Error << "use of incompletely defined GA_PointWithUnCertainty::GA_PointWithUnCertainty (const GA_PointWithUnCertainty &)" << std::endl;
  abort();
}

GA_PointWithUnCertainty::~GA_PointWithUnCertainty()
{
  delete geographicalCoordinates;
}

AsnType *GA_PointWithUnCertainty::Clone() const
{
  return new GA_PointWithUnCertainty;
}

#if SNACC_DEEP_COPY
GA_PointWithUnCertainty &GA_PointWithUnCertainty::operator = (const GA_PointWithUnCertainty &that)
#else // SNACC_DEEP_COPY
GA_PointWithUnCertainty &GA_PointWithUnCertainty::operator = (const GA_PointWithUnCertainty &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    if (that.geographicalCoordinates)
    {
      if (!geographicalCoordinates)
        geographicalCoordinates = new GeographicalCoordinates;
      *geographicalCoordinates = *that.geographicalCoordinates;
    }
    else
    {
      delete geographicalCoordinates;
      geographicalCoordinates = NULL;
    }
    uncertaintyCode = that.uncertaintyCode;
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined GA_PointWithUnCertainty &GA_PointWithUnCertainty::operator = (const GA_PointWithUnCertainty &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
GA_PointWithUnCertainty::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

    l = uncertaintyCode.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

      BEncEocIfNec (b);
    l = geographicalCoordinates->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;

  return totalLen;
} // GA_PointWithUnCertainty::BEncContent


void GA_PointWithUnCertainty::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    geographicalCoordinates = new GeographicalCoordinates;
    geographicalCoordinates->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << std::endl;
    longjmp (env, -165);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    uncertaintyCode.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << std::endl;
    longjmp (env, -166);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << std::endl;
    longjmp (env, -167);
  }
  else
    return;
} // GA_PointWithUnCertainty::BDecContent

AsnLen GA_PointWithUnCertainty::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void GA_PointWithUnCertainty::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "GA_PointWithUnCertainty::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -168);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int GA_PointWithUnCertainty::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int GA_PointWithUnCertainty::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void GA_PointWithUnCertainty::Print (std::ostream &os) const
{
  os << "{ -- SEQUENCE --" << std::endl;
  indentG += stdIndentG;

  if (NOT_NULL (geographicalCoordinates))
  {
    Indent (os, indentG);
    os << "geographicalCoordinates ";
    os << *geographicalCoordinates;
  }
  else
  {
    Indent (os, indentG);
    os << "geographicalCoordinates ";
    os << "-- void --";
    os << "," << std::endl;
  }

  {
    Indent (os, indentG);
    os << "uncertaintyCode ";
    os << uncertaintyCode;
  }

  os << std::endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // GA_PointWithUnCertainty::Print


Services_Information::Services_Information()
{
  iSUP_parameters = NULL;
  dSS1_parameters_codeset_0 = NULL;
  mAP_parameters = NULL;
}

Services_Information::Services_Information (const Services_Information &)
{
  Asn1Error << "use of incompletely defined Services_Information::Services_Information (const Services_Information &)" << std::endl;
  abort();
}

Services_Information::~Services_Information()
{
  delete iSUP_parameters;
  delete dSS1_parameters_codeset_0;
  delete mAP_parameters;
}

AsnType *Services_Information::Clone() const
{
  return new Services_Information;
}

#if SNACC_DEEP_COPY
Services_Information &Services_Information::operator = (const Services_Information &that)
#else // SNACC_DEEP_COPY
Services_Information &Services_Information::operator = (const Services_Information &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    if (that.iSUP_parameters)
    {
      if (!iSUP_parameters)
        iSUP_parameters = new ISUP_parameters;
      *iSUP_parameters = *that.iSUP_parameters;
    }
    else
    {
      delete iSUP_parameters;
      iSUP_parameters = NULL;
    }
    if (that.dSS1_parameters_codeset_0)
    {
      if (!dSS1_parameters_codeset_0)
        dSS1_parameters_codeset_0 = new DSS1_parameters_codeset_0;
      *dSS1_parameters_codeset_0 = *that.dSS1_parameters_codeset_0;
    }
    else
    {
      delete dSS1_parameters_codeset_0;
      dSS1_parameters_codeset_0 = NULL;
    }
    if (that.mAP_parameters)
    {
      if (!mAP_parameters)
        mAP_parameters = new MAP_parameters;
      *mAP_parameters = *that.mAP_parameters;
    }
    else
    {
      delete mAP_parameters;
      mAP_parameters = NULL;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined Services_Information &Services_Information::operator = (const Services_Information &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
Services_Information::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

  if (NOT_NULL (mAP_parameters))
  {
      BEncEocIfNec (b);
    l = mAP_parameters->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 3);
    totalLen += l;
  }

  if (NOT_NULL (dSS1_parameters_codeset_0))
  {
      BEncEocIfNec (b);
    l = dSS1_parameters_codeset_0->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 2);
    totalLen += l;
  }

  if (NOT_NULL (iSUP_parameters))
  {
      BEncEocIfNec (b);
    l = iSUP_parameters->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 1);
    totalLen += l;
  }

  return totalLen;
} // Services_Information::BEncContent


void Services_Information::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  if (elmtLen0 == 0)
    return;
  else
  {
    tag1 = BDecTag (b, seqBytesDecoded, env);

    if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
    {
      BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
      bytesDecoded += seqBytesDecoded;
      return;
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    iSUP_parameters = new ISUP_parameters;
    iSUP_parameters->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    dSS1_parameters_codeset_0 = new DSS1_parameters_codeset_0;
    dSS1_parameters_codeset_0->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 3)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    mAP_parameters = new MAP_parameters;
    mAP_parameters->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << std::endl;
    longjmp (env, -169);
  }
  else
    return;
} // Services_Information::BDecContent

AsnLen Services_Information::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void Services_Information::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "Services_Information::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -170);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int Services_Information::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int Services_Information::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void Services_Information::Print (std::ostream &os) const
{
  int nonePrinted = true;
  os << "{ -- SEQUENCE --" << std::endl;
  indentG += stdIndentG;

  if (NOT_NULL (iSUP_parameters))
  {
    nonePrinted = false;
    Indent (os, indentG);
    os << "iSUP-parameters ";
    os << *iSUP_parameters;
  }
  else
  {
    Indent (os, indentG);
    os << "iSUP-parameters ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (dSS1_parameters_codeset_0))
  {
    if (!nonePrinted)
      os << "," << std::endl;
    nonePrinted = false;
    Indent (os, indentG);
    os << "dSS1-parameters-codeset-0 ";
    os << *dSS1_parameters_codeset_0;
  }
  else
  {
    Indent (os, indentG);
    os << "dSS1-parameters-codeset-0 ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (mAP_parameters))
  {
    if (!nonePrinted)
      os << "," << std::endl;
    nonePrinted = false;
    Indent (os, indentG);
    os << "mAP-parameters ";
    os << *mAP_parameters;
  }
  else
  {
    Indent (os, indentG);
    os << "mAP-parameters ";
    os << "-- void --";
    os << std::endl;
  }

  os << std::endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // Services_Information::Print


Standard_Supplementary_Services::Standard_Supplementary_Services()
{
  iSUP_SS_parameters = NULL;
  dSS1_SS_parameters_codeset_0 = NULL;
  dSS1_SS_parameters_codeset_4 = NULL;
  dSS1_SS_parameters_codeset_5 = NULL;
  dSS1_SS_parameters_codeset_6 = NULL;
  dSS1_SS_parameters_codeset_7 = NULL;
  dSS1_SS_Invoke_components = NULL;
  mAP_SS_Parameters = NULL;
  mAP_SS_Invoke_Components = NULL;
}

Standard_Supplementary_Services::Standard_Supplementary_Services (const Standard_Supplementary_Services &)
{
  Asn1Error << "use of incompletely defined Standard_Supplementary_Services::Standard_Supplementary_Services (const Standard_Supplementary_Services &)" << std::endl;
  abort();
}

Standard_Supplementary_Services::~Standard_Supplementary_Services()
{
  delete iSUP_SS_parameters;
  delete dSS1_SS_parameters_codeset_0;
  delete dSS1_SS_parameters_codeset_4;
  delete dSS1_SS_parameters_codeset_5;
  delete dSS1_SS_parameters_codeset_6;
  delete dSS1_SS_parameters_codeset_7;
  delete dSS1_SS_Invoke_components;
  delete mAP_SS_Parameters;
  delete mAP_SS_Invoke_Components;
}

AsnType *Standard_Supplementary_Services::Clone() const
{
  return new Standard_Supplementary_Services;
}

#if SNACC_DEEP_COPY
Standard_Supplementary_Services &Standard_Supplementary_Services::operator = (const Standard_Supplementary_Services &that)
#else // SNACC_DEEP_COPY
Standard_Supplementary_Services &Standard_Supplementary_Services::operator = (const Standard_Supplementary_Services &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    if (that.iSUP_SS_parameters)
    {
      if (!iSUP_SS_parameters)
        iSUP_SS_parameters = new ISUP_SS_parameters;
      *iSUP_SS_parameters = *that.iSUP_SS_parameters;
    }
    else
    {
      delete iSUP_SS_parameters;
      iSUP_SS_parameters = NULL;
    }
    if (that.dSS1_SS_parameters_codeset_0)
    {
      if (!dSS1_SS_parameters_codeset_0)
        dSS1_SS_parameters_codeset_0 = new DSS1_SS_parameters_codeset_0;
      *dSS1_SS_parameters_codeset_0 = *that.dSS1_SS_parameters_codeset_0;
    }
    else
    {
      delete dSS1_SS_parameters_codeset_0;
      dSS1_SS_parameters_codeset_0 = NULL;
    }
    if (that.dSS1_SS_parameters_codeset_4)
    {
      if (!dSS1_SS_parameters_codeset_4)
        dSS1_SS_parameters_codeset_4 = new DSS1_SS_parameters_codeset_4;
      *dSS1_SS_parameters_codeset_4 = *that.dSS1_SS_parameters_codeset_4;
    }
    else
    {
      delete dSS1_SS_parameters_codeset_4;
      dSS1_SS_parameters_codeset_4 = NULL;
    }
    if (that.dSS1_SS_parameters_codeset_5)
    {
      if (!dSS1_SS_parameters_codeset_5)
        dSS1_SS_parameters_codeset_5 = new DSS1_SS_parameters_codeset_5;
      *dSS1_SS_parameters_codeset_5 = *that.dSS1_SS_parameters_codeset_5;
    }
    else
    {
      delete dSS1_SS_parameters_codeset_5;
      dSS1_SS_parameters_codeset_5 = NULL;
    }
    if (that.dSS1_SS_parameters_codeset_6)
    {
      if (!dSS1_SS_parameters_codeset_6)
        dSS1_SS_parameters_codeset_6 = new DSS1_SS_parameters_codeset_6;
      *dSS1_SS_parameters_codeset_6 = *that.dSS1_SS_parameters_codeset_6;
    }
    else
    {
      delete dSS1_SS_parameters_codeset_6;
      dSS1_SS_parameters_codeset_6 = NULL;
    }
    if (that.dSS1_SS_parameters_codeset_7)
    {
      if (!dSS1_SS_parameters_codeset_7)
        dSS1_SS_parameters_codeset_7 = new DSS1_SS_parameters_codeset_7;
      *dSS1_SS_parameters_codeset_7 = *that.dSS1_SS_parameters_codeset_7;
    }
    else
    {
      delete dSS1_SS_parameters_codeset_7;
      dSS1_SS_parameters_codeset_7 = NULL;
    }
    if (that.dSS1_SS_Invoke_components)
    {
      if (!dSS1_SS_Invoke_components)
        dSS1_SS_Invoke_components = new DSS1_SS_Invoke_Components;
      *dSS1_SS_Invoke_components = *that.dSS1_SS_Invoke_components;
    }
    else
    {
      delete dSS1_SS_Invoke_components;
      dSS1_SS_Invoke_components = NULL;
    }
    if (that.mAP_SS_Parameters)
    {
      if (!mAP_SS_Parameters)
        mAP_SS_Parameters = new MAP_SS_Parameters;
      *mAP_SS_Parameters = *that.mAP_SS_Parameters;
    }
    else
    {
      delete mAP_SS_Parameters;
      mAP_SS_Parameters = NULL;
    }
    if (that.mAP_SS_Invoke_Components)
    {
      if (!mAP_SS_Invoke_Components)
        mAP_SS_Invoke_Components = new MAP_SS_Invoke_Components;
      *mAP_SS_Invoke_Components = *that.mAP_SS_Invoke_Components;
    }
    else
    {
      delete mAP_SS_Invoke_Components;
      mAP_SS_Invoke_Components = NULL;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined Standard_Supplementary_Services &Standard_Supplementary_Services::operator = (const Standard_Supplementary_Services &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
Standard_Supplementary_Services::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

  if (NOT_NULL (mAP_SS_Invoke_Components))
  {
      BEncEocIfNec (b);
    l = mAP_SS_Invoke_Components->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 9);
    totalLen += l;
  }

  if (NOT_NULL (mAP_SS_Parameters))
  {
      BEncEocIfNec (b);
    l = mAP_SS_Parameters->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 8);
    totalLen += l;
  }

  if (NOT_NULL (dSS1_SS_Invoke_components))
  {
      BEncEocIfNec (b);
    l = dSS1_SS_Invoke_components->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 7);
    totalLen += l;
  }

  if (NOT_NULL (dSS1_SS_parameters_codeset_7))
  {
      BEncEocIfNec (b);
    l = dSS1_SS_parameters_codeset_7->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 6);
    totalLen += l;
  }

  if (NOT_NULL (dSS1_SS_parameters_codeset_6))
  {
      BEncEocIfNec (b);
    l = dSS1_SS_parameters_codeset_6->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 5);
    totalLen += l;
  }

  if (NOT_NULL (dSS1_SS_parameters_codeset_5))
  {
      BEncEocIfNec (b);
    l = dSS1_SS_parameters_codeset_5->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 4);
    totalLen += l;
  }

  if (NOT_NULL (dSS1_SS_parameters_codeset_4))
  {
      BEncEocIfNec (b);
    l = dSS1_SS_parameters_codeset_4->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 3);
    totalLen += l;
  }

  if (NOT_NULL (dSS1_SS_parameters_codeset_0))
  {
      BEncEocIfNec (b);
    l = dSS1_SS_parameters_codeset_0->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 2);
    totalLen += l;
  }

  if (NOT_NULL (iSUP_SS_parameters))
  {
      BEncEocIfNec (b);
    l = iSUP_SS_parameters->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 1);
    totalLen += l;
  }

  return totalLen;
} // Standard_Supplementary_Services::BEncContent


void Standard_Supplementary_Services::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  if (elmtLen0 == 0)
    return;
  else
  {
    tag1 = BDecTag (b, seqBytesDecoded, env);

    if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
    {
      BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
      bytesDecoded += seqBytesDecoded;
      return;
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    iSUP_SS_parameters = new ISUP_SS_parameters;
    iSUP_SS_parameters->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    dSS1_SS_parameters_codeset_0 = new DSS1_SS_parameters_codeset_0;
    dSS1_SS_parameters_codeset_0->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 3)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    dSS1_SS_parameters_codeset_4 = new DSS1_SS_parameters_codeset_4;
    dSS1_SS_parameters_codeset_4->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 4)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    dSS1_SS_parameters_codeset_5 = new DSS1_SS_parameters_codeset_5;
    dSS1_SS_parameters_codeset_5->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 5)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    dSS1_SS_parameters_codeset_6 = new DSS1_SS_parameters_codeset_6;
    dSS1_SS_parameters_codeset_6->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 6)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    dSS1_SS_parameters_codeset_7 = new DSS1_SS_parameters_codeset_7;
    dSS1_SS_parameters_codeset_7->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 7)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    dSS1_SS_Invoke_components = new DSS1_SS_Invoke_Components;
    dSS1_SS_Invoke_components->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 8)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    mAP_SS_Parameters = new MAP_SS_Parameters;
    mAP_SS_Parameters->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 9)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    mAP_SS_Invoke_Components = new MAP_SS_Invoke_Components;
    mAP_SS_Invoke_Components->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << std::endl;
    longjmp (env, -171);
  }
  else
    return;
} // Standard_Supplementary_Services::BDecContent

AsnLen Standard_Supplementary_Services::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void Standard_Supplementary_Services::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "Standard_Supplementary_Services::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -172);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int Standard_Supplementary_Services::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int Standard_Supplementary_Services::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void Standard_Supplementary_Services::Print (std::ostream &os) const
{
  int nonePrinted = true;
  os << "{ -- SEQUENCE --" << std::endl;
  indentG += stdIndentG;

  if (NOT_NULL (iSUP_SS_parameters))
  {
    nonePrinted = false;
    Indent (os, indentG);
    os << "iSUP-SS-parameters ";
    os << *iSUP_SS_parameters;
  }
  else
  {
    Indent (os, indentG);
    os << "iSUP-SS-parameters ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (dSS1_SS_parameters_codeset_0))
  {
    if (!nonePrinted)
      os << "," << std::endl;
    nonePrinted = false;
    Indent (os, indentG);
    os << "dSS1-SS-parameters-codeset-0 ";
    os << *dSS1_SS_parameters_codeset_0;
  }
  else
  {
    Indent (os, indentG);
    os << "dSS1-SS-parameters-codeset-0 ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (dSS1_SS_parameters_codeset_4))
  {
    if (!nonePrinted)
      os << "," << std::endl;
    nonePrinted = false;
    Indent (os, indentG);
    os << "dSS1-SS-parameters-codeset-4 ";
    os << *dSS1_SS_parameters_codeset_4;
  }
  else
  {
    Indent (os, indentG);
    os << "dSS1-SS-parameters-codeset-4 ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (dSS1_SS_parameters_codeset_5))
  {
    if (!nonePrinted)
      os << "," << std::endl;
    nonePrinted = false;
    Indent (os, indentG);
    os << "dSS1-SS-parameters-codeset-5 ";
    os << *dSS1_SS_parameters_codeset_5;
  }
  else
  {
    Indent (os, indentG);
    os << "dSS1-SS-parameters-codeset-5 ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (dSS1_SS_parameters_codeset_6))
  {
    if (!nonePrinted)
      os << "," << std::endl;
    nonePrinted = false;
    Indent (os, indentG);
    os << "dSS1-SS-parameters-codeset-6 ";
    os << *dSS1_SS_parameters_codeset_6;
  }
  else
  {
    Indent (os, indentG);
    os << "dSS1-SS-parameters-codeset-6 ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (dSS1_SS_parameters_codeset_7))
  {
    if (!nonePrinted)
      os << "," << std::endl;
    nonePrinted = false;
    Indent (os, indentG);
    os << "dSS1-SS-parameters-codeset-7 ";
    os << *dSS1_SS_parameters_codeset_7;
  }
  else
  {
    Indent (os, indentG);
    os << "dSS1-SS-parameters-codeset-7 ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (dSS1_SS_Invoke_components))
  {
    if (!nonePrinted)
      os << "," << std::endl;
    nonePrinted = false;
    Indent (os, indentG);
    os << "dSS1-SS-Invoke-components ";
    os << *dSS1_SS_Invoke_components;
  }
  else
  {
    Indent (os, indentG);
    os << "dSS1-SS-Invoke-components ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (mAP_SS_Parameters))
  {
    if (!nonePrinted)
      os << "," << std::endl;
    nonePrinted = false;
    Indent (os, indentG);
    os << "mAP-SS-Parameters ";
    os << *mAP_SS_Parameters;
  }
  else
  {
    Indent (os, indentG);
    os << "mAP-SS-Parameters ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (mAP_SS_Invoke_Components))
  {
    if (!nonePrinted)
      os << "," << std::endl;
    nonePrinted = false;
    Indent (os, indentG);
    os << "mAP-SS-Invoke-Components ";
    os << *mAP_SS_Invoke_Components;
  }
  else
  {
    Indent (os, indentG);
    os << "mAP-SS-Invoke-Components ";
    os << "-- void --";
    os << std::endl;
  }

  os << std::endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // Standard_Supplementary_Services::Print


AsnType *Non_Standard_Supplementary_Services::Clone() const
{
  return new Non_Standard_Supplementary_Services;
}

AsnLen Non_Standard_Supplementary_Services::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SET_TAG_CODE);
  return l;
}

void Non_Standard_Supplementary_Services::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SET_TAG_CODE))
  {
    Asn1Error << "Non_Standard_Supplementary_Services::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -173);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

Non_Standard_Supplementary_Services::Non_Standard_Supplementary_Services (const Non_Standard_Supplementary_Services &)
{
  Asn1Error << "use of incompletely defined Non_Standard_Supplementary_Services::Non_Standard_Supplementary_Services (const Non_Standard_Supplementary_Services &)" << std::endl;
  abort();
}

Non_Standard_Supplementary_Services::~Non_Standard_Supplementary_Services()
{
  SetCurrToFirst();
  for (; Curr() != NULL; RemoveCurrFromList())
    ;
} // end of destructor

#if SNACC_DEEP_COPY
Non_Standard_Supplementary_Services &Non_Standard_Supplementary_Services::operator = (const Non_Standard_Supplementary_Services &that)
#else // SNACC_DEEP_COPY
Non_Standard_Supplementary_Services &Non_Standard_Supplementary_Services::operator = (const Non_Standard_Supplementary_Services &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    SetCurrToFirst();
    for (; Curr(); RemoveCurrFromList())
      ;

    //that.SetCurrToFirst();
    //for (; that.Curr(); that.GoNext())
    //  AppendCopy (*that.Curr());
    for (const AsnListElmt *run=that.first; run; run=run->next)
      AppendCopy (*run->elmt);
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined Non_Standard_Supplementary_Services &Non_Standard_Supplementary_Services::operator = (const Non_Standard_Supplementary_Services &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

void Non_Standard_Supplementary_Services::Print (std::ostream &os) const
{
    os << "{ -- SEQUENCE/SET OF -- " << std::endl;
    indentG += stdIndentG;
    //SetCurrToFirst();
    //for (; Curr() != NULL; GoNext())
    for (const AsnListElmt *run=first; run; run=run->next)
    {
        Indent (os, indentG);
        //os << *Curr();
        os << *run->elmt;
        //if (Curr() != Last())
        if (run != last)
            os << ",";
        os << std::endl;
    }
    indentG -= stdIndentG;
    Indent (os, indentG);
    os << "}\n";
} // Print


void  Non_Standard_Supplementary_Services::SetCurrElmt (unsigned long int index)
{
  unsigned long int i;
  curr = first;
  if (count)
    for (i = 0; (i < (count-1)) && (i < index); i++)
      curr = curr->next;
} // Non_Standard_Supplementary_Services::SetCurrElmt


unsigned long int  Non_Standard_Supplementary_Services::GetCurrElmtIndex()
{
    unsigned long int i;
    AsnListElmt *tmp;
    if (curr != NULL)
    {
        for (i = 0, tmp = first; tmp != NULL; i++)
        {
            if (tmp == curr)
                return i;
            else
                tmp = tmp->next;
        }
    }
    return count;
} // Non_Standard_Supplementary_Services::GetCurrElmtIndex


// alloc new list elmt, put at end of list
//  and return the component type
Non_Standard_Supplementary_ServicesChoice *Non_Standard_Supplementary_Services::Append()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt  = new Non_Standard_Supplementary_ServicesChoice;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // Non_Standard_Supplementary_Services::Append

//------------------------------------------------------------------------------------------------------------------------------
//Begin of This was no created by snacc
Non_Standard_Supplementary_ServicesChoice* Non_Standard_Supplementary_Services::Append(const char *sciData )
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt  = new Non_Standard_Supplementary_ServicesChoice(sciData);
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
}
Non_Standard_Supplementary_ServicesChoice* Non_Standard_Supplementary_Services::Append(SimpleIndication psimpleIndication )
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt  = new Non_Standard_Supplementary_ServicesChoice(psimpleIndication);
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
}
//End of This was no created by snacc
//------------------------------------------------------------------------------------------------------------------------------

// alloc new list elmt, put at begining of list
//  and return the component type
Non_Standard_Supplementary_ServicesChoice  *Non_Standard_Supplementary_Services::Prepend()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new Non_Standard_Supplementary_ServicesChoice;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // Non_Standard_Supplementary_Services::Prepend


// alloc new list elmt, insert it before the
// current element and return the component type
// if the current element is null, the new element
// is placed at the beginning of the list.
Non_Standard_Supplementary_ServicesChoice  *Non_Standard_Supplementary_Services::InsertBefore()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new Non_Standard_Supplementary_ServicesChoice;
    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // Non_Standard_Supplementary_Services::InsertBefore


// alloc new list elmt, insert it after the
// current element and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
Non_Standard_Supplementary_ServicesChoice *Non_Standard_Supplementary_Services::InsertAfter()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new Non_Standard_Supplementary_ServicesChoice;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // Non_Standard_Supplementary_Services::InsertAfter


Non_Standard_Supplementary_Services  &Non_Standard_Supplementary_Services::AppendCopy (Non_Standard_Supplementary_ServicesChoice &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new Non_Standard_Supplementary_ServicesChoice;
    *newElmt->elmt = elmt;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return *this;
} // AppendCopy


Non_Standard_Supplementary_Services  &Non_Standard_Supplementary_Services::PrependCopy (Non_Standard_Supplementary_ServicesChoice &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new Non_Standard_Supplementary_ServicesChoice;
    *newElmt->elmt = elmt;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return *this;
} // Non_Standard_Supplementary_Services::PrependCopy


// alloc new list elmt, insert it before the
// current element, copy the given elmt into the new elmt
// and return the component type.
// if the current element is null, the new element
// is placed at the beginning of the list.
Non_Standard_Supplementary_Services &Non_Standard_Supplementary_Services::InsertBeforeAndCopy (Non_Standard_Supplementary_ServicesChoice &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new Non_Standard_Supplementary_ServicesChoice;
    *newElmt->elmt = elmt;

    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return *this;
} // Non_Standard_Supplementary_Services::InsertBeforeAndCopy


// alloc new list elmt, insert it after the
// current element, copy given elmt in to new elmt
//  and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
Non_Standard_Supplementary_Services  &Non_Standard_Supplementary_Services::InsertAfterAndCopy (Non_Standard_Supplementary_ServicesChoice &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new Non_Standard_Supplementary_ServicesChoice;
    *newElmt->elmt = elmt;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return *this;
} // Non_Standard_Supplementary_Services::InsertAfterAndCopy


// remove current element from list if current element is not NULL
// The new current element will be the next element.
// If the current element is the last element in the list
// the second but last element will become the new current element.
void Non_Standard_Supplementary_Services::RemoveCurrFromList()
{
    AsnListElmt *del_elmt;

    if (curr != NULL)
    {
        del_elmt = curr;
        count--;

        if (count == 0)
            first = last = curr = NULL;
        else if (curr == first)
        {
            curr = first= first->next;
            first->prev = NULL;
        }
        else if (curr == last)
        {
            curr = last = last->prev;
            last->next = NULL;
        }
        else
        {
            curr->prev->next = curr->next;
            curr->next->prev = curr->prev;
        }

        delete del_elmt->elmt;
        delete del_elmt;
    }
}


AsnLen Non_Standard_Supplementary_Services::BEncContent (BUF_TYPE b)
{
    AsnListElmt *currElmt;
    AsnLen elmtLen;
    AsnLen totalLen = 0;
    for (currElmt = last; currElmt != NULL; currElmt = currElmt->prev)
    {
        elmtLen = currElmt->elmt->BEncContent (b);
        totalLen += elmtLen;
    }
    return totalLen;
} // Non_Standard_Supplementary_Services::BEncContent


void  Non_Standard_Supplementary_Services::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0,
                                  AsnLen &bytesDecoded, ENV_TYPE env)
{
    Non_Standard_Supplementary_ServicesChoice *listElmt;
    AsnTag tag1;
    AsnLen listBytesDecoded = 0;
    AsnLen elmtLen1;

    while ((listBytesDecoded < elmtLen0) || (elmtLen0 == INDEFINITE_LEN))
    {
        tag1 = BDecTag (b, listBytesDecoded, env);
        if ((tag1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
        {
            BDEC_2ND_EOC_OCTET (b, listBytesDecoded, env);
            break;
        }
        if (!((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1))
         || (tag1 == MAKE_TAG_ID (CNTX, PRIM, 2))
            || (tag1 == MAKE_TAG_ID (CNTX, CONS, 2))
))
        {
            Asn1Error << "Unexpected Tag" << std::endl;
            longjmp (env, -174);
        }

        elmtLen1 = BDecLen (b, listBytesDecoded, env);
        listElmt = Append();
        listElmt->BDecContent (b, tag1, elmtLen1, listBytesDecoded, env);
    }

    bytesDecoded += listBytesDecoded;
} // Non_Standard_Supplementary_Services::BDecContent


IPAddress::IPAddress()
{
//#if TCL
  iP_value = new IP_value;
/*#else
  iP_value = NULL; // incomplete initialization of mandatory element!
#endif // TCL
*/
  iP_assignment = NULL;
}

IPAddress::IPAddress (const IPAddress &)
{
  Asn1Error << "use of incompletely defined IPAddress::IPAddress (const IPAddress &)" << std::endl;
  abort();
}

//----------------------------------------------------------------------------------------------------------------------------
//Begin This is not implement by the snacc
// IPAddressEnum enum {iPV4,iPV6};

IPAddress::IPAddress( IPAddressEnum ip_type, IP_value::ChoiceIdEnum choiceIpType, const char *str )
{
    iP_type=ip_type;
    iP_value = new IP_value(choiceIpType, str);
    iP_assignment = NULL;
}

// IPAddressEnum1 enum{ static1, dynamic, notKnown };
IPAddress::IPAddress( IPAddressEnum ip_type, IP_value::ChoiceIdEnum choiceIpType, const char *str, IPAddressEnum1 choiceIpAssignment )
{
    iP_type=ip_type;
    iP_value = new IP_value(choiceIpType, str);
    iP_assignment = new IPAddressEnum1(choiceIpAssignment);
}

//End of This is not implement by the snacc
//----------------------------------------------------------------------------------------------------------------------------

IPAddress::~IPAddress()
{
  delete iP_value;
  delete iP_assignment;
}

AsnType *IPAddress::Clone() const
{
  return new IPAddress;
}

#if SNACC_DEEP_COPY
IPAddress &IPAddress::operator = (const IPAddress &that)
#else // SNACC_DEEP_COPY
IPAddress &IPAddress::operator = (const IPAddress &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    iP_type = that.iP_type;
    if (that.iP_value)
    {
      if (!iP_value)
        iP_value = new IP_value;
      *iP_value = *that.iP_value;
    }
    else
    {
      delete iP_value;
      iP_value = NULL;
    }
    if (that.iP_assignment)
    {
      if (!iP_assignment)
        iP_assignment = new IPAddressEnum1;
      *iP_assignment = *that.iP_assignment;
    }
    else
    {
      delete iP_assignment;
      iP_assignment = NULL;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined IPAddress &IPAddress::operator = (const IPAddress &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
IPAddress::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

  if (NOT_NULL (iP_assignment))
  {
    l = iP_assignment->BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, CNTX, PRIM, 3);
    totalLen += l;
  }

      BEncEocIfNec (b);
    l = iP_value->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 2);
    totalLen += l;

    l = iP_type.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, CNTX, PRIM, 1);
    totalLen += l;

  return totalLen;
} // IPAddress::BEncContent


void IPAddress::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  AsnLen elmtLen2;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    iP_type.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << std::endl;
    longjmp (env, -175);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
    elmtLen2 = BDecLen (b, seqBytesDecoded, env);
    iP_value = new IP_value;
    iP_value->BDecContent (b, tag1, elmtLen2, seqBytesDecoded, env);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (b, seqBytesDecoded, env);

    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << std::endl;
    longjmp (env, -176);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    iP_assignment = new IPAddressEnum1;
    iP_assignment->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << std::endl;
    longjmp (env, -177);
  }
  else
    return;
} // IPAddress::BDecContent

AsnLen IPAddress::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void IPAddress::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "IPAddress::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -178);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int IPAddress::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int IPAddress::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void IPAddress::Print (std::ostream &os) const
{
  os << "{ -- SEQUENCE --" << std::endl;
  indentG += stdIndentG;

  {
    Indent (os, indentG);
    os << "iP-type ";
    os << iP_type;
    os << "," << std::endl;
  }

  if (NOT_NULL (iP_value))
  {
    Indent (os, indentG);
    os << "iP-value ";
    os << *iP_value;
  }
  else
  {
    Indent (os, indentG);
    os << "iP-value ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (iP_assignment))
  {
    os << ","<< std::endl;
    Indent (os, indentG);
    os << "iP-assignment ";
    os << *iP_assignment;
  }
  else
  {
    Indent (os, indentG);
    os << "iP-assignment ";
    os << "-- void --";
    os << std::endl;
  }

  os << std::endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // IPAddress::Print


GA_PolygonSeq::GA_PolygonSeq()
{
#if TCL
  geographicalCoordinates = new GeographicalCoordinates;
#else
  geographicalCoordinates = NULL; // incomplete initialization of mandatory element!
#endif // TCL
}

//--------------------------------------------------------------------------------------------
//Begin of this was not generated by compiler
GA_PolygonSeq::GA_PolygonSeq(GeographicalCoordinatesEnum platitudeSign,int platitude, int plongitude)
{
    geographicalCoordinates = new GeographicalCoordinates(platitudeSign, platitude, plongitude);
}

//End of this was not generated by compiler
//--------------------------------------------------------------------------------------------

GA_PolygonSeq::GA_PolygonSeq (const GA_PolygonSeq &)
{
  Asn1Error << "use of incompletely defined GA_PolygonSeq::GA_PolygonSeq (const GA_PolygonSeq &)" << std::endl;
  abort();
}

GA_PolygonSeq::~GA_PolygonSeq()
{
  delete geographicalCoordinates;
}

AsnType *GA_PolygonSeq::Clone() const
{
  return new GA_PolygonSeq;
}

#if SNACC_DEEP_COPY
GA_PolygonSeq &GA_PolygonSeq::operator = (const GA_PolygonSeq &that)
#else // SNACC_DEEP_COPY
GA_PolygonSeq &GA_PolygonSeq::operator = (const GA_PolygonSeq &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    if (that.geographicalCoordinates)
    {
      if (!geographicalCoordinates)
        geographicalCoordinates = new GeographicalCoordinates;
      *geographicalCoordinates = *that.geographicalCoordinates;
    }
    else
    {
      delete geographicalCoordinates;
      geographicalCoordinates = NULL;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined GA_PolygonSeq &GA_PolygonSeq::operator = (const GA_PolygonSeq &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
GA_PolygonSeq::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

      BEncEocIfNec (b);
    l = geographicalCoordinates->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;

  return totalLen;
} // GA_PolygonSeq::BEncContent


void GA_PolygonSeq::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    geographicalCoordinates = new GeographicalCoordinates;
    geographicalCoordinates->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << std::endl;
    longjmp (env, -179);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << std::endl;
    longjmp (env, -180);
  }
  else
    return;
} // GA_PolygonSeq::BDecContent

AsnLen GA_PolygonSeq::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void GA_PolygonSeq::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "GA_PolygonSeq::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -181);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int GA_PolygonSeq::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int GA_PolygonSeq::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void GA_PolygonSeq::Print (std::ostream &os) const
{
  os << "{ -- SEQUENCE --" << std::endl;
  indentG += stdIndentG;

  if (NOT_NULL (geographicalCoordinates))
  {
    Indent (os, indentG);
    os << "geographicalCoordinates ";
    os << *geographicalCoordinates;
  }
  else
  {
    Indent (os, indentG);
    os << "geographicalCoordinates ";
    os << "-- void --";
    os << std::endl;
  }

  os << std::endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // GA_PolygonSeq::Print


Network_Element_Identifier::Network_Element_Identifier()
{
  choiceId = e164_FormatCid;
//#if TCL
  e164_Format = new AsnOcts;
/*
#else
  e164_Format = NULL; // incomplete initialization of mandatory element!
#endif // TCL
*/
}

//---------------------------------------------------------------------------------------------------------------
// Begin This is not implement by the snacc
// enum ChoiceIdEnum{e164_FormatCid, x25_FormatCid, iP_FormatCid, dNS_FormatCid, iP_AddressCid};
Network_Element_Identifier::Network_Element_Identifier(ChoiceIdEnum pchoiceId, const char *str)
{
    choiceId =pchoiceId;
    switch( choiceId )
    {
        case e164_FormatCid:
                e164_Format = new AsnOcts;
                e164_Format->Set(str);
                break;
        case x25_FormatCid:
                x25_Format = new AsnOcts;
                x25_Format->Set(str);
                break;
        case iP_FormatCid:
                iP_Format = new AsnOcts;
                iP_Format->Set(str);
                break;
        case dNS_FormatCid:
                dNS_Format = new AsnOcts;
                dNS_Format->Set(str);
                break;
    }
}

Network_Element_Identifier::Network_Element_Identifier(ChoiceIdEnum pchoiceId, IPAddressEnum ip_type,IP_value::ChoiceIdEnum choiceIpTypeValue, const char *str )
{
    choiceId =pchoiceId;
    iP_Address = new IPAddress(ip_type, choiceIpTypeValue, str);
}
Network_Element_Identifier::Network_Element_Identifier(ChoiceIdEnum pchoiceId, IPAddressEnum ip_type,IP_value::ChoiceIdEnum choiceIpTypeValue, const char *str, IPAddressEnum1 choiceIpAssignment )
{
    choiceId =pchoiceId;
    iP_Address = new IPAddress(ip_type, choiceIpTypeValue, str, choiceIpAssignment);
}




//End of This is not implement by the snacc
//---------------------------------------------------------------------------------------------------------------


Network_Element_Identifier::Network_Element_Identifier (const Network_Element_Identifier &)
{
  Asn1Error << "use of incompletely defined Network_Element_Identifier::Network_Element_Identifier (const Network_Element_Identifier &)" << std::endl;
  abort();
}

Network_Element_Identifier::~Network_Element_Identifier()
{
  switch (choiceId)
  {
    case e164_FormatCid:
      delete e164_Format;
      break;
    case x25_FormatCid:
      delete x25_Format;
      break;
    case iP_FormatCid:
      delete iP_Format;
      break;
    case dNS_FormatCid:
      delete dNS_Format;
      break;
    case iP_AddressCid:
      delete iP_Address;
      break;
  } // end of switch
} // end of destructor

AsnType *Network_Element_Identifier::Clone() const
{
  return new Network_Element_Identifier;
}

#if SNACC_DEEP_COPY
Network_Element_Identifier &Network_Element_Identifier::operator = (const Network_Element_Identifier &that)
#else // SNACC_DEEP_COPY
Network_Element_Identifier &Network_Element_Identifier::operator = (const Network_Element_Identifier &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    switch (choiceId)
    {
      case e164_FormatCid:
        delete e164_Format;
        break;
      case x25_FormatCid:
        delete x25_Format;
        break;
      case iP_FormatCid:
        delete iP_Format;
        break;
      case dNS_FormatCid:
        delete dNS_Format;
        break;
      case iP_AddressCid:
        delete iP_Address;
        break;
    }
    switch (choiceId = that.choiceId)
    {
      case e164_FormatCid:
        e164_Format = new AsnOcts;
        *e164_Format = *that.e164_Format;
        break;
      case x25_FormatCid:
        x25_Format = new AsnOcts;
        *x25_Format = *that.x25_Format;
        break;
      case iP_FormatCid:
        iP_Format = new AsnOcts;
        *iP_Format = *that.iP_Format;
        break;
      case dNS_FormatCid:
        dNS_Format = new AsnOcts;
        *dNS_Format = *that.dNS_Format;
        break;
      case iP_AddressCid:
        iP_Address = new IPAddress;
        *iP_Address = *that.iP_Address;
        break;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined Network_Element_Identifier &Network_Element_Identifier::operator = (const Network_Element_Identifier &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
Network_Element_Identifier::BEncContent (BUF_TYPE b)
{
  AsnLen l;
  switch (choiceId)
  {
    case e164_FormatCid:
      l = e164_Format->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 1);
      break;

    case x25_FormatCid:
      l = x25_Format->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 2);
      break;

    case iP_FormatCid:
      l = iP_Format->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 3);
      break;

    case dNS_FormatCid:
      l = dNS_Format->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 4);
      break;

    case iP_AddressCid:
      BEncEocIfNec (b);
      l = iP_Address->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 5);
      break;

  } // end switch
  return l;
} // Network_Element_Identifier::BEncContent


void Network_Element_Identifier::BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  switch (tag)
  {
    case MAKE_TAG_ID (CNTX, PRIM, 1):
    case MAKE_TAG_ID (CNTX, CONS, 1):
      choiceId = e164_FormatCid;
      e164_Format = new AsnOcts;
        e164_Format->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 2):
    case MAKE_TAG_ID (CNTX, CONS, 2):
      choiceId = x25_FormatCid;
      x25_Format = new AsnOcts;
        x25_Format->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 3):
    case MAKE_TAG_ID (CNTX, CONS, 3):
      choiceId = iP_FormatCid;
      iP_Format = new AsnOcts;
        iP_Format->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 4):
    case MAKE_TAG_ID (CNTX, CONS, 4):
      choiceId = dNS_FormatCid;
      dNS_Format = new AsnOcts;
        dNS_Format->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, CONS, 5):
      choiceId = iP_AddressCid;
      iP_Address = new IPAddress;
        iP_Address->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    default:
      Asn1Error << "ERROR - unexpected tag in CHOICE" << std::endl;
      longjmp (env, -182);
      break;
  } // end switch
} // Network_Element_Identifier::BDecContent


AsnLen Network_Element_Identifier::BEnc (BUF_TYPE b)
{
    AsnLen l;
    l = BEncContent (b);
    return l;
}

void Network_Element_Identifier::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
    AsnLen elmtLen;
    AsnTag tag;

    /*  CHOICEs are a special case - grab identifying tag */
    /*  this allows easier handling of nested CHOICEs */
    tag = BDecTag (b, bytesDecoded, env);
    elmtLen = BDecLen (b, bytesDecoded, env);
    BDecContent (b, tag, elmtLen, bytesDecoded, env);
}

int Network_Element_Identifier::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int Network_Element_Identifier::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void Network_Element_Identifier::Print (std::ostream &os) const
{
  switch (choiceId)
  {
    case e164_FormatCid:
      os << "e164-Format ";
      if (e164_Format)
        os << *e164_Format;
      else
        os << "-- void3 --\n";
      break;

    case x25_FormatCid:
      os << "x25-Format ";
      if (x25_Format)
        os << *x25_Format;
      else
        os << "-- void3 --\n";
      break;

    case iP_FormatCid:
      os << "iP-Format ";
      if (iP_Format)
        os << *iP_Format;
      else
        os << "-- void3 --\n";
      break;

    case dNS_FormatCid:
      os << "dNS-Format ";
      if (dNS_Format)
        os << *dNS_Format;
      else
        os << "-- void3 --\n";
      break;

    case iP_AddressCid:
      os << "iP-Address ";
      if (iP_Address)
        os << *iP_Address;
      else
        os << "-- void3 --\n";
      break;

  } // end of switch
} // Network_Element_Identifier::Print

TimeStamp::TimeStamp()
{
  choiceId = localTimeCid;
#if TCL
  localTime = new LocalTimeStamp;
#else
  localTime = NULL; // incomplete initialization of mandatory element!
#endif // TCL
}

//---------------------------------------------------------------------------------------------------------------
//Begin this is not generated by compiler


TimeStamp::TimeStamp(const char *utcTimeStr)
{
    choiceId=utcTimeCid;
    utcTime = new UTCTime;
    utcTime->Set(utcTimeStr);
}

TimeStamp::TimeStamp(const char*generalizedTimeStr,LocalTimeStampEnum  pwinterSummerIndication)
{
    choiceId=localTimeCid;
    localTime = new LocalTimeStamp(generalizedTimeStr, pwinterSummerIndication);
}


void TimeStamp::SetUTCTime(const char *utcTimeStr)
{
    choiceId=utcTimeCid;
    delete utcTime;
    utcTime = new UTCTime;
    utcTime->Set(utcTimeStr);
}
void TimeStamp::SetLocalTimeStamp(const char*generalizedTimeStr,LocalTimeStampEnum  pwinterSummerIndication)
{
    choiceId=localTimeCid;
    delete localTime;
    localTime = new LocalTimeStamp(generalizedTimeStr, pwinterSummerIndication);
}

//End  this is not generated by compiler
//---------------------------------------------------------------------------------------------------------------


TimeStamp::TimeStamp (const TimeStamp &)
{
  Asn1Error << "use of incompletely defined TimeStamp::TimeStamp (const TimeStamp &)" << std::endl;
  abort();
}

TimeStamp::~TimeStamp()
{
  switch (choiceId)
  {
    case localTimeCid:
      delete localTime;
      break;
    case utcTimeCid:
      delete utcTime;
      break;
  } // end of switch
} // end of destructor

AsnType *TimeStamp::Clone() const
{
  return new TimeStamp;
}

#if SNACC_DEEP_COPY
TimeStamp &TimeStamp::operator = (const TimeStamp &that)
#else // SNACC_DEEP_COPY
TimeStamp &TimeStamp::operator = (const TimeStamp &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    switch (choiceId)
    {
      case localTimeCid:
        delete localTime;
        break;
      case utcTimeCid:
        delete utcTime;
        break;
    }
    switch (choiceId = that.choiceId)
    {
      case localTimeCid:
        localTime = new LocalTimeStamp;
        *localTime = *that.localTime;
        break;
      case utcTimeCid:
        utcTime = new UTCTime;
        *utcTime = *that.utcTime;
        break;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined TimeStamp &TimeStamp::operator = (const TimeStamp &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
TimeStamp::BEncContent (BUF_TYPE b)
{
  AsnLen l;
  switch (choiceId)
  {
    case localTimeCid:
      BEncEocIfNec (b);
      l = localTime->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 0);
      break;

    case utcTimeCid:
      l = utcTime->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 1);
      break;

  } // end switch
  return l;
} // TimeStamp::BEncContent


void TimeStamp::BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  switch (tag)
  {
    case MAKE_TAG_ID (CNTX, CONS, 0):
      choiceId = localTimeCid;
      localTime = new LocalTimeStamp;
        localTime->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 1):
    case MAKE_TAG_ID (CNTX, CONS, 1):
      choiceId = utcTimeCid;
      utcTime = new UTCTime;
        utcTime->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    default:
      Asn1Error << "ERROR - unexpected tag in CHOICE" << std::endl;
      longjmp (env, -183);
      break;
  } // end switch
} // TimeStamp::BDecContent


AsnLen TimeStamp::BEnc (BUF_TYPE b)
{
    AsnLen l;
    l = BEncContent (b);
    return l;
}

void TimeStamp::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
    AsnLen elmtLen;
    AsnTag tag;

    /*  CHOICEs are a special case - grab identifying tag */
    /*  this allows easier handling of nested CHOICEs */
    tag = BDecTag (b, bytesDecoded, env);
    elmtLen = BDecLen (b, bytesDecoded, env);
    BDecContent (b, tag, elmtLen, bytesDecoded, env);
}

int TimeStamp::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int TimeStamp::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void TimeStamp::Print (std::ostream &os) const
{
  switch (choiceId)
  {
    case localTimeCid:
      os << "localTime ";
      if (localTime)
        os << *localTime;
      else
        os << "-- void3 --\n";
      break;

    case utcTimeCid:
      os << "utcTime ";
      if (utcTime)
        os << *utcTime;
      else
        os << "-- void3 --\n";
      break;

  } // end of switch
} // TimeStamp::Print

AsnType *GA_Polygon::Clone() const
{
  return new GA_Polygon;
}

AsnLen GA_Polygon::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void GA_Polygon::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "GA_Polygon::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -184);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

GA_Polygon::GA_Polygon (const GA_Polygon &)
{
  Asn1Error << "use of incompletely defined GA_Polygon::GA_Polygon (const GA_Polygon &)" << std::endl;
  abort();
}

GA_Polygon::~GA_Polygon()
{
  SetCurrToFirst();
  for (; Curr() != NULL; RemoveCurrFromList())
    ;
} // end of destructor

#if SNACC_DEEP_COPY
GA_Polygon &GA_Polygon::operator = (const GA_Polygon &that)
#else // SNACC_DEEP_COPY
GA_Polygon &GA_Polygon::operator = (const GA_Polygon &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    SetCurrToFirst();
    for (; Curr(); RemoveCurrFromList())
      ;

    //that.SetCurrToFirst();
    //for (; that.Curr(); that.GoNext())
    //  AppendCopy (*that.Curr());
    for (const AsnListElmt *run=that.first; run; run=run->next)
      AppendCopy (*run->elmt);
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined GA_Polygon &GA_Polygon::operator = (const GA_Polygon &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

void GA_Polygon::Print (std::ostream &os) const
{
    os << "{ -- SEQUENCE/SET OF -- " << std::endl;
    indentG += stdIndentG;
    //SetCurrToFirst();
    //for (; Curr() != NULL; GoNext())
    for (const AsnListElmt *run=first; run; run=run->next)
    {
        Indent (os, indentG);
        //os << *Curr();
        os << *run->elmt;
        //if (Curr() != Last())
        if (run != last)
            os << ",";
        os << std::endl;
    }
    indentG -= stdIndentG;
    Indent (os, indentG);
    os << "}\n";
} // Print


void  GA_Polygon::SetCurrElmt (unsigned long int index)
{
  unsigned long int i;
  curr = first;
  if (count)
    for (i = 0; (i < (count-1)) && (i < index); i++)
      curr = curr->next;
} // GA_Polygon::SetCurrElmt


unsigned long int  GA_Polygon::GetCurrElmtIndex()
{
    unsigned long int i;
    AsnListElmt *tmp;
    if (curr != NULL)
    {
        for (i = 0, tmp = first; tmp != NULL; i++)
        {
            if (tmp == curr)
                return i;
            else
                tmp = tmp->next;
        }
    }
    return count;
} // GA_Polygon::GetCurrElmtIndex


// alloc new list elmt, put at end of list
//  and return the component type
GA_PolygonSeq *GA_Polygon::Append()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt  = new GA_PolygonSeq;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // GA_Polygon::Append



//--------------------------------------------------------------------------------------------------------
//Begin This was no generated by compiler
GA_PolygonSeq *GA_Polygon::Append(GeographicalCoordinatesEnum platitudeSign,int platitude, int plongitude)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt  = new GA_PolygonSeq(platitudeSign, platitude, plongitude);
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
}

//End This was no generated by compiler
//--------------------------------------------------------------------------------------------------------


// alloc new list elmt, put at begining of list
//  and return the component type
GA_PolygonSeq  *GA_Polygon::Prepend()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new GA_PolygonSeq;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // GA_Polygon::Prepend


// alloc new list elmt, insert it before the
// current element and return the component type
// if the current element is null, the new element
// is placed at the beginning of the list.
GA_PolygonSeq  *GA_Polygon::InsertBefore()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new GA_PolygonSeq;
    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // GA_Polygon::InsertBefore


// alloc new list elmt, insert it after the
// current element and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
GA_PolygonSeq *GA_Polygon::InsertAfter()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new GA_PolygonSeq;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // GA_Polygon::InsertAfter


GA_Polygon  &GA_Polygon::AppendCopy (GA_PolygonSeq &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new GA_PolygonSeq;
    *newElmt->elmt = elmt;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return *this;
} // AppendCopy


GA_Polygon  &GA_Polygon::PrependCopy (GA_PolygonSeq &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new GA_PolygonSeq;
    *newElmt->elmt = elmt;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return *this;
} // GA_Polygon::PrependCopy


// alloc new list elmt, insert it before the
// current element, copy the given elmt into the new elmt
// and return the component type.
// if the current element is null, the new element
// is placed at the beginning of the list.
GA_Polygon &GA_Polygon::InsertBeforeAndCopy (GA_PolygonSeq &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new GA_PolygonSeq;
    *newElmt->elmt = elmt;

    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return *this;
} // GA_Polygon::InsertBeforeAndCopy


// alloc new list elmt, insert it after the
// current element, copy given elmt in to new elmt
//  and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
GA_Polygon  &GA_Polygon::InsertAfterAndCopy (GA_PolygonSeq &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new GA_PolygonSeq;
    *newElmt->elmt = elmt;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return *this;
} // GA_Polygon::InsertAfterAndCopy


// remove current element from list if current element is not NULL
// The new current element will be the next element.
// If the current element is the last element in the list
// the second but last element will become the new current element.
void GA_Polygon::RemoveCurrFromList()
{
    AsnListElmt *del_elmt;

    if (curr != NULL)
    {
        del_elmt = curr;
        count--;

        if (count == 0)
            first = last = curr = NULL;
        else if (curr == first)
        {
            curr = first= first->next;
            first->prev = NULL;
        }
        else if (curr == last)
        {
            curr = last = last->prev;
            last->next = NULL;
        }
        else
        {
            curr->prev->next = curr->next;
            curr->next->prev = curr->prev;
        }

        delete del_elmt->elmt;
        delete del_elmt;
    }
}


AsnLen GA_Polygon::BEncContent (BUF_TYPE b)
{
    AsnListElmt *currElmt;
    AsnLen elmtLen;
    AsnLen totalLen = 0;
    for (currElmt = last; currElmt != NULL; currElmt = currElmt->prev)
    {
      BEncEocIfNec (b);
        elmtLen = currElmt->elmt->BEncContent (b);
    elmtLen += BEncConsLen (b, elmtLen);

    elmtLen += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
        totalLen += elmtLen;
    }
    return totalLen;
} // GA_Polygon::BEncContent


void  GA_Polygon::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0,
                                  AsnLen &bytesDecoded, ENV_TYPE env)
{
    GA_PolygonSeq *listElmt;
    AsnTag tag1;
    AsnLen listBytesDecoded = 0;
    AsnLen elmtLen1;

    while ((listBytesDecoded < elmtLen0) || (elmtLen0 == INDEFINITE_LEN))
    {
        tag1 = BDecTag (b, listBytesDecoded, env);
        if ((tag1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
        {
            BDEC_2ND_EOC_OCTET (b, listBytesDecoded, env);
            break;
        }
        if ((tag1 != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
        {
            Asn1Error << "Unexpected Tag" << std::endl;
            longjmp (env, -185);
        }

        elmtLen1 = BDecLen (b, listBytesDecoded, env);
        listElmt = Append();
        listElmt->BDecContent (b, tag1, elmtLen1, listBytesDecoded, env);
    }

    bytesDecoded += listBytesDecoded;
} // GA_Polygon::BDecContent


Supplementary_Services::Supplementary_Services()
{
  standard_Supplementary_Services = NULL;
  non_Standard_Supplementary_Services = NULL;
  other_Services = NULL;
}

Supplementary_Services::Supplementary_Services (const Supplementary_Services &)
{
  Asn1Error << "use of incompletely defined Supplementary_Services::Supplementary_Services (const Supplementary_Services &)" << std::endl;
  abort();
}

Supplementary_Services::~Supplementary_Services()
{
  delete standard_Supplementary_Services;
  delete non_Standard_Supplementary_Services;
  delete other_Services;
}

AsnType *Supplementary_Services::Clone() const
{
  return new Supplementary_Services;
}

#if SNACC_DEEP_COPY
Supplementary_Services &Supplementary_Services::operator = (const Supplementary_Services &that)
#else // SNACC_DEEP_COPY
Supplementary_Services &Supplementary_Services::operator = (const Supplementary_Services &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    if (that.standard_Supplementary_Services)
    {
      if (!standard_Supplementary_Services)
        standard_Supplementary_Services = new Standard_Supplementary_Services;
      *standard_Supplementary_Services = *that.standard_Supplementary_Services;
    }
    else
    {
      delete standard_Supplementary_Services;
      standard_Supplementary_Services = NULL;
    }
    if (that.non_Standard_Supplementary_Services)
    {
      if (!non_Standard_Supplementary_Services)
        non_Standard_Supplementary_Services = new Non_Standard_Supplementary_Services;
      *non_Standard_Supplementary_Services = *that.non_Standard_Supplementary_Services;
    }
    else
    {
      delete non_Standard_Supplementary_Services;
      non_Standard_Supplementary_Services = NULL;
    }
    if (that.other_Services)
    {
      if (!other_Services)
        other_Services = new Other_Services;
      *other_Services = *that.other_Services;
    }
    else
    {
      delete other_Services;
      other_Services = NULL;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined Supplementary_Services &Supplementary_Services::operator = (const Supplementary_Services &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
Supplementary_Services::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

  if (NOT_NULL (other_Services))
  {
      BEncEocIfNec (b);
    l = other_Services->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 3);
    totalLen += l;
  }

  if (NOT_NULL (non_Standard_Supplementary_Services))
  {
      BEncEocIfNec (b);
    l = non_Standard_Supplementary_Services->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 2);
    totalLen += l;
  }

  if (NOT_NULL (standard_Supplementary_Services))
  {
      BEncEocIfNec (b);
    l = standard_Supplementary_Services->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 1);
    totalLen += l;
  }

  return totalLen;
} // Supplementary_Services::BEncContent


void Supplementary_Services::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  if (elmtLen0 == 0)
    return;
  else
  {
    tag1 = BDecTag (b, seqBytesDecoded, env);

    if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
    {
      BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
      bytesDecoded += seqBytesDecoded;
      return;
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    standard_Supplementary_Services = new Standard_Supplementary_Services;
    standard_Supplementary_Services->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    non_Standard_Supplementary_Services = new Non_Standard_Supplementary_Services;
    non_Standard_Supplementary_Services->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 3)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    other_Services = new Other_Services;
    other_Services->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << std::endl;
    longjmp (env, -186);
  }
  else
    return;
} // Supplementary_Services::BDecContent

AsnLen Supplementary_Services::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void Supplementary_Services::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "Supplementary_Services::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -187);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int Supplementary_Services::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int Supplementary_Services::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void Supplementary_Services::Print (std::ostream &os) const
{
  int nonePrinted = true;
  os << "{ -- SEQUENCE --" << std::endl;
  indentG += stdIndentG;

  if (NOT_NULL (standard_Supplementary_Services))
  {
    nonePrinted = false;
    Indent (os, indentG);
    os << "standard-Supplementary-Services ";
    os << *standard_Supplementary_Services;
  }
  else
  {
    Indent (os, indentG);
    os << "standard-Supplementary-Services ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (non_Standard_Supplementary_Services))
  {
    if (!nonePrinted)
      os << "," << std::endl;
    nonePrinted = false;
    Indent (os, indentG);
    os << "non-Standard-Supplementary-Services ";
    os << *non_Standard_Supplementary_Services;
  }
  else
  {
    Indent (os, indentG);
    os << "non-Standard-Supplementary-Services ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (other_Services))
  {
    if (!nonePrinted)
      os << "," << std::endl;
    nonePrinted = false;
    Indent (os, indentG);
    os << "other-Services ";
    os << *other_Services;
  }
  else
  {
    Indent (os, indentG);
    os << "other-Services ";
    os << "-- void --";
    os << std::endl;
  }

  os << std::endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // Supplementary_Services::Print


DataNodeAddress::DataNodeAddress()
{
  choiceId = ipAddressCid;
#if TCL
  ipAddress = new IPAddress;
#else
  ipAddress = NULL; // incomplete initialization of mandatory element!
#endif // TCL
}

//-----------------------------------------------------------------------------------------------------------------------------------------------------
//Begin of this was not generated by snacc
DataNodeAddress::DataNodeAddress(const char *px25Address )
{
      choiceId = x25AddressCid;
      x25Address = new X25Address;
      x25Address->Set(px25Address);
}
DataNodeAddress::DataNodeAddress(IPAddressEnum ip_type,IP_value::ChoiceIdEnum choiceIpTypeValue, const char *pipAddress )
{
      choiceId = ipAddressCid;
    ipAddress = new IPAddress(ip_type, choiceIpTypeValue, pipAddress );
}
DataNodeAddress::DataNodeAddress(IPAddressEnum ip_type,IP_value::ChoiceIdEnum choiceIpTypeValue, const char *pipAddress, IPAddressEnum1 choiceIpAssignment )
{
      choiceId = ipAddressCid;
    ipAddress = new IPAddress(ip_type, choiceIpTypeValue, pipAddress, choiceIpAssignment );
}
//End of this was not generated by snacc
//-----------------------------------------------------------------------------------------------------------------------------------------------------

DataNodeAddress::DataNodeAddress (const DataNodeAddress &)
{
  Asn1Error << "use of incompletely defined DataNodeAddress::DataNodeAddress (const DataNodeAddress &)" << std::endl;
  abort();
}

DataNodeAddress::~DataNodeAddress()
{
  switch (choiceId)
  {
    case ipAddressCid:
      delete ipAddress;
      break;
    case x25AddressCid:
      delete x25Address;
      break;
  } // end of switch
} // end of destructor

AsnType *DataNodeAddress::Clone() const
{
  return new DataNodeAddress;
}

#if SNACC_DEEP_COPY
DataNodeAddress &DataNodeAddress::operator = (const DataNodeAddress &that)
#else // SNACC_DEEP_COPY
DataNodeAddress &DataNodeAddress::operator = (const DataNodeAddress &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    switch (choiceId)
    {
      case ipAddressCid:
        delete ipAddress;
        break;
      case x25AddressCid:
        delete x25Address;
        break;
    }
    switch (choiceId = that.choiceId)
    {
      case ipAddressCid:
        ipAddress = new IPAddress;
        *ipAddress = *that.ipAddress;
        break;
      case x25AddressCid:
        x25Address = new X25Address;
        *x25Address = *that.x25Address;
        break;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined DataNodeAddress &DataNodeAddress::operator = (const DataNodeAddress &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
DataNodeAddress::BEncContent (BUF_TYPE b)
{
  AsnLen l;
  switch (choiceId)
  {
    case ipAddressCid:
      BEncEocIfNec (b);
      l = ipAddress->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 1);
      break;

    case x25AddressCid:
      l = x25Address->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 2);
      break;

  } // end switch
  return l;
} // DataNodeAddress::BEncContent


void DataNodeAddress::BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  switch (tag)
  {
    case MAKE_TAG_ID (CNTX, CONS, 1):
      choiceId = ipAddressCid;
      ipAddress = new IPAddress;
        ipAddress->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 2):
    case MAKE_TAG_ID (CNTX, CONS, 2):
      choiceId = x25AddressCid;
      x25Address = new X25Address;
        x25Address->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    default:
      Asn1Error << "ERROR - unexpected tag in CHOICE" << std::endl;
      longjmp (env, -188);
      break;
  } // end switch
} // DataNodeAddress::BDecContent


AsnLen DataNodeAddress::BEnc (BUF_TYPE b)
{
    AsnLen l;
    l = BEncContent (b);
    return l;
}

void DataNodeAddress::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
    AsnLen elmtLen;
    AsnTag tag;

    /*  CHOICEs are a special case - grab identifying tag */
    /*  this allows easier handling of nested CHOICEs */
    tag = BDecTag (b, bytesDecoded, env);
    elmtLen = BDecLen (b, bytesDecoded, env);
    BDecContent (b, tag, elmtLen, bytesDecoded, env);
}

int DataNodeAddress::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int DataNodeAddress::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void DataNodeAddress::Print (std::ostream &os) const
{
  switch (choiceId)
  {
    case ipAddressCid:
      os << "ipAddress ";
      if (ipAddress)
        os << *ipAddress;
      else
        os << "-- void3 --\n";
      break;

    case x25AddressCid:
      os << "x25Address ";
      if (x25Address)
        os << *x25Address;
      else
        os << "-- void3 --\n";
      break;

  } // end of switch
} // DataNodeAddress::Print

Network_Identifier::Network_Identifier()
{
  network_Element_Identifier = NULL;
}

Network_Identifier::Network_Identifier (const Network_Identifier &)
{
  Asn1Error << "use of incompletely defined Network_Identifier::Network_Identifier (const Network_Identifier &)" << std::endl;
  abort();
}

Network_Identifier::~Network_Identifier()
{
  delete network_Element_Identifier;
}

AsnType *Network_Identifier::Clone() const
{
  return new Network_Identifier;
}

#if SNACC_DEEP_COPY
Network_Identifier &Network_Identifier::operator = (const Network_Identifier &that)
#else // SNACC_DEEP_COPY
Network_Identifier &Network_Identifier::operator = (const Network_Identifier &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    operator_Identifier = that.operator_Identifier;
    if (that.network_Element_Identifier)
    {
      if (!network_Element_Identifier)
        network_Element_Identifier = new Network_Element_Identifier;
      *network_Element_Identifier = *that.network_Element_Identifier;
    }
    else
    {
      delete network_Element_Identifier;
      network_Element_Identifier = NULL;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined Network_Identifier &Network_Identifier::operator = (const Network_Identifier &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
Network_Identifier::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

  if (NOT_NULL (network_Element_Identifier))
  {
      BEncEocIfNec (b);
    l = network_Element_Identifier->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 1);
    totalLen += l;
  }

    l = operator_Identifier.BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // Network_Identifier::BEncContent


void Network_Identifier::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  AsnLen elmtLen2;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    operator_Identifier.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << std::endl;
    longjmp (env, -189);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
    elmtLen2 = BDecLen (b, seqBytesDecoded, env);
    network_Element_Identifier = new Network_Element_Identifier;
    network_Element_Identifier->BDecContent (b, tag1, elmtLen2, seqBytesDecoded, env);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (b, seqBytesDecoded, env);

  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << std::endl;
    longjmp (env, -190);
  }
  else
    return;
} // Network_Identifier::BDecContent

AsnLen Network_Identifier::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void Network_Identifier::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "Network_Identifier::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -191);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int Network_Identifier::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int Network_Identifier::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void Network_Identifier::Print (std::ostream &os) const
{
  os << "{ -- SEQUENCE --" << std::endl;
  indentG += stdIndentG;

  {
    Indent (os, indentG);
    os << "operator-Identifier ";
    os << operator_Identifier;
    os << "," << std::endl;
  }

  if (NOT_NULL (network_Element_Identifier))
  {
    os << ","<< std::endl;
    Indent (os, indentG);
    os << "network-Element-Identifier ";
    os << *network_Element_Identifier;
  }
  else
  {
    Indent (os, indentG);
    os << "network-Element-Identifier ";
    os << "-- void --";
    os << std::endl;
  }

  os << std::endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // Network_Identifier::Print


UMTSLocation::UMTSLocation()
{
  choiceId = polygonCid;
//#if TCL
  polygon = new GA_Polygon;
//#else
  //point = NULL; // incomplete initialization of mandatory element!
//#endif // TCL
}

//-----------------------------------------------------------------------------------------------------------------------------------
//Begin this was not generated by snacc
UMTSLocation::UMTSLocation(GeographicalCoordinatesEnum platitudeSign,int platitude, int plongitude,unsigned int puncertaintyCode)
{
    choiceId = pointWithUnCertaintyCid;
    pointWithUnCertainty = new GA_PointWithUnCertainty(platitudeSign, platitude, plongitude, puncertaintyCode);
}
UMTSLocation::UMTSLocation(GeographicalCoordinatesEnum platitudeSign,int platitude, int plongitude)
{
    choiceId = pointCid;
    point = new GA_Point(platitudeSign, platitude, plongitude);
}

void UMTSLocation::AddPointToGAPolygon(GeographicalCoordinatesEnum platitudeSign,int platitude, int plongitude)
{
    choiceId = polygonCid;
    polygon->Append(platitudeSign, platitude, plongitude);
}

//End this was not generated by snacc
//-----------------------------------------------------------------------------------------------------------------------------------

UMTSLocation::UMTSLocation (const UMTSLocation &)
{
  Asn1Error << "use of incompletely defined UMTSLocation::UMTSLocation (const UMTSLocation &)" << std::endl;
  abort();
}

UMTSLocation::~UMTSLocation()
{
  switch (choiceId)
  {
    case pointCid:
      delete point;
      break;
    case pointWithUnCertaintyCid:
      delete pointWithUnCertainty;
      break;
    case polygonCid:
      delete polygon;
      break;
  } // end of switch
} // end of destructor

AsnType *UMTSLocation::Clone() const
{
  return new UMTSLocation;
}

#if SNACC_DEEP_COPY
UMTSLocation &UMTSLocation::operator = (const UMTSLocation &that)
#else // SNACC_DEEP_COPY
UMTSLocation &UMTSLocation::operator = (const UMTSLocation &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    switch (choiceId)
    {
      case pointCid:
        delete point;
        break;
      case pointWithUnCertaintyCid:
        delete pointWithUnCertainty;
        break;
      case polygonCid:
        delete polygon;
        break;
    }
    switch (choiceId = that.choiceId)
    {
      case pointCid:
        point = new GA_Point;
        *point = *that.point;
        break;
      case pointWithUnCertaintyCid:
        pointWithUnCertainty = new GA_PointWithUnCertainty;
        *pointWithUnCertainty = *that.pointWithUnCertainty;
        break;
      case polygonCid:
        polygon = new GA_Polygon;
        *polygon = *that.polygon;
        break;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined UMTSLocation &UMTSLocation::operator = (const UMTSLocation &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
UMTSLocation::BEncContent (BUF_TYPE b)
{
  AsnLen l;
  switch (choiceId)
  {
    case pointCid:
      BEncEocIfNec (b);
      l = point->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 1);
      break;

    case pointWithUnCertaintyCid:
      BEncEocIfNec (b);
      l = pointWithUnCertainty->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 2);
      break;

    case polygonCid:
      BEncEocIfNec (b);
      l = polygon->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 3);
      break;

  } // end switch
  return l;
} // UMTSLocation::BEncContent


void UMTSLocation::BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  switch (tag)
  {
    case MAKE_TAG_ID (CNTX, CONS, 1):
      choiceId = pointCid;
      point = new GA_Point;
        point->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, CONS, 2):
      choiceId = pointWithUnCertaintyCid;
      pointWithUnCertainty = new GA_PointWithUnCertainty;
        pointWithUnCertainty->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, CONS, 3):
      choiceId = polygonCid;
      polygon = new GA_Polygon;
        polygon->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    default:
      Asn1Error << "ERROR - unexpected tag in CHOICE" << std::endl;
      longjmp (env, -192);
      break;
  } // end switch
} // UMTSLocation::BDecContent


AsnLen UMTSLocation::BEnc (BUF_TYPE b)
{
    AsnLen l;
    l = BEncContent (b);
    return l;
}

void UMTSLocation::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
    AsnLen elmtLen;
    AsnTag tag;

    /*  CHOICEs are a special case - grab identifying tag */
    /*  this allows easier handling of nested CHOICEs */
    tag = BDecTag (b, bytesDecoded, env);
    elmtLen = BDecLen (b, bytesDecoded, env);
    BDecContent (b, tag, elmtLen, bytesDecoded, env);
}

int UMTSLocation::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int UMTSLocation::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void UMTSLocation::Print (std::ostream &os) const
{
  switch (choiceId)
  {
    case pointCid:
      os << "point ";
      if (point)
        os << *point;
      else
        os << "-- void3 --\n";
      break;

    case pointWithUnCertaintyCid:
      os << "pointWithUnCertainty ";
      if (pointWithUnCertainty)
        os << *pointWithUnCertainty;
      else
        os << "-- void3 --\n";
      break;

    case polygonCid:
      os << "polygon ";
      if (polygon)
        os << *polygon;
      else
        os << "-- void3 --\n";
      break;

  } // end of switch
} // UMTSLocation::Print

GPRS_parameters::GPRS_parameters()
{
  pDP_address_allocated_to_the_target = NULL;
  aPN = NULL;
  pDP_type = NULL;
}

GPRS_parameters::GPRS_parameters (const GPRS_parameters &)
{
  Asn1Error << "use of incompletely defined GPRS_parameters::GPRS_parameters (const GPRS_parameters &)" << std::endl;
  abort();
}

GPRS_parameters::~GPRS_parameters()
{
  delete pDP_address_allocated_to_the_target;
  delete aPN;
  delete pDP_type;
}

AsnType *GPRS_parameters::Clone() const
{
  return new GPRS_parameters;
}

#if SNACC_DEEP_COPY
GPRS_parameters &GPRS_parameters::operator = (const GPRS_parameters &that)
#else // SNACC_DEEP_COPY
GPRS_parameters &GPRS_parameters::operator = (const GPRS_parameters &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    if (that.pDP_address_allocated_to_the_target)
    {
      if (!pDP_address_allocated_to_the_target)
        pDP_address_allocated_to_the_target = new DataNodeAddress;
      *pDP_address_allocated_to_the_target = *that.pDP_address_allocated_to_the_target;
    }
    else
    {
      delete pDP_address_allocated_to_the_target;
      pDP_address_allocated_to_the_target = NULL;
    }
    if (that.aPN)
    {
      if (!aPN)
        aPN = new AsnOcts;
      *aPN = *that.aPN;
    }
    else
    {
      delete aPN;
      aPN = NULL;
    }
    if (that.pDP_type)
    {
      if (!pDP_type)
        pDP_type = new AsnOcts;
      *pDP_type = *that.pDP_type;
    }
    else
    {
      delete pDP_type;
      pDP_type = NULL;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined GPRS_parameters &GPRS_parameters::operator = (const GPRS_parameters &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
GPRS_parameters::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

  if (NOT_NULL (pDP_type))
  {
    l = pDP_type->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 3);
    totalLen += l;
  }

  if (NOT_NULL (aPN))
  {
    l = aPN->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 2);
    totalLen += l;
  }

  if (NOT_NULL (pDP_address_allocated_to_the_target))
  {
      BEncEocIfNec (b);
    l = pDP_address_allocated_to_the_target->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 1);
    totalLen += l;
  }

  return totalLen;
} // GPRS_parameters::BEncContent


void GPRS_parameters::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  AsnLen elmtLen2;
  if (elmtLen0 == 0)
    return;
  else
  {
    tag1 = BDecTag (b, seqBytesDecoded, env);

    if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
    {
      BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
      bytesDecoded += seqBytesDecoded;
      return;
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
    elmtLen2 = BDecLen (b, seqBytesDecoded, env);
    pDP_address_allocated_to_the_target = new DataNodeAddress;
    pDP_address_allocated_to_the_target->BDecContent (b, tag1, elmtLen2, seqBytesDecoded, env);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (b, seqBytesDecoded, env);

    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    aPN = new AsnOcts;
    aPN->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 3)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    pDP_type = new AsnOcts;
    pDP_type->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << std::endl;
    longjmp (env, -193);
  }
  else
    return;
} // GPRS_parameters::BDecContent

AsnLen GPRS_parameters::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void GPRS_parameters::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "GPRS_parameters::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -194);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int GPRS_parameters::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int GPRS_parameters::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void GPRS_parameters::Print (std::ostream &os) const
{
  int nonePrinted = true;
  os << "{ -- SEQUENCE --" << std::endl;
  indentG += stdIndentG;

  if (NOT_NULL (pDP_address_allocated_to_the_target))
  {
    nonePrinted = false;
    Indent (os, indentG);
    os << "pDP-address-allocated-to-the-target ";
    os << *pDP_address_allocated_to_the_target;
  }
  else
  {
    Indent (os, indentG);
    os << "pDP-address-allocated-to-the-target ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (aPN))
  {
    if (!nonePrinted)
      os << "," << std::endl;
    nonePrinted = false;
    Indent (os, indentG);
    os << "aPN ";
    os << *aPN;
  }
  else
  {
    Indent (os, indentG);
    os << "aPN ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (pDP_type))
  {
    if (!nonePrinted)
      os << "," << std::endl;
    nonePrinted = false;
    Indent (os, indentG);
    os << "pDP-type ";
    os << *pDP_type;
  }
  else
  {
    Indent (os, indentG);
    os << "pDP-type ";
    os << "-- void --";
    os << std::endl;
  }

  os << std::endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // GPRS_parameters::Print


CommunicationIdentifier::CommunicationIdentifier()
{
  communication_Identity_Number = NULL;
//#if TCL
  network_Identifier = new Network_Identifier;
/*
#else
  network_Identifier = NULL; // incomplete initialization of mandatory element!
#endif // TCL
*/
}

CommunicationIdentifier::CommunicationIdentifier (const CommunicationIdentifier &)
{
  Asn1Error << "use of incompletely defined CommunicationIdentifier::CommunicationIdentifier (const CommunicationIdentifier &)" << std::endl;
  abort();
}

CommunicationIdentifier::~CommunicationIdentifier()
{
  delete communication_Identity_Number;
  delete network_Identifier;
}

AsnType *CommunicationIdentifier::Clone() const
{
  return new CommunicationIdentifier;
}

#if SNACC_DEEP_COPY
CommunicationIdentifier &CommunicationIdentifier::operator = (const CommunicationIdentifier &that)
#else // SNACC_DEEP_COPY
CommunicationIdentifier &CommunicationIdentifier::operator = (const CommunicationIdentifier &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    if (that.communication_Identity_Number)
    {
      if (!communication_Identity_Number)
        communication_Identity_Number = new AsnOcts;
      *communication_Identity_Number = *that.communication_Identity_Number;
    }
    else
    {
      delete communication_Identity_Number;
      communication_Identity_Number = NULL;
    }
    if (that.network_Identifier)
    {
      if (!network_Identifier)
        network_Identifier = new Network_Identifier;
      *network_Identifier = *that.network_Identifier;
    }
    else
    {
      delete network_Identifier;
      network_Identifier = NULL;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined CommunicationIdentifier &CommunicationIdentifier::operator = (const CommunicationIdentifier &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
CommunicationIdentifier::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

      BEncEocIfNec (b);
    l = network_Identifier->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 1);
    totalLen += l;

  if (NOT_NULL (communication_Identity_Number))
  {
    l = communication_Identity_Number->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 0);
    totalLen += l;
  }

  return totalLen;
} // CommunicationIdentifier::BEncContent


void CommunicationIdentifier::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    communication_Identity_Number = new AsnOcts;
    communication_Identity_Number->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    network_Identifier = new Network_Identifier;
    network_Identifier->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << std::endl;
    longjmp (env, -195);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << std::endl;
    longjmp (env, -196);
  }
  else
    return;
} // CommunicationIdentifier::BDecContent

AsnLen CommunicationIdentifier::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void CommunicationIdentifier::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "CommunicationIdentifier::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -197);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int CommunicationIdentifier::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int CommunicationIdentifier::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void CommunicationIdentifier::Print (std::ostream &os) const
{
  os << "{ -- SEQUENCE --" << std::endl;
  indentG += stdIndentG;

  if (NOT_NULL (communication_Identity_Number))
  {
    Indent (os, indentG);
    os << "communication-Identity-Number ";
    os << *communication_Identity_Number;
  }
  else
  {
    Indent (os, indentG);
    os << "communication-Identity-Number ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (network_Identifier))
  {
    Indent (os, indentG);
    os << "network-Identifier ";
    os << *network_Identifier;
  }
  else
  {
    Indent (os, indentG);
    os << "network-Identifier ";
    os << "-- void --";
    os << std::endl;
  }

  os << std::endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // CommunicationIdentifier::Print


Services_Data_Information::Services_Data_Information()
{
  gPRS_parameters = NULL;
}

Services_Data_Information::Services_Data_Information (const Services_Data_Information &)
{
  Asn1Error << "use of incompletely defined Services_Data_Information::Services_Data_Information (const Services_Data_Information &)" << std::endl;
  abort();
}

Services_Data_Information::~Services_Data_Information()
{
  delete gPRS_parameters;
}

AsnType *Services_Data_Information::Clone() const
{
  return new Services_Data_Information;
}

#if SNACC_DEEP_COPY
Services_Data_Information &Services_Data_Information::operator = (const Services_Data_Information &that)
#else // SNACC_DEEP_COPY
Services_Data_Information &Services_Data_Information::operator = (const Services_Data_Information &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    if (that.gPRS_parameters)
    {
      if (!gPRS_parameters)
        gPRS_parameters = new GPRS_parameters;
      *gPRS_parameters = *that.gPRS_parameters;
    }
    else
    {
      delete gPRS_parameters;
      gPRS_parameters = NULL;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined Services_Data_Information &Services_Data_Information::operator = (const Services_Data_Information &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
Services_Data_Information::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

  if (NOT_NULL (gPRS_parameters))
  {
      BEncEocIfNec (b);
    l = gPRS_parameters->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 1);
    totalLen += l;
  }

  return totalLen;
} // Services_Data_Information::BEncContent


void Services_Data_Information::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  if (elmtLen0 == 0)
    return;
  else
  {
    tag1 = BDecTag (b, seqBytesDecoded, env);

    if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
    {
      BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
      bytesDecoded += seqBytesDecoded;
      return;
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    gPRS_parameters = new GPRS_parameters;
    gPRS_parameters->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << std::endl;
    longjmp (env, -198);
  }
  else
    return;
} // Services_Data_Information::BDecContent

AsnLen Services_Data_Information::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void Services_Data_Information::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "Services_Data_Information::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -199);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int Services_Data_Information::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int Services_Data_Information::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void Services_Data_Information::Print (std::ostream &os) const
{
  int nonePrinted = true;
  os << "{ -- SEQUENCE --" << std::endl;
  indentG += stdIndentG;

  if (NOT_NULL (gPRS_parameters))
  {
    nonePrinted = false;
    Indent (os, indentG);
    os << "gPRS-parameters ";
    os << *gPRS_parameters;
  }
  else
  {
    Indent (os, indentG);
    os << "gPRS-parameters ";
    os << "-- void --";
    os << std::endl;
  }

  os << std::endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // Services_Data_Information::Print



/* *************************************************************************

Partys

*/



Location::Location()
{
  e164_Number = NULL;
  globalCellID = NULL;
  tetraLocation = NULL;
  rAI = NULL;
  gsmLocation = NULL;
  umtsLocation = NULL;
  sAI = NULL;
}

Location::Location (const Location &)
{
  Asn1Error << "use of incompletely defined Location::Location (const Location &)" << std::endl;
  abort();
}

Location::~Location()
{
  delete e164_Number;
  delete globalCellID;
  delete tetraLocation;
  delete rAI;
  delete gsmLocation;
  delete umtsLocation;
  delete sAI;
}

AsnType *Location::Clone() const
{
  return new Location;
}

#if SNACC_DEEP_COPY
Location &Location::operator = (const Location &that)
#else // SNACC_DEEP_COPY
Location &Location::operator = (const Location &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    if (that.e164_Number)
    {
      if (!e164_Number)
        e164_Number = new AsnOcts;
      *e164_Number = *that.e164_Number;
    }
    else
    {
      delete e164_Number;
      e164_Number = NULL;
    }
    if (that.globalCellID)
    {
      if (!globalCellID)
        globalCellID = new AsnOcts;
      *globalCellID = *that.globalCellID;
    }
    else
    {
      delete globalCellID;
      globalCellID = NULL;
    }
    if (that.tetraLocation)
    {
      if (!tetraLocation)
        tetraLocation = new TetraLocation;
      *tetraLocation = *that.tetraLocation;
    }
    else
    {
      delete tetraLocation;
      tetraLocation = NULL;
    }
    if (that.rAI)
    {
      if (!rAI)
        rAI = new AsnOcts;
      *rAI = *that.rAI;
    }
    else
    {
      delete rAI;
      rAI = NULL;
    }
    if (that.gsmLocation)
    {
      if (!gsmLocation)
        gsmLocation = new GSMLocation;
      *gsmLocation = *that.gsmLocation;
    }
    else
    {
      delete gsmLocation;
      gsmLocation = NULL;
    }
    if (that.umtsLocation)
    {
      if (!umtsLocation)
        umtsLocation = new UMTSLocation;
      *umtsLocation = *that.umtsLocation;
    }
    else
    {
      delete umtsLocation;
      umtsLocation = NULL;
    }
    if (that.sAI)
    {
      if (!sAI)
        sAI = new AsnOcts;
      *sAI = *that.sAI;
    }
    else
    {
      delete sAI;
      sAI = NULL;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined Location &Location::operator = (const Location &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
Location::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

  if (NOT_NULL (sAI))
  {
    l = sAI->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 7);
    totalLen += l;
  }

  if (NOT_NULL (umtsLocation))
  {
      BEncEocIfNec (b);
    l = umtsLocation->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 6);
    totalLen += l;
  }

  if (NOT_NULL (gsmLocation))
  {
      BEncEocIfNec (b);
    l = gsmLocation->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 5);
    totalLen += l;
  }

  if (NOT_NULL (rAI))
  {
    l = rAI->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 4);
    totalLen += l;
  }

  if (NOT_NULL (tetraLocation))
  {
      BEncEocIfNec (b);
    l = tetraLocation->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 3);
    totalLen += l;
  }

  if (NOT_NULL (globalCellID))
  {
    l = globalCellID->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 2);
    totalLen += l;
  }

  if (NOT_NULL (e164_Number))
  {
    l = e164_Number->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 1);
    totalLen += l;
  }

  return totalLen;
} // Location::BEncContent


void Location::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  AsnLen elmtLen2;
  if (elmtLen0 == 0)
    return;
  else
  {
    tag1 = BDecTag (b, seqBytesDecoded, env);

    if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
    {
      BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
      bytesDecoded += seqBytesDecoded;
      return;
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    e164_Number = new AsnOcts;
    e164_Number->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    globalCellID = new AsnOcts;
    globalCellID->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 3)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
    elmtLen2 = BDecLen (b, seqBytesDecoded, env);
    tetraLocation = new TetraLocation;
    tetraLocation->BDecContent (b, tag1, elmtLen2, seqBytesDecoded, env);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (b, seqBytesDecoded, env);

    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 4)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    rAI = new AsnOcts;
    rAI->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 5)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
    elmtLen2 = BDecLen (b, seqBytesDecoded, env);
    gsmLocation = new GSMLocation;
    gsmLocation->BDecContent (b, tag1, elmtLen2, seqBytesDecoded, env);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (b, seqBytesDecoded, env);

    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 6)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
    elmtLen2 = BDecLen (b, seqBytesDecoded, env);
    umtsLocation = new UMTSLocation;
    umtsLocation->BDecContent (b, tag1, elmtLen2, seqBytesDecoded, env);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (b, seqBytesDecoded, env);

    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 7))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 7)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    sAI = new AsnOcts;
    sAI->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << std::endl;
    longjmp (env, -204);
  }
  else
    return;
} // Location::BDecContent

AsnLen Location::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void Location::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "Location::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -205);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int Location::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int Location::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void Location::Print (std::ostream &os) const
{
  int nonePrinted = true;
  os << "{ -- SEQUENCE --" << std::endl;
  indentG += stdIndentG;

  if (NOT_NULL (e164_Number))
  {
    nonePrinted = false;
    Indent (os, indentG);
    os << "e164-Number ";
    os << *e164_Number;
  }
  else
  {
    Indent (os, indentG);
    os << "e164-Number ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (globalCellID))
  {
    if (!nonePrinted)
      os << "," << std::endl;
    nonePrinted = false;
    Indent (os, indentG);
    os << "globalCellID ";
    os << *globalCellID;
  }
  else
  {
    Indent (os, indentG);
    os << "globalCellID ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (tetraLocation))
  {
    if (!nonePrinted)
      os << "," << std::endl;
    nonePrinted = false;
    Indent (os, indentG);
    os << "tetraLocation ";
    os << *tetraLocation;
  }
  else
  {
    Indent (os, indentG);
    os << "tetraLocation ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (rAI))
  {
    if (!nonePrinted)
      os << "," << std::endl;
    nonePrinted = false;
    Indent (os, indentG);
    os << "rAI ";
    os << *rAI;
  }
  else
  {
    Indent (os, indentG);
    os << "rAI ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (gsmLocation))
  {
    if (!nonePrinted)
      os << "," << std::endl;
    nonePrinted = false;
    Indent (os, indentG);
    os << "gsmLocation ";
    os << *gsmLocation;
  }
  else
  {
    Indent (os, indentG);
    os << "gsmLocation ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (umtsLocation))
  {
    if (!nonePrinted)
      os << "," << std::endl;
    nonePrinted = false;
    Indent (os, indentG);
    os << "umtsLocation ";
    os << *umtsLocation;
  }
  else
  {
    Indent (os, indentG);
    os << "umtsLocation ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (sAI))
  {
    if (!nonePrinted)
      os << "," << std::endl;
    nonePrinted = false;
    Indent (os, indentG);
    os << "sAI ";
    os << *sAI;
  }
  else
  {
    Indent (os, indentG);
    os << "sAI ";
    os << "-- void --";
    os << std::endl;
  }

  os << std::endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // Location::Print


CallContentLinkCharacteristics::CallContentLinkCharacteristics()
{
  cCLink_State = NULL;
  release_Time = NULL;
  release_Reason = NULL;
  lEMF_Address = NULL;
}

CallContentLinkCharacteristics::CallContentLinkCharacteristics (const CallContentLinkCharacteristics &)
{
  Asn1Error << "use of incompletely defined CallContentLinkCharacteristics::CallContentLinkCharacteristics (const CallContentLinkCharacteristics &)" << std::endl;
  abort();
}

CallContentLinkCharacteristics::~CallContentLinkCharacteristics()
{
  delete cCLink_State;
  delete release_Time;
  delete release_Reason;
  delete lEMF_Address;
}

AsnType *CallContentLinkCharacteristics::Clone() const
{
  return new CallContentLinkCharacteristics;
}

#if SNACC_DEEP_COPY
CallContentLinkCharacteristics &CallContentLinkCharacteristics::operator = (const CallContentLinkCharacteristics &that)
#else // SNACC_DEEP_COPY
CallContentLinkCharacteristics &CallContentLinkCharacteristics::operator = (const CallContentLinkCharacteristics &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    if (that.cCLink_State)
    {
      if (!cCLink_State)
        cCLink_State = new CCLink_State;
      *cCLink_State = *that.cCLink_State;
    }
    else
    {
      delete cCLink_State;
      cCLink_State = NULL;
    }
    if (that.release_Time)
    {
      if (!release_Time)
        release_Time = new TimeStamp;
      *release_Time = *that.release_Time;
    }
    else
    {
      delete release_Time;
      release_Time = NULL;
    }
    if (that.release_Reason)
    {
      if (!release_Reason)
        release_Reason = new AsnOcts;
      *release_Reason = *that.release_Reason;
    }
    else
    {
      delete release_Reason;
      release_Reason = NULL;
    }
    if (that.lEMF_Address)
    {
      if (!lEMF_Address)
        lEMF_Address = new CalledPartyNumber;
      *lEMF_Address = *that.lEMF_Address;
    }
    else
    {
      delete lEMF_Address;
      lEMF_Address = NULL;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined CallContentLinkCharacteristics &CallContentLinkCharacteristics::operator = (const CallContentLinkCharacteristics &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
CallContentLinkCharacteristics::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

  if (NOT_NULL (lEMF_Address))
  {
      BEncEocIfNec (b);
    l = lEMF_Address->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 4);
    totalLen += l;
  }

  if (NOT_NULL (release_Reason))
  {
    l = release_Reason->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 3);
    totalLen += l;
  }

  if (NOT_NULL (release_Time))
  {
      BEncEocIfNec (b);
    l = release_Time->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 2);
    totalLen += l;
  }

  if (NOT_NULL (cCLink_State))
  {
    l = cCLink_State->BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, CNTX, PRIM, 1);
    totalLen += l;
  }

  return totalLen;
} // CallContentLinkCharacteristics::BEncContent


void CallContentLinkCharacteristics::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  AsnLen elmtLen2;
  if (elmtLen0 == 0)
    return;
  else
  {
    tag1 = BDecTag (b, seqBytesDecoded, env);

    if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
    {
      BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
      bytesDecoded += seqBytesDecoded;
      return;
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    cCLink_State = new CCLink_State;
    cCLink_State->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
    elmtLen2 = BDecLen (b, seqBytesDecoded, env);
    release_Time = new TimeStamp;
    release_Time->BDecContent (b, tag1, elmtLen2, seqBytesDecoded, env);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (b, seqBytesDecoded, env);

    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 3)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    release_Reason = new AsnOcts;
    release_Reason->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 4)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
    elmtLen2 = BDecLen (b, seqBytesDecoded, env);
    lEMF_Address = new CalledPartyNumber;
    lEMF_Address->BDecContent (b, tag1, elmtLen2, seqBytesDecoded, env);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (b, seqBytesDecoded, env);

  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << std::endl;
    longjmp (env, -206);
  }
  else
    return;
} // CallContentLinkCharacteristics::BDecContent

AsnLen CallContentLinkCharacteristics::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void CallContentLinkCharacteristics::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "CallContentLinkCharacteristics::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -207);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int CallContentLinkCharacteristics::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int CallContentLinkCharacteristics::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void CallContentLinkCharacteristics::Print (std::ostream &os) const
{
  int nonePrinted = true;
  os << "{ -- SEQUENCE --" << std::endl;
  indentG += stdIndentG;

  if (NOT_NULL (cCLink_State))
  {
    nonePrinted = false;
    Indent (os, indentG);
    os << "cCLink-State ";
    os << *cCLink_State;
  }
  else
  {
    Indent (os, indentG);
    os << "cCLink-State ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (release_Time))
  {
    if (!nonePrinted)
      os << "," << std::endl;
    nonePrinted = false;
    Indent (os, indentG);
    os << "release-Time ";
    os << *release_Time;
  }
  else
  {
    Indent (os, indentG);
    os << "release-Time ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (release_Reason))
  {
    if (!nonePrinted)
      os << "," << std::endl;
    nonePrinted = false;
    Indent (os, indentG);
    os << "release-Reason ";
    os << *release_Reason;
  }
  else
  {
    Indent (os, indentG);
    os << "release-Reason ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (lEMF_Address))
  {
    if (!nonePrinted)
      os << "," << std::endl;
    nonePrinted = false;
    Indent (os, indentG);
    os << "lEMF-Address ";
    os << *lEMF_Address;
  }
  else
  {
    Indent (os, indentG);
    os << "lEMF-Address ";
    os << "-- void --";
    os << std::endl;
  }

  os << std::endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // CallContentLinkCharacteristics::Print


SMS_report::SMS_report()
{
//#if TCL
  communicationIdentifier = new CommunicationIdentifier;
/*#else
  communicationIdentifier = NULL; // incomplete initialization of mandatory element!
#endif // TCL
#if TCL*/
  timeStamp = new TimeStamp;
/*#else
  timeStamp = NULL; // incomplete initialization of mandatory element!
#endif // TCL
#if TCL*/
  sMS_Contents = new SMS_reportSeq;
/*#else
  sMS_Contents = NULL; // incomplete initialization of mandatory element!
#endif // TCL*/
}

SMS_report::SMS_report (const SMS_report &)
{
  Asn1Error << "use of incompletely defined SMS_report::SMS_report (const SMS_report &)" << std::endl;
  abort();
}

SMS_report::~SMS_report()
{
  delete communicationIdentifier;
  delete timeStamp;
  delete sMS_Contents;
}

AsnType *SMS_report::Clone() const
{
  return new SMS_report;
}

#if SNACC_DEEP_COPY
SMS_report &SMS_report::operator = (const SMS_report &that)
#else // SNACC_DEEP_COPY
SMS_report &SMS_report::operator = (const SMS_report &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    if (that.communicationIdentifier)
    {
      if (!communicationIdentifier)
        communicationIdentifier = new CommunicationIdentifier;
      *communicationIdentifier = *that.communicationIdentifier;
    }
    else
    {
      delete communicationIdentifier;
      communicationIdentifier = NULL;
    }
    if (that.timeStamp)
    {
      if (!timeStamp)
        timeStamp = new TimeStamp;
      *timeStamp = *that.timeStamp;
    }
    else
    {
      delete timeStamp;
      timeStamp = NULL;
    }
    if (that.sMS_Contents)
    {
      if (!sMS_Contents)
        sMS_Contents = new SMS_reportSeq;
      *sMS_Contents = *that.sMS_Contents;
    }
    else
    {
      delete sMS_Contents;
      sMS_Contents = NULL;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined SMS_report &SMS_report::operator = (const SMS_report &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
SMS_report::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

      BEncEocIfNec (b);
    l = sMS_Contents->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 3);
    totalLen += l;

      BEncEocIfNec (b);
    l = timeStamp->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 2);
    totalLen += l;

      BEncEocIfNec (b);
    l = communicationIdentifier->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 1);
    totalLen += l;

  return totalLen;
} // SMS_report::BEncContent


void SMS_report::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  AsnLen elmtLen2;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    communicationIdentifier = new CommunicationIdentifier;
    communicationIdentifier->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << std::endl;
    longjmp (env, -208);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
    elmtLen2 = BDecLen (b, seqBytesDecoded, env);
    timeStamp = new TimeStamp;
    timeStamp->BDecContent (b, tag1, elmtLen2, seqBytesDecoded, env);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (b, seqBytesDecoded, env);

    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << std::endl;
    longjmp (env, -209);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 3)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    sMS_Contents = new SMS_reportSeq;
    sMS_Contents->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << std::endl;
    longjmp (env, -210);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << std::endl;
    longjmp (env, -211);
  }
  else
    return;
} // SMS_report::BDecContent

AsnLen SMS_report::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void SMS_report::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "SMS_report::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -212);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int SMS_report::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int SMS_report::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void SMS_report::Print (std::ostream &os) const
{
  os << "{ -- SEQUENCE --" << std::endl;
  indentG += stdIndentG;

  if (NOT_NULL (communicationIdentifier))
  {
    Indent (os, indentG);
    os << "communicationIdentifier ";
    os << *communicationIdentifier;
  }
  else
  {
    Indent (os, indentG);
    os << "communicationIdentifier ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (timeStamp))
  {
    Indent (os, indentG);
    os << "timeStamp ";
    os << *timeStamp;
  }
  else
  {
    Indent (os, indentG);
    os << "timeStamp ";
    os << "-- void --";
    os << "," << std::endl;
  }

  if (NOT_NULL (sMS_Contents))
  {
    Indent (os, indentG);
    os << "sMS-Contents ";
    os << *sMS_Contents;
  }
  else
  {
    Indent (os, indentG);
    os << "sMS-Contents ";
    os << "-- void --";
    os << std::endl;
  }

  os << std::endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // SMS_report::Print


AsnType *National_Parameters::Clone() const
{
  return new National_Parameters;
}

AsnLen National_Parameters::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SET_TAG_CODE);
  return l;
}

void National_Parameters::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SET_TAG_CODE))
  {
    Asn1Error << "National_Parameters::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -213);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

National_Parameters::National_Parameters (const National_Parameters &)
{
  Asn1Error << "use of incompletely defined National_Parameters::National_Parameters (const National_Parameters &)" << std::endl;
  abort();
}

National_Parameters::~National_Parameters()
{
  SetCurrToFirst();
  for (; Curr() != NULL; RemoveCurrFromList())
    ;
} // end of destructor

#if SNACC_DEEP_COPY
National_Parameters &National_Parameters::operator = (const National_Parameters &that)
#else // SNACC_DEEP_COPY
National_Parameters &National_Parameters::operator = (const National_Parameters &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    SetCurrToFirst();
    for (; Curr(); RemoveCurrFromList())
      ;

    //that.SetCurrToFirst();
    //for (; that.Curr(); that.GoNext())
    //  AppendCopy (*that.Curr());
    for (const AsnListElmt *run=that.first; run; run=run->next)
      AppendCopy (*run->elmt);
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined National_Parameters &National_Parameters::operator = (const National_Parameters &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

void National_Parameters::Print (std::ostream &os) const
{
    os << "{ -- SEQUENCE/SET OF -- " << std::endl;
    indentG += stdIndentG;
    //SetCurrToFirst();
    //for (; Curr() != NULL; GoNext())
    for (const AsnListElmt *run=first; run; run=run->next)
    {
        Indent (os, indentG);
        //os << *Curr();
        os << *run->elmt;
        //if (Curr() != Last())
        if (run != last)
            os << ",";
        os << std::endl;
    }
    indentG -= stdIndentG;
    Indent (os, indentG);
    os << "}\n";
} // Print


void  National_Parameters::SetCurrElmt (unsigned long int index)
{
  unsigned long int i;
  curr = first;
  if (count)
    for (i = 0; (i < (count-1)) && (i < index); i++)
      curr = curr->next;
} // National_Parameters::SetCurrElmt


unsigned long int  National_Parameters::GetCurrElmtIndex()
{
    unsigned long int i;
    AsnListElmt *tmp;
    if (curr != NULL)
    {
        for (i = 0, tmp = first; tmp != NULL; i++)
        {
            if (tmp == curr)
                return i;
            else
                tmp = tmp->next;
        }
    }
    return count;
} // National_Parameters::GetCurrElmtIndex


// alloc new list elmt, put at end of list
//  and return the component type
AsnOcts *National_Parameters::Append()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt  = new AsnOcts;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // National_Parameters::Append



// alloc new list elmt, put at begining of list
//  and return the component type
AsnOcts  *National_Parameters::Prepend()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // National_Parameters::Prepend


// alloc new list elmt, insert it before the
// current element and return the component type
// if the current element is null, the new element
// is placed at the beginning of the list.
AsnOcts  *National_Parameters::InsertBefore()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // National_Parameters::InsertBefore


// alloc new list elmt, insert it after the
// current element and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
AsnOcts *National_Parameters::InsertAfter()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // National_Parameters::InsertAfter


National_Parameters  &National_Parameters::AppendCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return *this;
} // AppendCopy


National_Parameters  &National_Parameters::PrependCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return *this;
} // National_Parameters::PrependCopy


// alloc new list elmt, insert it before the
// current element, copy the given elmt into the new elmt
// and return the component type.
// if the current element is null, the new element
// is placed at the beginning of the list.
National_Parameters &National_Parameters::InsertBeforeAndCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;

    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return *this;
} // National_Parameters::InsertBeforeAndCopy


// alloc new list elmt, insert it after the
// current element, copy given elmt in to new elmt
//  and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
National_Parameters  &National_Parameters::InsertAfterAndCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return *this;
} // National_Parameters::InsertAfterAndCopy


// remove current element from list if current element is not NULL
// The new current element will be the next element.
// If the current element is the last element in the list
// the second but last element will become the new current element.
void National_Parameters::RemoveCurrFromList()
{
    AsnListElmt *del_elmt;

    if (curr != NULL)
    {
        del_elmt = curr;
        count--;

        if (count == 0)
            first = last = curr = NULL;
        else if (curr == first)
        {
            curr = first= first->next;
            first->prev = NULL;
        }
        else if (curr == last)
        {
            curr = last = last->prev;
            last->next = NULL;
        }
        else
        {
            curr->prev->next = curr->next;
            curr->next->prev = curr->prev;
        }

        delete del_elmt->elmt;
        delete del_elmt;
    }
}


AsnLen National_Parameters::BEncContent (BUF_TYPE b)
{
    AsnListElmt *currElmt;
    AsnLen elmtLen;
    AsnLen totalLen = 0;
    for (currElmt = last; currElmt != NULL; currElmt = currElmt->prev)
    {
        elmtLen = currElmt->elmt->BEncContent (b);
    elmtLen += BEncDefLen (b, elmtLen);

    elmtLen += BEncTag1 (b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
        totalLen += elmtLen;
    }
    return totalLen;
} // National_Parameters::BEncContent


void  National_Parameters::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0,
                                  AsnLen &bytesDecoded, ENV_TYPE env)
{
    AsnOcts *listElmt;
    AsnTag tag1;
    AsnLen listBytesDecoded = 0;
    AsnLen elmtLen1;

    while ((listBytesDecoded < elmtLen0) || (elmtLen0 == INDEFINITE_LEN))
    {
        tag1 = BDecTag (b, listBytesDecoded, env);
        if ((tag1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
        {
            BDEC_2ND_EOC_OCTET (b, listBytesDecoded, env);
            break;
        }
        if ((tag1 != MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
         && (tag1 != MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
        {
            Asn1Error << "Unexpected Tag" << std::endl;
            longjmp (env, -214);
        }

        elmtLen1 = BDecLen (b, listBytesDecoded, env);
        listElmt = Append();
        listElmt->BDecContent (b, tag1, elmtLen1, listBytesDecoded, env);
    }

    bytesDecoded += listBytesDecoded;
} // National_Parameters::BDecContent


National_HI2_ASN1parameters::National_HI2_ASN1parameters()
{
}

National_HI2_ASN1parameters::National_HI2_ASN1parameters (const National_HI2_ASN1parameters &)
{
  Asn1Error << "use of incompletely defined National_HI2_ASN1parameters::National_HI2_ASN1parameters (const National_HI2_ASN1parameters &)" << std::endl;
  abort();
}

National_HI2_ASN1parameters::~National_HI2_ASN1parameters()
{
}

AsnType *National_HI2_ASN1parameters::Clone() const
{
  return new National_HI2_ASN1parameters;
}

#if SNACC_DEEP_COPY
National_HI2_ASN1parameters &National_HI2_ASN1parameters::operator = (const National_HI2_ASN1parameters &that)
#else // SNACC_DEEP_COPY
National_HI2_ASN1parameters &National_HI2_ASN1parameters::operator = (const National_HI2_ASN1parameters &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    countryCode = that.countryCode;
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined National_HI2_ASN1parameters &National_HI2_ASN1parameters::operator = (const National_HI2_ASN1parameters &)" << std::endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
National_HI2_ASN1parameters::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

    l = countryCode.BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 1);
    totalLen += l;

  return totalLen;
} // National_HI2_ASN1parameters::BEncContent


void National_HI2_ASN1parameters::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    countryCode.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << std::endl;
    longjmp (env, -215);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << std::endl;
    longjmp (env, -216);
  }
  else
    return;
} // National_HI2_ASN1parameters::BDecContent

AsnLen National_HI2_ASN1parameters::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void National_HI2_ASN1parameters::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "National_HI2_ASN1parameters::BDec: ERROR - wrong tag" << std::endl;
    longjmp (env, -217);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int National_HI2_ASN1parameters::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int National_HI2_ASN1parameters::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void National_HI2_ASN1parameters::Print (std::ostream &os) const
{
  os << "{ -- SEQUENCE --" << std::endl;
  indentG += stdIndentG;

  {
    Indent (os, indentG);
    os << "countryCode ";
    os << countryCode;
  }

  os << std::endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // National_HI2_ASN1parameters::Print


