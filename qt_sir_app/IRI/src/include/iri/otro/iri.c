//   NOTE: this is a machine generated file--editing not recommended
//
// IRI.C - class member functions for ASN.1 module IRI
//
//   This file was generated by snacc on Thu Jun 10 13:42:06 2010
//   UBC snacc written by Mike Sample
//   A couple of enhancements made by IBM European Networking Center


#include "asn-incl.h"

#include "ParametersFormat.h"

//------------------------------------------------------------------------------
// class member definitions:

IRI_ParametersSeq::IRI_ParametersSeq()
{
  cCLink1Characteristics = NULL;
  cCLink2Characteristics = NULL;
}

IRI_ParametersSeq::IRI_ParametersSeq (const IRI_ParametersSeq &)
{
  Asn1Error << "use of incompletely defined IRI_ParametersSeq::IRI_ParametersSeq (const IRI_ParametersSeq &)" << endl;
  abort();
}

IRI_ParametersSeq::~IRI_ParametersSeq()
{
  delete cCLink1Characteristics;
  delete cCLink2Characteristics;
}

AsnType *IRI_ParametersSeq::Clone() const
{
  return new IRI_ParametersSeq;
}

#if SNACC_DEEP_COPY
IRI_ParametersSeq &IRI_ParametersSeq::operator = (const IRI_ParametersSeq &that)
#else // SNACC_DEEP_COPY
IRI_ParametersSeq &IRI_ParametersSeq::operator = (const IRI_ParametersSeq &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    if (that.cCLink1Characteristics)
    {
      if (!cCLink1Characteristics)
        cCLink1Characteristics = new CallContentLinkCharacteristics;
      *cCLink1Characteristics = *that.cCLink1Characteristics;
    }
    else
    {
      delete cCLink1Characteristics;
      cCLink1Characteristics = NULL;
    }
    if (that.cCLink2Characteristics)
    {
      if (!cCLink2Characteristics)
        cCLink2Characteristics = new CallContentLinkCharacteristics;
      *cCLink2Characteristics = *that.cCLink2Characteristics;
    }
    else
    {
      delete cCLink2Characteristics;
      cCLink2Characteristics = NULL;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined IRI_ParametersSeq &IRI_ParametersSeq::operator = (const IRI_ParametersSeq &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen IRI_ParametersSeq::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

  if (NOT_NULL (cCLink2Characteristics))
  {
      BEncEocIfNec (b);
    l = cCLink2Characteristics->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 2);
    totalLen += l;
  }

  if (NOT_NULL (cCLink1Characteristics))
  {
      BEncEocIfNec (b);
    l = cCLink1Characteristics->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 1);
    totalLen += l;
  }

  return totalLen;
} // IRI_ParametersSeq::BEncContent


void IRI_ParametersSeq::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  if (elmtLen0 == 0)
    return;
  else
  {
    tag1 = BDecTag (b, seqBytesDecoded, env);

    if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
    {
      BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
      bytesDecoded += seqBytesDecoded;
      return;
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    cCLink1Characteristics = new CallContentLinkCharacteristics;
    cCLink1Characteristics->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    cCLink2Characteristics = new CallContentLinkCharacteristics;
    cCLink2Characteristics->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << endl;
    longjmp (env, -100);
  }
  else
    return;
} // IRI_ParametersSeq::BDecContent

AsnLen IRI_ParametersSeq::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void IRI_ParametersSeq::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "IRI_ParametersSeq::BDec: ERROR - wrong tag" << endl;
    longjmp (env, -101);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int IRI_ParametersSeq::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int IRI_ParametersSeq::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

AsnType *IRI_ParametersSetOf::Clone() const
{
  return new IRI_ParametersSetOf;
}

AsnLen IRI_ParametersSetOf::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SET_TAG_CODE);
  return l;
}

void IRI_ParametersSetOf::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SET_TAG_CODE))
  {
    Asn1Error << "IRI_ParametersSetOf::BDec: ERROR - wrong tag" << endl;
    longjmp (env, -102);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

IRI_ParametersSetOf::IRI_ParametersSetOf (const IRI_ParametersSetOf &)
{
  Asn1Error << "use of incompletely defined IRI_ParametersSetOf::IRI_ParametersSetOf (const IRI_ParametersSetOf &)" << endl;
  abort();
}

IRI_ParametersSetOf::~IRI_ParametersSetOf()
{
  SetCurrToFirst();
  for (; Curr() != NULL; RemoveCurrFromList())
    ;
} // end of destructor

#if SNACC_DEEP_COPY
IRI_ParametersSetOf &IRI_ParametersSetOf::operator = (const IRI_ParametersSetOf &that)
#else // SNACC_DEEP_COPY
IRI_ParametersSetOf &IRI_ParametersSetOf::operator = (const IRI_ParametersSetOf &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    SetCurrToFirst();
    for (; Curr(); RemoveCurrFromList())
      ;

    //that.SetCurrToFirst();
    //for (; that.Curr(); that.GoNext())
    //  AppendCopy (*that.Curr());
    for (const AsnListElmt *run=that.first; run; run=run->next)
      AppendCopy (*run->elmt);
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined IRI_ParametersSetOf &IRI_ParametersSetOf::operator = (const IRI_ParametersSetOf &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

void  IRI_ParametersSetOf::SetCurrElmt (unsigned long int index)
{
  unsigned long int i;
  curr = first;
  if (count)
    for (i = 0; (i < (count-1)) && (i < index); i++)
      curr = curr->next;
} // IRI_ParametersSetOf::SetCurrElmt


unsigned long int  IRI_ParametersSetOf::GetCurrElmtIndex()
{
    unsigned long int i;
    AsnListElmt *tmp;
    if (curr != NULL)
    {
        for (i = 0, tmp = first; tmp != NULL; i++)
        {
            if (tmp == curr)
                return i;
            else
                tmp = tmp->next;
        }
    }
    return count;
} // IRI_ParametersSetOf::GetCurrElmtIndex


// alloc new list elmt, put at end of list
//  and return the component type
PartyInformation *IRI_ParametersSetOf::Append()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt  = new PartyInformation;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // IRI_ParametersSetOf::Append


// alloc new list elmt, put at begining of list
//  and return the component type
PartyInformation  *IRI_ParametersSetOf::Prepend()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new PartyInformation;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // IRI_ParametersSetOf::Prepend


// alloc new list elmt, insert it before the
// current element and return the component type
// if the current element is null, the new element
// is placed at the beginning of the list.
PartyInformation  *IRI_ParametersSetOf::InsertBefore()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new PartyInformation;
    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // IRI_ParametersSetOf::InsertBefore


// alloc new list elmt, insert it after the
// current element and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
PartyInformation *IRI_ParametersSetOf::InsertAfter()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new PartyInformation;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // IRI_ParametersSetOf::InsertAfter


IRI_ParametersSetOf  &IRI_ParametersSetOf::AppendCopy (PartyInformation &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new PartyInformation;
    *newElmt->elmt = elmt;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return *this;
} // AppendCopy


IRI_ParametersSetOf  &IRI_ParametersSetOf::PrependCopy (PartyInformation &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new PartyInformation;
    *newElmt->elmt = elmt;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return *this;
} // IRI_ParametersSetOf::PrependCopy


// alloc new list elmt, insert it before the
// current element, copy the given elmt into the new elmt
// and return the component type.
// if the current element is null, the new element
// is placed at the beginning of the list.
IRI_ParametersSetOf &IRI_ParametersSetOf::InsertBeforeAndCopy (PartyInformation &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new PartyInformation;
    *newElmt->elmt = elmt;

    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return *this;
} // IRI_ParametersSetOf::InsertBeforeAndCopy


// alloc new list elmt, insert it after the
// current element, copy given elmt in to new elmt
//  and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
IRI_ParametersSetOf  &IRI_ParametersSetOf::InsertAfterAndCopy (PartyInformation &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new PartyInformation;
    *newElmt->elmt = elmt;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return *this;
} // IRI_ParametersSetOf::InsertAfterAndCopy


// remove current element from list if current element is not NULL 
// The new current element will be the next element.
// If the current element is the last element in the list
// the second but last element will become the new current element.
void IRI_ParametersSetOf::RemoveCurrFromList()
{
    AsnListElmt *del_elmt;

    if (curr != NULL)
    {
        del_elmt = curr;
        count--;

        if (count == 0)
            first = last = curr = NULL;
        else if (curr == first)
        {
            curr = first= first->next;
            first->prev = NULL;
        }
        else if (curr == last)
        {
            curr = last = last->prev;
            last->next = NULL;
        }
        else
        {
            curr->prev->next = curr->next;
            curr->next->prev = curr->prev;
        }

        delete del_elmt->elmt;
        delete del_elmt;
    }
}


AsnLen IRI_ParametersSetOf::BEncContent (BUF_TYPE b)
{
    AsnListElmt *currElmt;
    AsnLen elmtLen;
    AsnLen totalLen = 0;
    for (currElmt = last; currElmt != NULL; currElmt = currElmt->prev)
    {
      BEncEocIfNec (b);
        elmtLen = currElmt->elmt->BEncContent (b);
    elmtLen += BEncConsLen (b, elmtLen);

    elmtLen += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
        totalLen += elmtLen;
    }
    return totalLen;
} // IRI_ParametersSetOf::BEncContent


void  IRI_ParametersSetOf::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0,
                                  AsnLen &bytesDecoded, ENV_TYPE env)
{
    PartyInformation *listElmt;
    AsnTag tag1;
    AsnLen listBytesDecoded = 0;
    AsnLen elmtLen1;

    while ((listBytesDecoded < elmtLen0) || (elmtLen0 == INDEFINITE_LEN))
    {
        tag1 = BDecTag (b, listBytesDecoded, env);
        if ((tag1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
        {
            BDEC_2ND_EOC_OCTET (b, listBytesDecoded, env);
            break;
        }
        if ((tag1 != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
        {
            Asn1Error << "Unexpected Tag" << endl;
            longjmp (env, -103);
        }

        elmtLen1 = BDecLen (b, listBytesDecoded, env);
        listElmt = Append();
        listElmt->BDecContent (b, tag1, elmtLen1, listBytesDecoded, env);
    }

    bytesDecoded += listBytesDecoded;
} // IRI_ParametersSetOf::BDecContent


IRI_Parameters::IRI_Parameters()
{
  domainID = NULL;
  iRIversion = NULL;
#if TCL
  communicationIdentifier = new CommunicationIdentifier;
#else
  communicationIdentifier = NULL; // incomplete initialization of mandatory element!
#endif // TCL
#if TCL
  timeStamp = new TimeStamp;
#else
  timeStamp = NULL; // incomplete initialization of mandatory element!
#endif // TCL
  intercepted_Call_Direct = NULL;
  intercepted_Call_State = NULL;
  ringingDuration = NULL;
  conversationDuration = NULL;
  locationOfTheTarget = NULL;
  partyInformation = NULL;
  callContentLinkInformation = NULL;
  release_Reason_Of_Intercepted_Call = NULL;
  nature_Of_The_intercepted_call = NULL;
  serverCenterAddress = NULL;
  sMS = NULL;
  cC_Link_Identifier = NULL;
  national_Parameters = NULL;
  gPRSCorrelationNumber = NULL;
  gPRSevent = NULL;
  sgsnAddress = NULL;
  gPRSOperationErrorCode = NULL;
  ggsnAddress = NULL;
  networkIdentifier = NULL;
  sMSOriginatingAddress = NULL;
  sMSTerminatingAddress = NULL;
  sIPMessage = NULL;
  servingSGSN_number = NULL;
  servingSGSN_address = NULL;
  national_HI2_ASN1parameters = NULL;
}

IRI_Parameters::IRI_Parameters (const IRI_Parameters &)
{
  Asn1Error << "use of incompletely defined IRI_Parameters::IRI_Parameters (const IRI_Parameters &)" << endl;
  abort();
}

IRI_Parameters::~IRI_Parameters()
{
  delete domainID;
  delete iRIversion;
  delete communicationIdentifier;
  delete timeStamp;
  delete intercepted_Call_Direct;
  delete intercepted_Call_State;
  delete ringingDuration;
  delete conversationDuration;
  delete locationOfTheTarget;
  delete partyInformation;
  delete callContentLinkInformation;
  delete release_Reason_Of_Intercepted_Call;
  delete nature_Of_The_intercepted_call;
  delete serverCenterAddress;
  delete sMS;
  delete cC_Link_Identifier;
  delete national_Parameters;
  delete gPRSCorrelationNumber;
  delete gPRSevent;
  delete sgsnAddress;
  delete gPRSOperationErrorCode;
  delete ggsnAddress;
  delete networkIdentifier;
  delete sMSOriginatingAddress;
  delete sMSTerminatingAddress;
  delete sIPMessage;
  delete servingSGSN_number;
  delete servingSGSN_address;
  delete national_HI2_ASN1parameters;
}

AsnType *IRI_Parameters::Clone() const
{
  return new IRI_Parameters;
}

#if SNACC_DEEP_COPY
IRI_Parameters &IRI_Parameters::operator = (const IRI_Parameters &that)
#else // SNACC_DEEP_COPY
IRI_Parameters &IRI_Parameters::operator = (const IRI_Parameters &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    if (that.domainID)
    {
      if (!domainID)
        domainID = new AsnOid;
      *domainID = *that.domainID;
    }
    else
    {
      delete domainID;
      domainID = NULL;
    }
    if (that.iRIversion)
    {
      if (!iRIversion)
        iRIversion = new IRI_ParametersEnum;
      *iRIversion = *that.iRIversion;
    }
    else
    {
      delete iRIversion;
      iRIversion = NULL;
    }
    lawfulInterceptionIdentifier = that.lawfulInterceptionIdentifier;
    if (that.communicationIdentifier)
    {
      if (!communicationIdentifier)
        communicationIdentifier = new CommunicationIdentifier;
      *communicationIdentifier = *that.communicationIdentifier;
    }
    else
    {
      delete communicationIdentifier;
      communicationIdentifier = NULL;
    }
    if (that.timeStamp)
    {
      if (!timeStamp)
        timeStamp = new TimeStamp;
      *timeStamp = *that.timeStamp;
    }
    else
    {
      delete timeStamp;
      timeStamp = NULL;
    }
    if (that.intercepted_Call_Direct)
    {
      if (!intercepted_Call_Direct)
        intercepted_Call_Direct = new IRI_ParametersEnum1;
      *intercepted_Call_Direct = *that.intercepted_Call_Direct;
    }
    else
    {
      delete intercepted_Call_Direct;
      intercepted_Call_Direct = NULL;
    }
    if (that.intercepted_Call_State)
    {
      if (!intercepted_Call_State)
        intercepted_Call_State = new Intercepted_Call_State;
      *intercepted_Call_State = *that.intercepted_Call_State;
    }
    else
    {
      delete intercepted_Call_State;
      intercepted_Call_State = NULL;
    }
    if (that.ringingDuration)
    {
      if (!ringingDuration)
        ringingDuration = new AsnOcts;
      *ringingDuration = *that.ringingDuration;
    }
    else
    {
      delete ringingDuration;
      ringingDuration = NULL;
    }
    if (that.conversationDuration)
    {
      if (!conversationDuration)
        conversationDuration = new AsnOcts;
      *conversationDuration = *that.conversationDuration;
    }
    else
    {
      delete conversationDuration;
      conversationDuration = NULL;
    }
    if (that.locationOfTheTarget)
    {
      if (!locationOfTheTarget)
        locationOfTheTarget = new Location;
      *locationOfTheTarget = *that.locationOfTheTarget;
    }
    else
    {
      delete locationOfTheTarget;
      locationOfTheTarget = NULL;
    }
    if (that.partyInformation)
    {
      if (!partyInformation)
        partyInformation = new IRI_ParametersSetOf;
      *partyInformation = *that.partyInformation;
    }
    else
    {
      delete partyInformation;
      partyInformation = NULL;
    }
    if (that.callContentLinkInformation)
    {
      if (!callContentLinkInformation)
        callContentLinkInformation = new IRI_ParametersSeq;
      *callContentLinkInformation = *that.callContentLinkInformation;
    }
    else
    {
      delete callContentLinkInformation;
      callContentLinkInformation = NULL;
    }
    if (that.release_Reason_Of_Intercepted_Call)
    {
      if (!release_Reason_Of_Intercepted_Call)
        release_Reason_Of_Intercepted_Call = new AsnOcts;
      *release_Reason_Of_Intercepted_Call = *that.release_Reason_Of_Intercepted_Call;
    }
    else
    {
      delete release_Reason_Of_Intercepted_Call;
      release_Reason_Of_Intercepted_Call = NULL;
    }
    if (that.nature_Of_The_intercepted_call)
    {
      if (!nature_Of_The_intercepted_call)
        nature_Of_The_intercepted_call = new IRI_ParametersEnum2;
      *nature_Of_The_intercepted_call = *that.nature_Of_The_intercepted_call;
    }
    else
    {
      delete nature_Of_The_intercepted_call;
      nature_Of_The_intercepted_call = NULL;
    }
    if (that.serverCenterAddress)
    {
      if (!serverCenterAddress)
        serverCenterAddress = new PartyInformation;
      *serverCenterAddress = *that.serverCenterAddress;
    }
    else
    {
      delete serverCenterAddress;
      serverCenterAddress = NULL;
    }
    if (that.sMS)
    {
      if (!sMS)
        sMS = new SMS_report;
      *sMS = *that.sMS;
    }
    else
    {
      delete sMS;
      sMS = NULL;
    }
    if (that.cC_Link_Identifier)
    {
      if (!cC_Link_Identifier)
        cC_Link_Identifier = new CC_Link_Identifier;
      *cC_Link_Identifier = *that.cC_Link_Identifier;
    }
    else
    {
      delete cC_Link_Identifier;
      cC_Link_Identifier = NULL;
    }
    if (that.national_Parameters)
    {
      if (!national_Parameters)
        national_Parameters = new National_Parameters;
      *national_Parameters = *that.national_Parameters;
    }
    else
    {
      delete national_Parameters;
      national_Parameters = NULL;
    }
    if (that.gPRSCorrelationNumber)
    {
      if (!gPRSCorrelationNumber)
        gPRSCorrelationNumber = new GPRSCorrelationNumber;
      *gPRSCorrelationNumber = *that.gPRSCorrelationNumber;
    }
    else
    {
      delete gPRSCorrelationNumber;
      gPRSCorrelationNumber = NULL;
    }
    if (that.gPRSevent)
    {
      if (!gPRSevent)
        gPRSevent = new GPRSEvent;
      *gPRSevent = *that.gPRSevent;
    }
    else
    {
      delete gPRSevent;
      gPRSevent = NULL;
    }
    if (that.sgsnAddress)
    {
      if (!sgsnAddress)
        sgsnAddress = new DataNodeAddress;
      *sgsnAddress = *that.sgsnAddress;
    }
    else
    {
      delete sgsnAddress;
      sgsnAddress = NULL;
    }
    if (that.gPRSOperationErrorCode)
    {
      if (!gPRSOperationErrorCode)
        gPRSOperationErrorCode = new GPRSOperationErrorCode;
      *gPRSOperationErrorCode = *that.gPRSOperationErrorCode;
    }
    else
    {
      delete gPRSOperationErrorCode;
      gPRSOperationErrorCode = NULL;
    }
    if (that.ggsnAddress)
    {
      if (!ggsnAddress)
        ggsnAddress = new DataNodeAddress;
      *ggsnAddress = *that.ggsnAddress;
    }
    else
    {
      delete ggsnAddress;
      ggsnAddress = NULL;
    }
    if (that.networkIdentifier)
    {
      if (!networkIdentifier)
        networkIdentifier = new Network_Identifier;
      *networkIdentifier = *that.networkIdentifier;
    }
    else
    {
      delete networkIdentifier;
      networkIdentifier = NULL;
    }
    if (that.sMSOriginatingAddress)
    {
      if (!sMSOriginatingAddress)
        sMSOriginatingAddress = new DataNodeAddress;
      *sMSOriginatingAddress = *that.sMSOriginatingAddress;
    }
    else
    {
      delete sMSOriginatingAddress;
      sMSOriginatingAddress = NULL;
    }
    if (that.sMSTerminatingAddress)
    {
      if (!sMSTerminatingAddress)
        sMSTerminatingAddress = new DataNodeAddress;
      *sMSTerminatingAddress = *that.sMSTerminatingAddress;
    }
    else
    {
      delete sMSTerminatingAddress;
      sMSTerminatingAddress = NULL;
    }
    if (that.sIPMessage)
    {
      if (!sIPMessage)
        sIPMessage = new AsnOcts;
      *sIPMessage = *that.sIPMessage;
    }
    else
    {
      delete sIPMessage;
      sIPMessage = NULL;
    }
    if (that.servingSGSN_number)
    {
      if (!servingSGSN_number)
        servingSGSN_number = new AsnOcts;
      *servingSGSN_number = *that.servingSGSN_number;
    }
    else
    {
      delete servingSGSN_number;
      servingSGSN_number = NULL;
    }
    if (that.servingSGSN_address)
    {
      if (!servingSGSN_address)
        servingSGSN_address = new AsnOcts;
      *servingSGSN_address = *that.servingSGSN_address;
    }
    else
    {
      delete servingSGSN_address;
      servingSGSN_address = NULL;
    }
    if (that.national_HI2_ASN1parameters)
    {
      if (!national_HI2_ASN1parameters)
        national_HI2_ASN1parameters = new National_HI2_ASN1parameters;
      *national_HI2_ASN1parameters = *that.national_HI2_ASN1parameters;
    }
    else
    {
      delete national_HI2_ASN1parameters;
      national_HI2_ASN1parameters = NULL;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined IRI_Parameters &IRI_Parameters::operator = (const IRI_Parameters &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
IRI_Parameters::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

  if (NOT_NULL (national_HI2_ASN1parameters))
  {
      BEncEocIfNec (b);
    l = national_HI2_ASN1parameters->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag3 (b, CNTX, CONS, 255);
    totalLen += l;
  }

  if (NOT_NULL (servingSGSN_address))
  {
    l = servingSGSN_address->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag2 (b, CNTX, PRIM, 32);
    totalLen += l;
  }

  if (NOT_NULL (servingSGSN_number))
  {
    l = servingSGSN_number->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag2 (b, CNTX, PRIM, 31);
    totalLen += l;
  }

  if (NOT_NULL (sIPMessage))
  {
    l = sIPMessage->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 30);
    totalLen += l;
  }

  if (NOT_NULL (sMSTerminatingAddress))
  {
      BEncEocIfNec (b);
    l = sMSTerminatingAddress->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 28);
    totalLen += l;
  }

  if (NOT_NULL (sMSOriginatingAddress))
  {
      BEncEocIfNec (b);
    l = sMSOriginatingAddress->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 27);
    totalLen += l;
  }

  if (NOT_NULL (networkIdentifier))
  {
      BEncEocIfNec (b);
    l = networkIdentifier->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 26);
    totalLen += l;
  }

  if (NOT_NULL (ggsnAddress))
  {
      BEncEocIfNec (b);
    l = ggsnAddress->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 24);
    totalLen += l;
  }

  if (NOT_NULL (gPRSOperationErrorCode))
  {
    l = gPRSOperationErrorCode->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 22);
    totalLen += l;
  }

  if (NOT_NULL (sgsnAddress))
  {
      BEncEocIfNec (b);
    l = sgsnAddress->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 21);
    totalLen += l;
  }

  if (NOT_NULL (gPRSevent))
  {
    l = gPRSevent->BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, CNTX, PRIM, 20);
    totalLen += l;
  }

  if (NOT_NULL (gPRSCorrelationNumber))
  {
    l = gPRSCorrelationNumber->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 18);
    totalLen += l;
  }

  if (NOT_NULL (national_Parameters))
  {
      BEncEocIfNec (b);
    l = national_Parameters->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 16);
    totalLen += l;
  }

  if (NOT_NULL (cC_Link_Identifier))
  {
    l = cC_Link_Identifier->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 15);
    totalLen += l;
  }

  if (NOT_NULL (sMS))
  {
      BEncEocIfNec (b);
    l = sMS->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 14);
    totalLen += l;
  }

  if (NOT_NULL (serverCenterAddress))
  {
      BEncEocIfNec (b);
    l = serverCenterAddress->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 13);
    totalLen += l;
  }

  if (NOT_NULL (nature_Of_The_intercepted_call))
  {
    l = nature_Of_The_intercepted_call->BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, CNTX, PRIM, 12);
    totalLen += l;
  }

  if (NOT_NULL (release_Reason_Of_Intercepted_Call))
  {
    l = release_Reason_Of_Intercepted_Call->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 11);
    totalLen += l;
  }

  if (NOT_NULL (callContentLinkInformation))
  {
      BEncEocIfNec (b);
    l = callContentLinkInformation->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 10);
    totalLen += l;
  }

  if (NOT_NULL (partyInformation))
  {
      BEncEocIfNec (b);
    l = partyInformation->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 9);
    totalLen += l;
  }

  if (NOT_NULL (locationOfTheTarget))
  {
      BEncEocIfNec (b);
    l = locationOfTheTarget->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 8);
    totalLen += l;
  }

  if (NOT_NULL (conversationDuration))
  {
    l = conversationDuration->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 7);
    totalLen += l;
  }

  if (NOT_NULL (ringingDuration))
  {
    l = ringingDuration->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 6);
    totalLen += l;
  }

  if (NOT_NULL (intercepted_Call_State))
  {
    l = intercepted_Call_State->BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, CNTX, PRIM, 5);
    totalLen += l;
  }

  if (NOT_NULL (intercepted_Call_Direct))
  {
    l = intercepted_Call_Direct->BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, CNTX, PRIM, 4);
    totalLen += l;
  }

      BEncEocIfNec (b);
    l = timeStamp->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 3);
    totalLen += l;

      BEncEocIfNec (b);
    l = communicationIdentifier->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 2);
    totalLen += l;

    l = lawfulInterceptionIdentifier.BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 1);
    totalLen += l;

  if (NOT_NULL (iRIversion))
  {
    l = iRIversion->BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, CNTX, PRIM, 23);
    totalLen += l;
  }

  if (NOT_NULL (domainID))
  {
    l = domainID->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 0);
    totalLen += l;
  }

  return totalLen;
} // IRI_Parameters::BEncContent


void IRI_Parameters::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  AsnLen elmtLen2;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    domainID = new AsnOid;
    domainID->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 23)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    iRIversion = new IRI_ParametersEnum;
    iRIversion->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    lawfulInterceptionIdentifier.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -104);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    communicationIdentifier = new CommunicationIdentifier;
    communicationIdentifier->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -105);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 3)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
    elmtLen2 = BDecLen (b, seqBytesDecoded, env);
    timeStamp = new TimeStamp;
    timeStamp->BDecContent (b, tag1, elmtLen2, seqBytesDecoded, env);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (b, seqBytesDecoded, env);

    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -106);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    intercepted_Call_Direct = new IRI_ParametersEnum1;
    intercepted_Call_Direct->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 5)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    intercepted_Call_State = new Intercepted_Call_State;
    intercepted_Call_State->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 6))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 6)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    ringingDuration = new AsnOcts;
    ringingDuration->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 7))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 7)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    conversationDuration = new AsnOcts;
    conversationDuration->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 8)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    locationOfTheTarget = new Location;
    locationOfTheTarget->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 9)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    partyInformation = new IRI_ParametersSetOf;
    partyInformation->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 10)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    callContentLinkInformation = new IRI_ParametersSeq;
    callContentLinkInformation->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 11))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 11)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    release_Reason_Of_Intercepted_Call = new AsnOcts;
    release_Reason_Of_Intercepted_Call->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 12)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    nature_Of_The_intercepted_call = new IRI_ParametersEnum2;
    nature_Of_The_intercepted_call->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 13)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    serverCenterAddress = new PartyInformation;
    serverCenterAddress->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 14)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    sMS = new SMS_report;
    sMS->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 15))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 15)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    cC_Link_Identifier = new CC_Link_Identifier;
    cC_Link_Identifier->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 16)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    national_Parameters = new National_Parameters;
    national_Parameters->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 18))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 18)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    gPRSCorrelationNumber = new GPRSCorrelationNumber;
    gPRSCorrelationNumber->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 20)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    gPRSevent = new GPRSEvent;
    gPRSevent->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 21)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
    elmtLen2 = BDecLen (b, seqBytesDecoded, env);
    sgsnAddress = new DataNodeAddress;
    sgsnAddress->BDecContent (b, tag1, elmtLen2, seqBytesDecoded, env);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (b, seqBytesDecoded, env);

    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 22))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 22)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    gPRSOperationErrorCode = new GPRSOperationErrorCode;
    gPRSOperationErrorCode->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 24)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
    elmtLen2 = BDecLen (b, seqBytesDecoded, env);
    ggsnAddress = new DataNodeAddress;
    ggsnAddress->BDecContent (b, tag1, elmtLen2, seqBytesDecoded, env);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (b, seqBytesDecoded, env);

    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 26)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    networkIdentifier = new Network_Identifier;
    networkIdentifier->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 27)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
    elmtLen2 = BDecLen (b, seqBytesDecoded, env);
    sMSOriginatingAddress = new DataNodeAddress;
    sMSOriginatingAddress->BDecContent (b, tag1, elmtLen2, seqBytesDecoded, env);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (b, seqBytesDecoded, env);

    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 28)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
    elmtLen2 = BDecLen (b, seqBytesDecoded, env);
    sMSTerminatingAddress = new DataNodeAddress;
    sMSTerminatingAddress->BDecContent (b, tag1, elmtLen2, seqBytesDecoded, env);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (b, seqBytesDecoded, env);

    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 30))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 30)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    sIPMessage = new AsnOcts;
    sIPMessage->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 31))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 31)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    servingSGSN_number = new AsnOcts;
    servingSGSN_number->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 32))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 32)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    servingSGSN_address = new AsnOcts;
    servingSGSN_address->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 255)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    national_HI2_ASN1parameters = new National_HI2_ASN1parameters;
    national_HI2_ASN1parameters->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << endl;
    longjmp (env, -107);
  }
  else
    return;
} // IRI_Parameters::BDecContent

AsnLen IRI_Parameters::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void IRI_Parameters::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "IRI_Parameters::BDec: ERROR - wrong tag" << endl;
    longjmp (env, -108);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int IRI_Parameters::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int IRI_Parameters::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

IRIContent::IRIContent()
{
  choiceId = iRI_Begin_recordCid;
#if TCL
  iRI_Begin_record = new IRI_Parameters;
#else
  iRI_Begin_record = NULL; // incomplete initialization of mandatory element!
#endif // TCL
}

IRIContent::IRIContent (const IRIContent &)
{
  Asn1Error << "use of incompletely defined IRIContent::IRIContent (const IRIContent &)" << endl;
  abort();
}

IRIContent::~IRIContent()
{
  switch (choiceId)
  {
    case iRI_Begin_recordCid:
      delete iRI_Begin_record;
      break;
    case iRI_End_recordCid:
      delete iRI_End_record;
      break;
    case iRI_Continue_recordCid:
      delete iRI_Continue_record;
      break;
    case iRI_Report_recordCid:
      delete iRI_Report_record;
      break;
  } // end of switch
} // end of destructor

AsnType *IRIContent::Clone() const
{
  return new IRIContent;
}

#if SNACC_DEEP_COPY
IRIContent &IRIContent::operator = (const IRIContent &that)
#else // SNACC_DEEP_COPY
IRIContent &IRIContent::operator = (const IRIContent &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    switch (choiceId)
    {
      case iRI_Begin_recordCid:
        delete iRI_Begin_record;
        break;
      case iRI_End_recordCid:
        delete iRI_End_record;
        break;
      case iRI_Continue_recordCid:
        delete iRI_Continue_record;
        break;
      case iRI_Report_recordCid:
        delete iRI_Report_record;
        break;
    }
    switch (choiceId = that.choiceId)
    {
      case iRI_Begin_recordCid:
        iRI_Begin_record = new IRI_Parameters;
        *iRI_Begin_record = *that.iRI_Begin_record;
        break;
      case iRI_End_recordCid:
        iRI_End_record = new IRI_Parameters;
        *iRI_End_record = *that.iRI_End_record;
        break;
      case iRI_Continue_recordCid:
        iRI_Continue_record = new IRI_Parameters;
        *iRI_Continue_record = *that.iRI_Continue_record;
        break;
      case iRI_Report_recordCid:
        iRI_Report_record = new IRI_Parameters;
        *iRI_Report_record = *that.iRI_Report_record;
        break;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined IRIContent &IRIContent::operator = (const IRIContent &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen IRIContent::BEncContent (BUF_TYPE b)
{
  AsnLen l;
  switch (choiceId)
  {
    case iRI_Begin_recordCid:
      BEncEocIfNec (b);
      l = iRI_Begin_record->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 1);
      break;

    case iRI_End_recordCid:
      BEncEocIfNec (b);
      l = iRI_End_record->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 2);
      break;

    case iRI_Continue_recordCid:
      BEncEocIfNec (b);
      l = iRI_Continue_record->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 3);
      break;

    case iRI_Report_recordCid:
      BEncEocIfNec (b);
      l = iRI_Report_record->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 4);
      break;

  } // end switch
  return l;
} // IRIContent::BEncContent


void IRIContent::BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  switch (tag)
  {
    case MAKE_TAG_ID (CNTX, CONS, 1):
      choiceId = iRI_Begin_recordCid;
      iRI_Begin_record = new IRI_Parameters;
        iRI_Begin_record->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, CONS, 2):
      choiceId = iRI_End_recordCid;
      iRI_End_record = new IRI_Parameters;
        iRI_End_record->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, CONS, 3):
      choiceId = iRI_Continue_recordCid;
      iRI_Continue_record = new IRI_Parameters;
        iRI_Continue_record->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, CONS, 4):
      choiceId = iRI_Report_recordCid;
      iRI_Report_record = new IRI_Parameters;
        iRI_Report_record->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    default:
      Asn1Error << "ERROR - unexpected tag in CHOICE" << endl;
      longjmp (env, -109);
      break;
  } // end switch
} // IRIContent::BDecContent


AsnLen IRIContent::BEnc (BUF_TYPE b)
{
    AsnLen l;
    l = BEncContent (b);
    return l;
}

void IRIContent::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
    AsnLen elmtLen;
    AsnTag tag;

    /*  CHOICEs are a special case - grab identifying tag */
    /*  this allows easier handling of nested CHOICEs */
    tag = BDecTag (b, bytesDecoded, env);
    elmtLen = BDecLen (b, bytesDecoded, env);
    BDecContent (b, tag, elmtLen, bytesDecoded, env);
}

int IRIContent::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int IRIContent::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

AsnType *IRISequence::Clone() const
{
  return new IRISequence;
}

AsnLen IRISequence::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void IRISequence::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "IRISequence::BDec: ERROR - wrong tag" << endl;
    longjmp (env, -110);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

IRISequence::IRISequence (const IRISequence &)
{
  Asn1Error << "use of incompletely defined IRISequence::IRISequence (const IRISequence &)" << endl;
  abort();
}

IRISequence::~IRISequence()
{
  SetCurrToFirst();
  for (; Curr() != NULL; RemoveCurrFromList())
    ;
} // end of destructor

#if SNACC_DEEP_COPY
IRISequence &IRISequence::operator = (const IRISequence &that)
#else // SNACC_DEEP_COPY
IRISequence &IRISequence::operator = (const IRISequence &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    SetCurrToFirst();
    for (; Curr(); RemoveCurrFromList())
      ;

    //that.SetCurrToFirst();
    //for (; that.Curr(); that.GoNext())
    //  AppendCopy (*that.Curr());
    for (const AsnListElmt *run=that.first; run; run=run->next)
      AppendCopy (*run->elmt);
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined IRISequence &IRISequence::operator = (const IRISequence &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

void  IRISequence::SetCurrElmt (unsigned long int index)
{
  unsigned long int i;
  curr = first;
  if (count)
    for (i = 0; (i < (count-1)) && (i < index); i++)
      curr = curr->next;
} // IRISequence::SetCurrElmt


unsigned long int  IRISequence::GetCurrElmtIndex()
{
    unsigned long int i;
    AsnListElmt *tmp;
    if (curr != NULL)
    {
        for (i = 0, tmp = first; tmp != NULL; i++)
        {
            if (tmp == curr)
                return i;
            else
                tmp = tmp->next;
        }
    }
    return count;
} // IRISequence::GetCurrElmtIndex


// alloc new list elmt, put at end of list
//  and return the component type
IRIContent *IRISequence::Append()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt  = new IRIContent;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // IRISequence::Append


// alloc new list elmt, put at begining of list
//  and return the component type
IRIContent  *IRISequence::Prepend()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new IRIContent;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // IRISequence::Prepend


// alloc new list elmt, insert it before the
// current element and return the component type
// if the current element is null, the new element
// is placed at the beginning of the list.
IRIContent  *IRISequence::InsertBefore()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new IRIContent;
    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // IRISequence::InsertBefore


// alloc new list elmt, insert it after the
// current element and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
IRIContent *IRISequence::InsertAfter()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new IRIContent;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // IRISequence::InsertAfter

//---------------------------------------------------------------------------------------------------------
IRIContent::IRIContent( IRIContent::ChoiceIdEnum choiceId)
{
    this->choiceId = choiceId;
    switch( this->choiceId )
    {
        case iRI_Begin_recordCid:
        {
          break;
        }
    case iRI_Continue_recordCid:
        {
          break;
      }
    case iRI_End_recordCid:
        {
          break;
      }
    case iRI_Report_recordCid:
        {

      }
    }

//iRIContent =  new IRIsChoice(choiceId);// crea un iri en dependencia del tipo o sea un iri begin o end o content
    //current_IRI_parameter = iRIContent->current_IRI_parameter;
}
//---------------------------------------------------------------------------------------------------------



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Metodos para cambiar los datos de un IRI

void IRIContent::CreateLawfulInterceptionIdentifier(char *lawfulInterceptionIdentifier, int len)
{
    current_IRI_parameter->lawfulInterceptionIdentifier.Set(lawfulInterceptionIdentifier,len);
}

//************Struct communicationIdentifier***************************
void IRIContent::CreateCommunicationIdentifierIdentityNumber(const char *communicationIdentityNumber)
{
    current_IRI_parameter->communicationIdentifier->communication_Identity_Number = new AsnOcts(communicationIdentityNumber);
}
void IRIContent::CreateCommunicationIdentifierNetworkIdentifierOperatorIdentifier(const char *networkOperatorIdentifier)
{
    current_IRI_parameter->communicationIdentifier->network_Identifier->operator_Identifier= networkOperatorIdentifier;//NO S
}
//enum ChoiceIdEnum{ e164_FormatCid, x25_FormatCid, iP_FormatCid, dNS_FormatCid, iP_AddressCid};
void IRIContent::CreateCommunicationIdentifierNetworkIdentifierNetworkElementIdentifier(Network_Element_Identifier::ChoiceIdEnum typeOfElement, const char *str)
{
    current_IRI_parameter->communicationIdentifier->network_Identifier->network_Element_Identifier = new Network_Element_Identifier(typeOfElement, str);
}
void IRIContent::CreateCommunicationIdentifierNetworkIdentifierNetworkElementIdentifier(Network_Element_Identifier::ChoiceIdEnum typeOfElement, IPAddressEnum ip_type,IP_value::ChoiceIdEnum choiceIpTypeValue, const char *str )
{
    current_IRI_parameter->communicationIdentifier->network_Identifier->network_Element_Identifier = new Network_Element_Identifier(typeOfElement, ip_type, choiceIpTypeValue, str);
}
void IRIContent::CreateCommunicationIdentifierNetworkIdentifierNetworkElementIdentifier(Network_Element_Identifier::ChoiceIdEnum typeOfElement, IPAddressEnum ip_type,IP_value::ChoiceIdEnum choiceIpTypeValue, const char *str, IPAddressEnum1 choiceIpAssignment )
{
    current_IRI_parameter->communicationIdentifier->network_Identifier->network_Element_Identifier = new Network_Element_Identifier(typeOfElement, ip_type, choiceIpTypeValue, str, choiceIpAssignment);
}


//***************Struct TimeStamp**********************
void IRIContent::CreateTimeStampUtcTime(const char *utcTimeStr)
{
    current_IRI_parameter->timeStamp = new TimeStamp(utcTimeStr);
}
void IRIContent::CreateTimeStampLocalTime(const char *generalizedTimeStr, LocalTimeStampEnum  winterSummerIndication)
{
    current_IRI_parameter->timeStamp = new TimeStamp(generalizedTimeStr, winterSummerIndication);
}


//************InterceptedCallDirect*****************
//IRI_ParametersEnum1 enum{not_Available, originating_Target, terminating_Target};
void IRIContent::CreateInterceptedCallDirect( IRI_ParametersEnum1 intercepted_Call_Direct)
{
    current_IRI_parameter->intercepted_Call_Direct = new IRI_ParametersEnum1(intercepted_Call_Direct);
}

//************Intercepted_Call_State***************
void IRIContent::CreateInterceptedCallState(Intercepted_Call_State intercepted_Call_State)
{
    current_IRI_parameter->intercepted_Call_State = new Intercepted_Call_State(intercepted_Call_State);
}

//************RingingDuration***************
void IRIContent::CreateRingingDuration(const char *ringingDuration)
{
    current_IRI_parameter->ringingDuration = new AsnOcts;
    current_IRI_parameter->ringingDuration->Set(ringingDuration);
}

//ConversationDuration
void IRIContent::CreateConversationDuration(const char*conversationDuration)
{
    current_IRI_parameter->conversationDuration = new AsnOcts;
    current_IRI_parameter->conversationDuration->Set(conversationDuration);
}

//***************Struct Location*************
void IRIContent::CreateLocationE164_Number(const char *e164_Number)
{
    CreateLocation();
    current_IRI_parameter->locationOfTheTarget->e164_Number = new AsnOcts;
    current_IRI_parameter->locationOfTheTarget->e164_Number->Set(e164_Number);
}
void IRIContent::CreateLocationGlobalCellID(const char *globalCellID)
{
    CreateLocation();
    current_IRI_parameter->locationOfTheTarget->globalCellID = new AsnOcts;
    current_IRI_parameter->locationOfTheTarget->globalCellID->Set(globalCellID);
}

//function of Struct TetraLocation of Location
void IRIContent::CreateLocationTetraLocation(int pls_loc)
{
    CreateLocation();
    current_IRI_parameter->locationOfTheTarget->tetraLocation = new TetraLocation(pls_loc);
}

void IRIContent::CreateLocationTetraLocation(unsigned int mcc, unsigned int mnc, unsigned int lai)
{
    CreateLocation();
    current_IRI_parameter->locationOfTheTarget->tetraLocation = new TetraLocation(mcc,mnc,lai);
}
void IRIContent::CreateLocationTetraLocation(unsigned int mcc, unsigned int mnc, unsigned int lai, int ci)
{
    CreateLocation();
    current_IRI_parameter->locationOfTheTarget->tetraLocation = new TetraLocation(mcc,mnc,lai, ci);
}

//function for  set RAI of Location
void IRIContent::CreateLocationRAI(const char *rAI)
{
    CreateLocation();
    current_IRI_parameter->locationOfTheTarget->rAI = new AsnOcts;
    current_IRI_parameter->locationOfTheTarget->rAI->Set(rAI);
}
//Struct GSMLocation of Location
void IRIContent::CreateGSMLocationGeoCoordinates(const char *platitude,const char *plongitude, MapDatum  pmapDatum)
{
    CreateGSMLocation();
    current_IRI_parameter->locationOfTheTarget->gsmLocation->CreateGeoCoordinates(platitude,plongitude,pmapDatum);
}
void IRIContent::CreateGSMLocationGeoCoordinates(const char *platitude,const char *plongitude,  unsigned int pazimuth, MapDatum  pmapDatum)
{
    CreateGSMLocation();
    current_IRI_parameter->locationOfTheTarget->gsmLocation->CreateGeoCoordinates(platitude,plongitude, pazimuth, pmapDatum);
}
void IRIContent::CreateGSMLocationUtmCoordinates(const char *putm_East,const char *putm_North, MapDatum  pmapDatum)
{
    CreateGSMLocation();
    current_IRI_parameter->locationOfTheTarget->gsmLocation->CreateUtmCoordinates(putm_East, putm_North, pmapDatum);
}
void IRIContent::CreateGSMLocationUtmCoordinates(const char *putm_East,const char *putm_North, unsigned int pazimuth, MapDatum  pmapDatum)
{
    CreateGSMLocation();
    current_IRI_parameter->locationOfTheTarget->gsmLocation->CreateUtmCoordinates(putm_East, putm_North, pazimuth, pmapDatum);
}
void IRIContent::CreateGSMLocationUtmRefCoordinates(const char *putmref_string,MapDatum  pmapDatum)
{
    CreateGSMLocation();
    current_IRI_parameter->locationOfTheTarget->gsmLocation->CreateUtmRefCoordinates(putmref_string,pmapDatum);
}
void IRIContent::CreateGSMLocationWGS84Coordinates( const char *pwGS84Coordinates)
{
    CreateGSMLocation();
    current_IRI_parameter->locationOfTheTarget->gsmLocation->CreateWGS84Coordinates(pwGS84Coordinates);
}


//Struct UMTSLocation of Location
void IRIContent::CreateUMTSLocationPoint(GeographicalCoordinatesEnum platitudeSign,int platitude, int plongitude)
{
    CreateLocation();
    current_IRI_parameter->locationOfTheTarget->umtsLocation = new UMTSLocation(platitudeSign, platitude, plongitude);
}
void IRIContent::CreateUMTSLocationPointWithUnCertainty(GeographicalCoordinatesEnum platitudeSign,int platitude, int plongitude,unsigned int puncertaintyCode)
{
    CreateLocation();
    current_IRI_parameter->locationOfTheTarget->umtsLocation = new UMTSLocation(platitudeSign, platitude, plongitude, puncertaintyCode);
}
void IRIContent::AddUMTSLocationPointToPolygon(GeographicalCoordinatesEnum platitudeSign,int platitude, int plongitude)
{
    CreateLocation();
    if (current_IRI_parameter->locationOfTheTarget->umtsLocation == NULL )
        current_IRI_parameter->locationOfTheTarget->umtsLocation = new UMTSLocation;
    current_IRI_parameter->locationOfTheTarget->umtsLocation->polygon->Append(platitudeSign, platitude, plongitude);
}


//Sai location
void IRIContent::CreateLocationSAI(const char *sAI )
{
    CreateLocation();
    current_IRI_parameter->locationOfTheTarget->sAI = new AsnOcts;
    current_IRI_parameter->locationOfTheTarget->sAI->Set(sAI);
}

//*************Struct PartyInformation
PartyInformation*  IRIContent::AddPartyInformation()
{
    if ( current_IRI_parameter->partyInformation == NULL )
        current_IRI_parameter->partyInformation = new IRI_ParametersSetOf;

    return current_IRI_parameter->partyInformation->Append();
}

//**************CallContentLinkInformation
void IRIContent::CreateCallContentLinkInformation()
{
    if( current_IRI_parameter->callContentLinkInformation == NULL )
        current_IRI_parameter->callContentLinkInformation = new IRI_ParametersSeq;
}
void IRIContent::CreateCallContentLinkInformationCCLink1Characteristics()
{
    CreateCallContentLinkInformation();
    if( current_IRI_parameter->callContentLinkInformation->cCLink1Characteristics == NULL )
        current_IRI_parameter->callContentLinkInformation->cCLink1Characteristics = new CallContentLinkCharacteristics;
}
void IRIContent::CreateCallContentLinkInformationCCLink1CharacteristicsCCLinkState(CCLink_State pcCLink_State)
{
    CreateCallContentLinkInformationCCLink1Characteristics();
    current_IRI_parameter->callContentLinkInformation->cCLink1Characteristics->cCLink_State = new CCLink_State(pcCLink_State);
}
void IRIContent::CreateCallContentLinkInformationCCLink1CharacteristicsRelease_Time(const char *utcTimeStr)
{
    CreateCallContentLinkInformationCCLink1Characteristics();
    current_IRI_parameter->callContentLinkInformation->cCLink1Characteristics->release_Time = new TimeStamp(utcTimeStr);
}
void IRIContent::CreateCallContentLinkInformationCCLink1CharacteristicsRelease_Time(const char*generalizedTimeStr,LocalTimeStampEnum  pwinterSummerIndication)
{
    CreateCallContentLinkInformationCCLink1Characteristics();
    current_IRI_parameter->callContentLinkInformation->cCLink1Characteristics->release_Time = new TimeStamp(generalizedTimeStr, pwinterSummerIndication);
}
void IRIContent::CreateCallContentLinkInformationCCLink1CharacteristicsRelease_Reason(const char *release_Reason)
{
    CreateCallContentLinkInformationCCLink1Characteristics();
    current_IRI_parameter->callContentLinkInformation->cCLink1Characteristics->release_Reason = new AsnOcts(release_Reason);
}
void IRIContent::CreateCallContentLinkInformationCCLink1CharacteristicsLEMF_Address(CalledPartyNumber::ChoiceIdEnum pchoiceId, const char *number)
{
    CreateCallContentLinkInformationCCLink1Characteristics();
    int longitud=7;
    current_IRI_parameter->callContentLinkInformation->cCLink1Characteristics->lEMF_Address = new CalledPartyNumber(pchoiceId, number,longitud);
}

void IRIContent::CreateCallContentLinkInformationCCLink2Characteristics()
{
    CreateCallContentLinkInformation();
    if( current_IRI_parameter->callContentLinkInformation->cCLink2Characteristics == NULL )
        current_IRI_parameter->callContentLinkInformation->cCLink2Characteristics = new CallContentLinkCharacteristics;
}
void IRIContent::CreateCallContentLinkInformationCCLink2CharacteristicsCCLinkState(CCLink_State pcCLink_State)
{
    CreateCallContentLinkInformationCCLink2Characteristics();
    current_IRI_parameter->callContentLinkInformation->cCLink2Characteristics->cCLink_State = new CCLink_State(pcCLink_State);
}
void IRIContent::CreateCallContentLinkInformationCCLink2CharacteristicsRelease_Time(const char *utcTimeStr)
{
    CreateCallContentLinkInformationCCLink2Characteristics();
    current_IRI_parameter->callContentLinkInformation->cCLink2Characteristics->release_Time = new TimeStamp(utcTimeStr);
}
void IRIContent::CreateCallContentLinkInformationCCLink2CharacteristicsRelease_Time(const char*generalizedTimeStr,LocalTimeStampEnum  pwinterSummerIndication)
{
    CreateCallContentLinkInformationCCLink2Characteristics();
    current_IRI_parameter->callContentLinkInformation->cCLink2Characteristics->release_Time = new TimeStamp(generalizedTimeStr, pwinterSummerIndication);
}
void IRIContent::CreateCallContentLinkInformationCCLink2CharacteristicsRelease_Reason(const char *release_Reason)
{
    CreateCallContentLinkInformationCCLink2Characteristics();
    current_IRI_parameter->callContentLinkInformation->cCLink2Characteristics->release_Reason = new AsnOcts(release_Reason);
}
void IRIContent::CreateCallContentLinkInformationCCLink2CharacteristicsLEMF_Address(CalledPartyNumber::ChoiceIdEnum pchoiceId, const char *number)
{
    CreateCallContentLinkInformationCCLink2Characteristics();
    int longitud;
    current_IRI_parameter->callContentLinkInformation->cCLink2Characteristics->lEMF_Address = new CalledPartyNumber(pchoiceId, number,longitud);
}

//release_Reason_Of_Intercepted_Call
void IRIContent::CreateReleaseReasonOfInterceptedCall(const char *releaseReason)
{
    current_IRI_parameter->release_Reason_Of_Intercepted_Call = new AsnOcts;
    current_IRI_parameter->release_Reason_Of_Intercepted_Call->Set(releaseReason);
}

//NatureOfTheInterceptedCall
/*enum IRI_ParametersEnum2 {
                            gSM_ISDN_PSTN_circuit_call, gSM_SMS_Message, uUS4_Messages,
                            tETRA_circuit_call, teTRA_Packet_Data, gPRS_Packet_Data,
                            uMTS_circuit_call
                            };
*/
void IRIContent::CreateNatureOfTheInterceptedCall(IRI_ParametersEnum2 natureOfTheInterceptedCall)
{
    current_IRI_parameter->nature_Of_The_intercepted_call = new IRI_ParametersEnum2(natureOfTheInterceptedCall);
}

//ServerCenterAddress
PartyInformation* IRIContent::CreateServerCenterAddress()
{
    current_IRI_parameter->serverCenterAddress = new PartyInformation;
    return current_IRI_parameter->serverCenterAddress;
}

//SMSReport
void IRIContent::CreateSMSReport()
{
    if( current_IRI_parameter->sMS == NULL)
        current_IRI_parameter->sMS = new SMS_report;
}
    //Struct CommunicationIdentifier of SMSReport
void IRIContent::CreateSMSReportCommunicationIdentityNumber(const char *identityNumber)
{
    CreateSMSReport();
    current_IRI_parameter->sMS->communicationIdentifier->communication_Identity_Number = new AsnOcts;
    current_IRI_parameter->sMS->communicationIdentifier->communication_Identity_Number->Set(identityNumber);
}
void IRIContent::SetSMSReportNetworkOperatorIdentifier(const char *operatorIdentifier)
{
    CreateSMSReport();
    current_IRI_parameter->sMS->communicationIdentifier->network_Identifier->operator_Identifier.Set(operatorIdentifier);
}
void IRIContent::CreateSMSReportNetworkElementIdentifier(Network_Element_Identifier::ChoiceIdEnum typeOfElement, const char *str)
{
    CreateSMSReport();
    current_IRI_parameter->sMS->communicationIdentifier->network_Identifier->network_Element_Identifier = new Network_Element_Identifier(typeOfElement,str);
}
void IRIContent::CreateSMSReportNetworkElementIdentifier(Network_Element_Identifier::ChoiceIdEnum typeOfElement, IPAddressEnum ip_type, IP_value::ChoiceIdEnum choiceIpTypeValue, const char *str )
{
    CreateSMSReport();
    current_IRI_parameter->sMS->communicationIdentifier->network_Identifier->network_Element_Identifier = new Network_Element_Identifier(typeOfElement,ip_type, choiceIpTypeValue, str);
}
void IRIContent::CreateSMSReportNetworkElementIdentifier(Network_Element_Identifier::ChoiceIdEnum typeOfElement, IPAddressEnum ip_type, IP_value::ChoiceIdEnum choiceIpTypeValue, const char *str, IPAddressEnum1 choiceIpAssignment )
{
    CreateSMSReport();
    current_IRI_parameter->sMS->communicationIdentifier->network_Identifier->network_Element_Identifier = new Network_Element_Identifier(typeOfElement,ip_type, choiceIpTypeValue, str, choiceIpAssignment);
}
    //Struct TimeStamp of SMSReport
void IRIContent::SetSMSReportTimeStampUtcTime(const char *utcTimeStr)
{
    CreateSMSReport();
    current_IRI_parameter->sMS->timeStamp->SetUTCTime(utcTimeStr);
}
void IRIContent::SetSMSReportTimeStampLocalTime(const char *generalizedTimeStr, LocalTimeStampEnum  winterSummerIndication)
{
    CreateSMSReport();
    current_IRI_parameter->sMS->timeStamp->SetLocalTimeStamp(generalizedTimeStr, winterSummerIndication);
}
    //Struct SMS_Contents
void IRIContent::SetSMSReportSMSContentsInitiator(SMS_reportSeqEnum initiator)
{
    CreateSMSReport();
    current_IRI_parameter->sMS->sMS_Contents->initiator = initiator;
}
void IRIContent::CreateSMSReportSMSContentsTransferStatus(SMS_reportSeqEnum1 transfer_status)
{
    CreateSMSReport();
    current_IRI_parameter->sMS->sMS_Contents->transfer_status =  new SMS_reportSeqEnum1(transfer_status);
}
void IRIContent::CreateSMSReportSMSContentsOtherMessage (SMS_reportSeqEnum2	other_message)
{
    CreateSMSReport();
    current_IRI_parameter->sMS->sMS_Contents->other_message =  new SMS_reportSeqEnum2(other_message);
}
void IRIContent::CreateSMSReportSMSContentsContent(const char *content)
{
    CreateSMSReport();
    current_IRI_parameter->sMS->sMS_Contents->content =  new AsnOcts;
    current_IRI_parameter->sMS->sMS_Contents->content->Set(content);
}

//CCLinkIdentifier
void IRIContent::CreateCCLinkIdentifier(const char *cCLinkIdentifier)
{
    current_IRI_parameter->cC_Link_Identifier = new CC_Link_Identifier;
    current_IRI_parameter->cC_Link_Identifier->Set(cCLinkIdentifier);
}

//NationalParameters
void IRIContent::AddNationalParameters(const char *nationalParameter)
{
    if( current_IRI_parameter->national_Parameters == NULL )
        current_IRI_parameter->national_Parameters = new National_Parameters;

    AsnOcts *parameter = current_IRI_parameter->national_Parameters->Append();
    parameter->Set(nationalParameter);
}

//GPRSCorrelationNumber
void IRIContent::CreateGPRSCorrelationNumber(const char *gPRSCorrelationNumber)
{
    current_IRI_parameter->gPRSCorrelationNumber = new GPRSCorrelationNumber;
    current_IRI_parameter->gPRSCorrelationNumber->Set(gPRSCorrelationNumber);
}

//GPRSEvent
/*
  enum GPRSEvent { pDPContextActivation, startOfInterceptionWithPDPContextActive, pDPContextDeactivation,
                   gPRSAttach, gPRSDetach, cellOrRAUpdate, sMS, pDPContextModification };
*/
void IRIContent::CreateGPRSEvent(GPRSEvent gPRSEvent)
{
    current_IRI_parameter->gPRSevent = new GPRSEvent(gPRSEvent);
}

//SGSNDataNodeAddress
void IRIContent::CreateSGSNDataNodeAddress(const char *px25Address)
{
    current_IRI_parameter->sgsnAddress = new DataNodeAddress(px25Address);
}
void IRIContent::CreateSGSNDataNodeAddress(IPAddressEnum ip_type,IP_value::ChoiceIdEnum choiceIpTypeValue, const char *pipAddress )
{
    current_IRI_parameter->sgsnAddress = new DataNodeAddress(ip_type, choiceIpTypeValue, pipAddress);
}
void IRIContent::CreateSGSNDataNodeAddress(IPAddressEnum ip_type,IP_value::ChoiceIdEnum choiceIpTypeValue, const char *pipAddress, IPAddressEnum1 choiceIpAssignment )
{
    current_IRI_parameter->sgsnAddress = new DataNodeAddress(ip_type, choiceIpTypeValue, pipAddress, choiceIpAssignment);
}
//GPRSOperationErrorCode
void IRIContent::CreateGPRSOperationErrorCode(const char *gPRSOperationErrorCode)
{
    current_IRI_parameter->gPRSOperationErrorCode = new AsnOcts;
    current_IRI_parameter->gPRSOperationErrorCode->Set(gPRSOperationErrorCode);
}
//GGSNDataNodeAddress
void IRIContent::CreateGGSNDataNodeAddress(const char *px25Address)
{
    current_IRI_parameter->ggsnAddress = new DataNodeAddress(px25Address);
}
void IRIContent::CreateGGSNDataNodeAddress(IPAddressEnum ip_type,IP_value::ChoiceIdEnum choiceIpTypeValue, const char *pipAddress )
{
    current_IRI_parameter->ggsnAddress = new DataNodeAddress(ip_type, choiceIpTypeValue, pipAddress);
}
void IRIContent::CreateGGSNDataNodeAddress(IPAddressEnum ip_type,IP_value::ChoiceIdEnum choiceIpTypeValue, const char *pipAddress, IPAddressEnum1 choiceIpAssignment )
{
    current_IRI_parameter->ggsnAddress = new DataNodeAddress(ip_type, choiceIpTypeValue, pipAddress, choiceIpAssignment);
}

//NetworkIdentifier
void IRIContent::CreateNetworkIdentifier(const char *operatorIdentifier)
{
    current_IRI_parameter->networkIdentifier = new Network_Identifier;
    current_IRI_parameter->networkIdentifier->operator_Identifier.Set(operatorIdentifier);
}
void IRIContent::SetNetworkIdentifierOperatorIdentifier(const char *operatorIdentifier)
{
    current_IRI_parameter->networkIdentifier->operator_Identifier.Set(operatorIdentifier);
}
void IRIContent::CreateNetworkIdentifierNetworkElementIdentifier(Network_Element_Identifier::ChoiceIdEnum typeOfElement, const char *str)
{
    current_IRI_parameter->networkIdentifier->network_Element_Identifier = new Network_Element_Identifier(typeOfElement, str);
}
void IRIContent::CreateNetworkIdentifierNetworkElementIdentifier(Network_Element_Identifier::ChoiceIdEnum typeOfElement, IPAddressEnum ip_type,IP_value::ChoiceIdEnum choiceIpTypeValue, const char *str )
{
    current_IRI_parameter->networkIdentifier->network_Element_Identifier = new Network_Element_Identifier(typeOfElement, ip_type, choiceIpTypeValue, str);
}
void IRIContent::CreateNetworkIdentifierNetworkElementIdentifier(Network_Element_Identifier::ChoiceIdEnum typeOfElement, IPAddressEnum ip_type,IP_value::ChoiceIdEnum choiceIpTypeValue, const char *str, IPAddressEnum1 choiceIpAssignment )
{
    current_IRI_parameter->networkIdentifier->network_Element_Identifier = new Network_Element_Identifier(typeOfElement, ip_type, choiceIpTypeValue, str, choiceIpAssignment);
}

//SMSOriginatingAddress
void IRIContent::CreateSMSOriginatingAddress(const char *px25Address)
{
    current_IRI_parameter->sMSOriginatingAddress = new DataNodeAddress(px25Address);
}
void IRIContent::CreateSMSOriginatingAddress(IPAddressEnum ip_type,IP_value::ChoiceIdEnum choiceIpTypeValue, const char *pipAddress )
{
    current_IRI_parameter->sMSOriginatingAddress = new DataNodeAddress(ip_type, choiceIpTypeValue, pipAddress);
}
void IRIContent::CreateSMSOriginatingAddress(IPAddressEnum ip_type,IP_value::ChoiceIdEnum choiceIpTypeValue, const char *pipAddress, IPAddressEnum1 choiceIpAssignment )
{
    current_IRI_parameter->sMSOriginatingAddress = new DataNodeAddress(ip_type, choiceIpTypeValue, pipAddress, choiceIpAssignment);
}

//SMSTerminatingAddress
void IRIContent::CreateSMSTerminatingAddress(const char *px25Address)
{
    current_IRI_parameter->sMSTerminatingAddress = new DataNodeAddress(px25Address);
}
void IRIContent::CreateSMSTerminatingAddress(IPAddressEnum ip_type,IP_value::ChoiceIdEnum choiceIpTypeValue, const char *pipAddress )
{
    current_IRI_parameter->sMSTerminatingAddress = new DataNodeAddress(ip_type, choiceIpTypeValue, pipAddress);
}
void IRIContent::CreateSMSTerminatingAddress(IPAddressEnum ip_type,IP_value::ChoiceIdEnum choiceIpTypeValue, const char *pipAddress, IPAddressEnum1 choiceIpAssignment )
{
    current_IRI_parameter->sMSTerminatingAddress = new DataNodeAddress(ip_type, choiceIpTypeValue, pipAddress, choiceIpAssignment);
}

//SIPMessage
void IRIContent::CreateSIPMessage(const char *sIPMessage)
{
    current_IRI_parameter->sIPMessage = new AsnOcts;
    current_IRI_parameter->sIPMessage->Set(sIPMessage );
}
//ServingSGSNNumber
void IRIContent::CreateServingSGSNNumber(const char *servingSGSNNumber)
{
    current_IRI_parameter->servingSGSN_number = new AsnOcts;
    current_IRI_parameter->servingSGSN_number->Set(servingSGSNNumber );
}
//ServingSGSNAddress
void IRIContent::CreateServingSGSNAddress(const char *servingSGSNAddress)
{
    current_IRI_parameter->servingSGSN_address= new AsnOcts;
    current_IRI_parameter->servingSGSN_address->Set(servingSGSNAddress );
}
//NationalHI2ASN1parameters
void IRIContent::CreateNationalHI2ASN1parametersCountryCode(const char *countryCode)
{
    current_IRI_parameter->national_HI2_ASN1parameters = new National_HI2_ASN1parameters;
    current_IRI_parameter->national_HI2_ASN1parameters->countryCode.Set( countryCode);
}





//Private
void  IRIContent::CreateLocation()
{
    if( current_IRI_parameter->locationOfTheTarget == NULL)
        current_IRI_parameter->locationOfTheTarget = new Location;
}

void IRIContent::CreateGSMLocation()
{
    CreateLocation();
    //if( current_IRI_parameter->locationOfTheTarget->gsmLocation == NULL )
    delete current_IRI_parameter->locationOfTheTarget->gsmLocation;
    current_IRI_parameter->locationOfTheTarget->gsmLocation = new GSMLocation;//choice
}

void IRIContent::CreateUMTSLocation()
{
    CreateLocation();
    if( current_IRI_parameter->locationOfTheTarget->umtsLocation == NULL )
        current_IRI_parameter->locationOfTheTarget->umtsLocation = new UMTSLocation;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////

/**	IRISEQUENCE	**/

IRISequence  &IRISequence::AppendCopy (IRIContent &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new IRIContent;
    *newElmt->elmt = elmt;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return *this;
} // AppendCopy


IRISequence  &IRISequence::PrependCopy (IRIContent &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new IRIContent;
    *newElmt->elmt = elmt;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return *this;
} // IRISequence::PrependCopy


// alloc new list elmt, insert it before the
// current element, copy the given elmt into the new elmt
// and return the component type.
// if the current element is null, the new element
// is placed at the beginning of the list.
IRISequence &IRISequence::InsertBeforeAndCopy (IRIContent &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new IRIContent;
    *newElmt->elmt = elmt;

    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return *this;
} // IRISequence::InsertBeforeAndCopy


// alloc new list elmt, insert it after the
// current element, copy given elmt in to new elmt
//  and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
IRISequence  &IRISequence::InsertAfterAndCopy (IRIContent &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new IRIContent;
    *newElmt->elmt = elmt;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return *this;
} // IRISequence::InsertAfterAndCopy


// remove current element from list if current element is not NULL 
// The new current element will be the next element.
// If the current element is the last element in the list
// the second but last element will become the new current element.
void IRISequence::RemoveCurrFromList()
{
    AsnListElmt *del_elmt;

    if (curr != NULL)
    {
        del_elmt = curr;
        count--;

        if (count == 0)
            first = last = curr = NULL;
        else if (curr == first)
        {
            curr = first= first->next;
            first->prev = NULL;
        }
        else if (curr == last)
        {
            curr = last = last->prev;
            last->next = NULL;
        }
        else
        {
            curr->prev->next = curr->next;
            curr->next->prev = curr->prev;
        }

        delete del_elmt->elmt;
        delete del_elmt;
    }
}


AsnLen IRISequence::BEncContent (BUF_TYPE b)
{
    AsnListElmt *currElmt;
    AsnLen elmtLen;
    AsnLen totalLen = 0;
    for (currElmt = last; currElmt != NULL; currElmt = currElmt->prev)
    {
        elmtLen = currElmt->elmt->BEncContent (b);
        totalLen += elmtLen;
    }
    return totalLen;
} // IRISequence::BEncContent


void  IRISequence::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0,
                                  AsnLen &bytesDecoded, ENV_TYPE env)
{
    IRIContent *listElmt;
    AsnTag tag1;
    AsnLen listBytesDecoded = 0;
    AsnLen elmtLen1;

    while ((listBytesDecoded < elmtLen0) || (elmtLen0 == INDEFINITE_LEN))
    {
        tag1 = BDecTag (b, listBytesDecoded, env);
        if ((tag1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
        {
            BDEC_2ND_EOC_OCTET (b, listBytesDecoded, env);
            break;
        }
        if (!((tag1 == MAKE_TAG_ID (CNTX, CONS, 1))
         || (tag1 == MAKE_TAG_ID (CNTX, CONS, 2))
         || (tag1 == MAKE_TAG_ID (CNTX, CONS, 3))
         || (tag1 == MAKE_TAG_ID (CNTX, CONS, 4))))
        {
            Asn1Error << "Unexpected Tag" << endl;
            longjmp (env, -111);
        }

        elmtLen1 = BDecLen (b, listBytesDecoded, env);
        listElmt = Append();
        listElmt->BDecContent (b, tag1, elmtLen1, listBytesDecoded, env);
    }

    bytesDecoded += listBytesDecoded;
} // IRISequence::BDecContent


IRIsContent::IRIsContent()
{
  choiceId = iRIContentCid;
#if TCL
  iRIContent = new IRIContent;
#else
  iRIContent = NULL; // incomplete initialization of mandatory element!
#endif // TCL
}

IRIsContent::IRIsContent (const IRIsContent &)
{
  Asn1Error << "use of incompletely defined IRIsContent::IRIsContent (const IRIsContent &)" << endl;
  abort();
}

IRIsContent::~IRIsContent()
{
  switch (choiceId)
  {
    case iRIContentCid:
      delete iRIContent;
      break;
    case iRISequenceCid:
      delete iRISequence;
      break;
  } // end of switch
} // end of destructor

AsnType *IRIsContent::Clone() const
{
  return new IRIsContent;
}

#if SNACC_DEEP_COPY
IRIsContent &IRIsContent::operator = (const IRIsContent &that)
#else // SNACC_DEEP_COPY
IRIsContent &IRIsContent::operator = (const IRIsContent &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    switch (choiceId)
    {
      case iRIContentCid:
        delete iRIContent;
        break;
      case iRISequenceCid:
        delete iRISequence;
        break;
    }
    switch (choiceId = that.choiceId)
    {
      case iRIContentCid:
        iRIContent = new IRIContent;
        *iRIContent = *that.iRIContent;
        break;
      case iRISequenceCid:
        iRISequence = new IRISequence;
        *iRISequence = *that.iRISequence;
        break;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined IRIsContent &IRIsContent::operator = (const IRIsContent &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
IRIsContent::BEncContent (BUF_TYPE b)
{
  AsnLen l;
  switch (choiceId)
  {
    case iRIContentCid:
      l = iRIContent->BEncContent (b);
      break;

    case iRISequenceCid:
      BEncEocIfNec (b);
      l = iRISequence->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
      break;

  } // end switch
  return l;
} // IRIsContent::BEncContent


void IRIsContent::BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  switch (tag)
  {
    case MAKE_TAG_ID (CNTX, CONS, 1):
    case MAKE_TAG_ID (CNTX, CONS, 2):
    case MAKE_TAG_ID (CNTX, CONS, 3):
    case MAKE_TAG_ID (CNTX, CONS, 4):
      choiceId = iRIContentCid;
      iRIContent = new IRIContent;
        iRIContent->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE):
      choiceId = iRISequenceCid;
      iRISequence = new IRISequence;
        iRISequence->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    default:
      Asn1Error << "ERROR - unexpected tag in CHOICE" << endl;
      longjmp (env, -112);
      break;
  } // end switch
} // IRIsContent::BDecContent


AsnLen IRIsContent::BEnc (BUF_TYPE b)
{
    AsnLen l;
    l = BEncContent (b);
    return l;
}

void IRIsContent::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
    AsnLen elmtLen;
    AsnTag tag;

    /*  CHOICEs are a special case - grab identifying tag */
    /*  this allows easier handling of nested CHOICEs */
    tag = BDecTag (b, bytesDecoded, env);
    elmtLen = BDecLen (b, bytesDecoded, env);
    BDecContent (b, tag, elmtLen, bytesDecoded, env);
}

int IRIsContent::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int IRIsContent::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

